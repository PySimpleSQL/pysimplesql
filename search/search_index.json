{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Reference (more pages to come)","text":""},{"location":"#pysimplesql.pysimplesql--disclaimer-while-pysimplesql-works-with-and-was-inspired-by-the-excellent","title":"DISCLAIMER: While pysimplesql works with and was inspired by the excellent","text":"<p>PySimpleGUI\u2122 project, it has no affiliation.</p>"},{"location":"#pysimplesql.pysimplesql--rapidly-build-and-deploy-database-applications-in-python-pysimplesql-binds","title":"Rapidly build and deploy database applications in Python pysimplesql binds","text":"<p>PySimpleGUI to various databases for rapid, effortless database application development. Makes a great replacement for MS Access or LibreOffice Base! Have the full power and language features of Python while having the power and control of managing your own codebase. pysimplesql not only allows for super simple automatic control (not one single line of SQL needs written to use pysimplesql), but also allows for very low level control for situations that warrant it.</p>"},{"location":"#pysimplesql.pysimplesql--naming-conventions-used-throughout-the-source-code","title":"NAMING CONVENTIONS USED THROUGHOUT THE SOURCE CODE","text":"<p>There is a lot of ambiguity with database terminology, as many terms are used interchangeably in some circumstances, but not in others.  The Internet has post after post debating this topic.  See one example here: https://dba.stackexchange.com/questions/65609/column-vs-field-have-i-been-using-these-terms-incorrectly  # fmt: skip To avoid confusion in the source code, specific naming conventions will be used whenever possible.</p> <p>Naming conventions can fall under 4 categories: - referencing the database (variables, functions, etc. that relate to the database) - referencing the DataSet (variables, functions, etc. that relate to the DataSet) - referencing pysimplesql - referencing PySimpleGUI</p> <ul> <li> <p>Database related:     driver - a SQLDriver derived class     t, table, tables - the database table name(s)     r, row, rows - A group of related data in a table     c, col, cols, column, columns -  A set of values of a particular type     q, query - An SQL query string     domain - the data type of the data (INTEGER, TEXT, etc.)</p> </li> <li> <p>DataSet related:     r, row, rows, df - A row, or collection of rows from  querying the database     c, col, cols, column, columns -  A set of values of a particular type     Record - A collection of fields that make up a row     field - the value found where a row intersects a column</p> </li> <li> <p>pysimplesql related     frm - a Form object     dataset, datasets - a DataSet object, or collection of DataSet objects     data_key - the key (name) of a dataset object</p> </li> <li> <p>PySimpleGUI related     win, window - A PySimpleGUI Window object     element - a Window element     element_key -  a window element key</p> </li> </ul>"},{"location":"#pysimplesql.pysimplesql.TFORM_ENCODE","title":"<code>TFORM_ENCODE: int = 1</code>  <code>module-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.TFORM_DECODE","title":"<code>TFORM_DECODE: int = 0</code>  <code>module-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.PROMPT_MODE","title":"<code>PROMPT_MODE: int = 1</code>  <code>module-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.AUTOSAVE_MODE","title":"<code>AUTOSAVE_MODE: int = 2</code>  <code>module-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.SAVE_FAIL","title":"<code>SAVE_FAIL: int = 1</code>  <code>module-attribute</code>","text":"<p>Save failed due to callback or database error</p>"},{"location":"#pysimplesql.pysimplesql.SAVE_SUCCESS","title":"<code>SAVE_SUCCESS: int = 2</code>  <code>module-attribute</code>","text":"<p>Save was successful</p>"},{"location":"#pysimplesql.pysimplesql.SAVE_NONE","title":"<code>SAVE_NONE: int = 4</code>  <code>module-attribute</code>","text":"<p>There was nothing to save</p>"},{"location":"#pysimplesql.pysimplesql.keygen","title":"<code>keygen = KeyGen(separator=':')</code>  <code>module-attribute</code>","text":"<p>This is a global keygen instance for general purpose use.</p> <p>See KeyGen for more info</p>"},{"location":"#pysimplesql.pysimplesql.ElementType","title":"<code>ElementType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Types for automatic mapping.</p>"},{"location":"#pysimplesql.pysimplesql.EventType","title":"<code>EventType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Event Types.</p>"},{"location":"#pysimplesql.pysimplesql.EventType.FUNCTION","title":"<code>FUNCTION = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Custom events (requires 'function')</p>"},{"location":"#pysimplesql.pysimplesql.PromptSaveReturn","title":"<code>PromptSaveReturn</code>","text":"<p>             Bases: <code>Enum</code></p> <p>prompt_save return enums.</p>"},{"location":"#pysimplesql.pysimplesql.PromptSaveReturn.PROCEED","title":"<code>PROCEED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>After prompt_save, proceeded to save</p>"},{"location":"#pysimplesql.pysimplesql.PromptSaveReturn.NONE","title":"<code>NONE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Found no records changed</p>"},{"location":"#pysimplesql.pysimplesql.PromptSaveReturn.DISCARDED","title":"<code>DISCARDED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>User declined to save</p>"},{"location":"#pysimplesql.pysimplesql.Boolean","title":"<code>Boolean</code>","text":"<p>             Bases: <code>Flag</code></p> <p>Enumeration class providing a convenient way to differentiate when a function may return a 'truthy' or 'falsy' value, such as 1, \"\", or 0.</p> <p>Used in value_changed</p>"},{"location":"#pysimplesql.pysimplesql.Boolean.TRUE","title":"<code>TRUE = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents the boolean value True.</p>"},{"location":"#pysimplesql.pysimplesql.Boolean.FALSE","title":"<code>FALSE = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents the boolean value False.</p>"},{"location":"#pysimplesql.pysimplesql.ValidateMode","title":"<code>ValidateMode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration class representing different validation modes.</p>"},{"location":"#pysimplesql.pysimplesql.ValidateMode.STRICT","title":"<code>STRICT = 'strict'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Strict prevents invalid values from being entered.</p>"},{"location":"#pysimplesql.pysimplesql.ValidateMode.RELAXED","title":"<code>RELAXED = 'relaxed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Relaxed allows invalid input, but ensures validation occurs before saving to the database.</p>"},{"location":"#pysimplesql.pysimplesql.ValidateMode.DISABLED","title":"<code>DISABLED = 'disabled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Validation is turned off, and no checks or restrictions are applied.</p>"},{"location":"#pysimplesql.pysimplesql.ValidateRule","title":"<code>ValidateRule</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Collection of enums used ValidateResponse.</p>"},{"location":"#pysimplesql.pysimplesql.ValidateRule.REQUIRED","title":"<code>REQUIRED = 'required'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Required field. Either set as 'NOTNULL' in database, or later in ColumnClass</p>"},{"location":"#pysimplesql.pysimplesql.ValidateRule.PYTHON_TYPE","title":"<code>PYTHON_TYPE = 'python_type'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>After casting, value is still not correct python type.</p>"},{"location":"#pysimplesql.pysimplesql.ValidateRule.PRECISION","title":"<code>PRECISION = 'precision'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Value has too many numerical places</p>"},{"location":"#pysimplesql.pysimplesql.ValidateRule.MIN_VALUE","title":"<code>MIN_VALUE = 'min_value'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Value less than set mininum value</p>"},{"location":"#pysimplesql.pysimplesql.ValidateRule.MAX_VALUE","title":"<code>MAX_VALUE = 'max_value'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Value greater than set maximum value</p>"},{"location":"#pysimplesql.pysimplesql.ValidateRule.MIN_LENGTH","title":"<code>MIN_LENGTH = 'min_length'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Value's length is less than minimum length</p>"},{"location":"#pysimplesql.pysimplesql.ValidateRule.MAX_LENGTH","title":"<code>MAX_LENGTH = 'max_length'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Value's length is greater than than maximum length</p>"},{"location":"#pysimplesql.pysimplesql.ValidateRule.CUSTOM","title":"<code>CUSTOM = 'custom'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Special enum to be used when returning a ValidateResponse in your own `custom_validate_fn'.</p> Example <pre><code>import re\ndef is_valid_email(email):\n    valid_email = re.match(r\".+\\@.+\\..+\", email) is not None\n    if not valid_email:\n        return ss.ValidateResponse(\n            ss.ValidateRule.CUSTOM, email, \" is not a valid email\"\n        )\n    return ss.ValidateResponse()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ValidateResponse","title":"<code>ValidateResponse</code>  <code>dataclass</code>","text":"<p>Represents the response returned by validate method.</p> <p>Attributes:</p> Name Type Description <code>exception</code> <code>Union[ValidateRule, None]</code> <p>Indicates validation failure, if any. None for valid responses.</p> <code>value</code> <code>str</code> <p>The value that was being validated.</p> <code>rule</code> <code>str</code> <p>The specific ValidateRule that caused the exception, if applicable.</p> Example <p>How how to create a ok popup from an exception:</p> <pre><code>```python\nresponse = frm[data_key].column_info[col].validate(value)\nif response.exception:\nmsg = f\"{ss.lang.dataset_save_validate_error_header}\"\nfield = ss.lang.dataset_save_validate_error_field.format_map(\nss.LangFormat(field=col)\n)\nexception = ss.lang[response.exception].format_map(\nss.LangFormat(value=response.value, rule=response.rule)\n)\nmsg += f\"{field}{exception}\"\nfrm.popup.ok(lang.dataset_save_validate_error_title, msg)\n```\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.CellFormatFn","title":"<code>CellFormatFn</code>","text":"<p>Collection of functions to pre-format values before populating <code>sg.Table</code> values.</p> <p>Each function must accept and return 1 value. Additional arguments can be filled in via a lambda.</p> Example <pre><code>fn = lambda x: ss.CellFormatFn.decimal_places(x, 2)\nfrm[data_key].column_info[col].cell_format_fn = fn\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.CellFormatFn.bool_to_checkbox","title":"<code>bool_to_checkbox(val)</code>  <code>staticmethod</code>","text":"<p>Converts a boolean value to a themepack.checkbox_true/false.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>@staticmethod\ndef bool_to_checkbox(\n    val: Union[str, int, bool]\n) -&gt; Union[themepack.checkbox_true, themepack.checkbox_false]:\n\"\"\"Converts a boolean value to a themepack.checkbox_true/false.\"\"\"\n    return (\n        themepack.checkbox_true\n        if checkbox_to_bool(val)\n        else themepack.checkbox_false\n    )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.CellFormatFn.decimal_places","title":"<code>decimal_places(val, decimal_places)</code>  <code>staticmethod</code>","text":"<p>Format the value to specified decimal places using the system locale.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>@staticmethod\ndef decimal_places(val: Union[int, float, Decimal], decimal_places: int):\n\"\"\"Format the value to specified decimal places using the system locale.\"\"\"\n    format_string = f\"%.{decimal_places}f\"\n    if val not in EMPTY:\n        return locale.format_string(format_string, val)\n    return val\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.TableRow","title":"<code>TableRow(pk, *args, **kwargs)</code>","text":"<p>             Bases: <code>list</code></p> <p>Convenience class used by Tables to associate a primary key with a row of data.</p> <p>Note: This is typically not used by the end user.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, pk: int, *args, **kwargs) -&gt; None:\n    self.pk = pk\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ElementRow","title":"<code>ElementRow(pk, val)</code>","text":"<p>Convenience class used by listboxes and comboboxes to associate a primary key with a row of data.</p> <p>Note: This is typically not used by the end user.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, pk: int, val: Union[str, int]) -&gt; None:\n    self.pk = pk\n    self.val = val\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Relationship","title":"<code>Relationship</code>  <code>dataclass</code>","text":"<p>Information from Foreign-Keys.</p> <p>Parameters:</p> Name Type Description Default <code>join_type</code> <code>str</code> <p>The join type. I.e. \"LEFT JOIN\", \"INNER JOIN\", etc.</p> required <code>child_table</code> <code>str</code> <p>The table name of the fk table</p> required <code>fk_column</code> <code>Union[str, int]</code> <p>The child table's foreign key column</p> required <code>parent_table</code> <code>str</code> <p>The table name of the parent table</p> required <code>pk_column</code> <code>Union[str, int]</code> <p>The parent table's primary key column</p> required <code>update_cascade</code> <code>bool</code> <p>True if the child's fk_column ON UPDATE rule is 'CASCADE'</p> required <code>delete_cascade</code> <code>bool</code> <p>True if the child's fk_column ON DELETE rule is 'CASCADE'</p> required <code>driver</code> <code>Driver</code> <p>A SQLDriver instance.</p> required"},{"location":"#pysimplesql.pysimplesql.Relationship.__str__","title":"<code>__str__()</code>","text":"<p>Return a join clause when cast to a string.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a join clause when cast to a string.\"\"\"\n    return self.driver.relationship_to_join_clause(self)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.RelationshipStore","title":"<code>RelationshipStore</code>  <code>dataclass</code>","text":"<p>             Bases: <code>list</code></p> <p>Used to track primary/foreign key relationships in the database.</p> <p>See the following for more information: add_relationship and auto_add_relationships.</p> <p>Note: This class is not typically used the end user</p>"},{"location":"#pysimplesql.pysimplesql.RelationshipStore.get_rels_for","title":"<code>get_rels_for(table)</code>","text":"<p>Return the relationships for the passed-in table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table to get relationships for</p> required <p>Returns:</p> Type Description <code>List[Relationship]</code> <p>A list of @Relationship objects</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_rels_for(self, table: str) -&gt; List[Relationship]:\n\"\"\"Return the relationships for the passed-in table.\n\n    Args:\n        table: The table to get relationships for\n\n    Returns:\n        A list of @Relationship objects\n    \"\"\"\n    return [r for r in self if r.child_table == table]\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.RelationshipStore.get_update_cascade_tables","title":"<code>get_update_cascade_tables(table)</code>","text":"<p>Return a unique list of the relationships for this table that should requery with this table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table to get cascaded children for</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A unique list of table names</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_update_cascade_tables(self, table: str) -&gt; List[str]:\n\"\"\"Return a unique list of the relationships for this table that should requery\n    with this table.\n\n    Args:\n        table: The table to get cascaded children for\n\n    Returns:\n        A unique list of table names\n    \"\"\"\n    rel = [\n        r.child_table\n        for r in self\n        if r.parent_table == table and r.on_update_cascade\n    ]\n    # make unique\n    return list(set(rel))\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.RelationshipStore.get_delete_cascade_tables","title":"<code>get_delete_cascade_tables(table)</code>","text":"<p>Return a unique list of the relationships for this table that should be deleted with this table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table to get cascaded children for</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A unique list of table names</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_delete_cascade_tables(self, table: str) -&gt; List[str]:\n\"\"\"Return a unique list of the relationships for this table that should be\n    deleted with this table.\n\n    Args:\n        table: The table to get cascaded children for\n\n    Returns:\n        A unique list of table names\n    \"\"\"\n    rel = [\n        r.child_table\n        for r in self\n        if r.parent_table == table and r.on_delete_cascade\n    ]\n    # make unique\n    return list(set(rel))\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.RelationshipStore.get_parent","title":"<code>get_parent(table)</code>","text":"<p>Return the parent table for the passed-in table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table (str) to get relationships for</p> required <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>The name of the Parent table, or None if there is none</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_parent(self, table: str) -&gt; Union[str, None]:\n\"\"\"Return the parent table for the passed-in table.\n\n    Args:\n        table: The table (str) to get relationships for\n\n    Returns:\n        The name of the Parent table, or None if there is none\n    \"\"\"\n    for r in self:\n        if r.child_table == table and r.on_update_cascade:\n            return r.parent_table\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.RelationshipStore.is_parent_virtual","title":"<code>is_parent_virtual(table, frm)</code>","text":"<p>Return True if current row of parent table is virtual.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table (str) to get relationships for</p> required <code>frm</code> <code>Form</code> <p>Form reference</p> required <p>Returns:</p> Type Description <code>Union[bool, None]</code> <p>True if current row of parent table is virtual</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def is_parent_virtual(self, table: str, frm: Form) -&gt; Union[bool, None]:\n\"\"\"Return True if current row of parent table is virtual.\n\n    Args:\n        table: The table (str) to get relationships for\n        frm: Form reference\n\n    Returns:\n        True if current row of parent table is virtual\n    \"\"\"\n    for r in self:\n        if r.child_table == table and r.on_update_cascade:\n            try:\n                return frm[r.parent_table].pk_is_virtual()\n            except AttributeError:\n                return False\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.RelationshipStore.get_update_cascade_fk_column","title":"<code>get_update_cascade_fk_column(table)</code>","text":"<p>Return the cascade fk that filters for the passed-in table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table name of the child</p> required <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>The name of the cascade-fk, or None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_update_cascade_fk_column(self, table: str) -&gt; Union[str, None]:\n\"\"\"Return the cascade fk that filters for the passed-in table.\n\n    Args:\n        table: The table name of the child\n\n    Returns:\n        The name of the cascade-fk, or None\n    \"\"\"\n    for r in self:\n        if r.child_table == table and r.on_update_cascade:\n            return r.fk_column\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.RelationshipStore.get_delete_cascade_fk_column","title":"<code>get_delete_cascade_fk_column(table)</code>","text":"<p>Return the cascade fk that filters for the passed-in table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table name of the child</p> required <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>The name of the cascade-fk, or None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_delete_cascade_fk_column(self, table: str) -&gt; Union[str, None]:\n\"\"\"Return the cascade fk that filters for the passed-in table.\n\n    Args:\n        table: The table name of the child\n\n    Returns:\n        The name of the cascade-fk, or None\n    \"\"\"\n    for r in self:\n        if r.child_table == table and r.on_delete_cascade:\n            return r.fk_column\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.RelationshipStore.get_dependent_columns","title":"<code>get_dependent_columns(frm_reference, table)</code>","text":"<p>Returns a dictionary of the key and column names that use the description_column text of the given parent table in their ElementRow objects.</p> <p>This method is used to determine which GUI field and selector elements to update when a new description_column value is saved. The returned dictionary contains the key as the key and the corresponding column name as the value.</p> <p>Parameters:</p> Name Type Description Default <code>frm_reference</code> <code>Form</code> <p>A Form object representing the parent form.</p> required <code>table</code> <code>str</code> <p>The name of the parent table.</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>A dictionary of <code>{datakey: column}</code> pairs.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_dependent_columns(self, frm_reference: Form, table: str) -&gt; Dict[str, str]:\n\"\"\"Returns a dictionary of the `DataSet.key` and column names that use the\n    description_column text of the given parent table in their `ElementRow`\n    objects.\n\n    This method is used to determine which GUI field and selector elements to update\n    when a new `DataSet.description_column` value is saved. The returned dictionary\n    contains the `DataSet.key` as the key and the corresponding column name as the\n    value.\n\n    Args:\n        frm_reference: A `Form` object representing the parent form.\n        table: The name of the parent table.\n\n    Returns:\n        A dictionary of `{datakey: column}` pairs.\n    \"\"\"\n    return {\n        frm_reference[dataset].key: r.fk_column\n        for r in self\n        for dataset in frm_reference.datasets\n        if r.parent_table == table\n        and frm_reference[dataset].table == r.child_table\n        and not r.on_update_cascade\n    }\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ElementMap","title":"<code>ElementMap</code>  <code>dataclass</code>","text":"<p>Map a PySimpleGUI element to a specific DataSet column.</p> <p>This is what makes the GUI automatically update to the contents of the database. This happens automatically when a PySimpleGUI Window is bound to a Form by using the bind parameter of Form creation, or by executing auto_map_elements() as long as the Table.column naming convention is used, This method can be used to manually map any element to any DataSet column regardless of naming convention.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>A PySimpleGUI Element</p> required <code>dataset</code> <code>DataSet</code> <p>A DataSet object</p> required <code>column</code> <code>str</code> <p>The name of the column to bind to the element</p> required <code>where_column</code> <code>str</code> <p>Used for key, value shorthand</p> <code>None</code> <code>where_value</code> <code>str</code> <p>Used for key, value shorthand</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p>"},{"location":"#pysimplesql.pysimplesql.CurrentRow","title":"<code>CurrentRow</code>  <code>dataclass</code>","text":""},{"location":"#pysimplesql.pysimplesql.CurrentRow.has_backup","title":"<code>has_backup: bool</code>  <code>property</code>","text":"<p>Returns True if the current_row has a backup row, and False otherwise.</p> <p>A pandas Series object is stored rows.attrs[\"row_backup\"] before a 'CellEdit' or 'LiveUpdate' operation is initiated, so that it can be compared in records_changed and save_record or used to restore if changes are discarded during a prompt_save operations.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if a backup row is present that matches, and False otherwise.</p>"},{"location":"#pysimplesql.pysimplesql.CurrentRow.pk","title":"<code>pk: int</code>  <code>property</code>","text":"<p>Get the primary key of the currently selected record.</p> <p>Returns:</p> Type Description <code>int</code> <p>the primary key</p>"},{"location":"#pysimplesql.pysimplesql.CurrentRow.backup","title":"<code>backup()</code>","text":"<p>Creates a backup copy of the current row in rows.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def backup(self) -&gt; None:\n\"\"\"Creates a backup copy of the current row in `DataSet.rows`.\"\"\"\n    rows = self.dataset.rows\n    if not self.has_backup:\n        rows.attrs[\"row_backup\"] = self.get().copy()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.CurrentRow.restore_backup","title":"<code>restore_backup()</code>","text":"<p>Restores the backup row to the current row in rows.</p> <p>This method replaces the current row in the dataset with the backup row, if a backup row is present.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def restore_backup(self) -&gt; None:\n\"\"\"Restores the backup row to the current row in `DataSet.rows`.\n\n    This method replaces the current row in the dataset with the backup row, if a\n    backup row is present.\n    \"\"\"\n    rows = self.dataset.rows\n    if self.has_backup:\n        rows.iloc[self.index] = rows.attrs[\"row_backup\"].copy()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.CurrentRow.get","title":"<code>get()</code>","text":"<p>Get the row for the currently selected record of this table.</p> <p>Returns:</p> Type Description <code>Union[Series, None]</code> <p>A pandas Series object</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get(self) -&gt; Union[pd.Series, None]:\n\"\"\"Get the row for the currently selected record of this table.\n\n    Returns:\n        A pandas Series object\n    \"\"\"\n    rows = self.dataset.rows\n    if not rows.empty:\n        # force the current.index to be in bounds!\n        # For child reparenting\n        self.index = self.index\n\n        # make sure to return as python type\n        return rows.astype(\"O\").iloc[self.index]\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.CurrentRow.get_original","title":"<code>get_original()</code>","text":"<p>Returns a copy of current row as it was fetched in a query from SQLDriver.</p> <p>If a backup of the current row is present, this method returns a copy of that row. Otherwise, it returns a copy of the current row. Returns None if rows is empty.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_original(self) -&gt; pd.Series:\n\"\"\"Returns a copy of current row as it was fetched in a query from `SQLDriver`.\n\n    If a backup of the current row is present, this method returns a copy of that\n    row. Otherwise, it returns a copy of the current row. Returns None if\n    `DataSet.rows` is empty.\n    \"\"\"\n    rows = self.dataset.rows\n    if self.has_backup:\n        return rows.attrs[\"row_backup\"].copy()\n    if not rows.empty:\n        return self.get().copy()\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.CurrentRow.get_value","title":"<code>get_value(column, default='')</code>","text":"<p>Get the value for the supplied column in the current row.</p> <p>You can also use indexing of the Form object to get the current value of a column I.e. frm[{DataSet}].[{column}].</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column you want to get the value from</p> required <code>default</code> <code>Union[str, int]</code> <p>A value to return if the record is null</p> <code>''</code> <p>Returns:</p> Type Description <code>Union[str, int]</code> <p>The value of the column requested</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_value(self, column: str, default: Union[str, int] = \"\") -&gt; Union[str, int]:\n\"\"\"Get the value for the supplied column in the current row.\n\n    You can also use indexing of the `Form` object to get the current value of a\n    column I.e. frm[{DataSet}].[{column}].\n\n    Args:\n        column: The column you want to get the value from\n        default: A value to return if the record is null\n\n    Returns:\n        The value of the column requested\n    \"\"\"\n    logger.debug(f\"Getting current record for {self.dataset.table}.{column}\")\n    if self.dataset.row_count:\n        if self.get()[column] is not None:\n            return self.get()[column]\n        return default\n    return default\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.CurrentRow.set_value","title":"<code>set_value(column, value, write_event=False)</code>","text":"<p>Set the value for the supplied column in the current row, making a backup if needed.</p> <p>You can also use indexing of the Form object to set the current value of a column. I.e. frm[{DataSet}].[{column}] = 'New value'.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column you want to set the value for</p> required <code>value</code> <code>Union[str, int]</code> <p>A value to set the current record's column to</p> required <code>write_event</code> <code>bool</code> <p>(optional) If True, writes an event to PySimpleGui as after_record_edit.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_value(\n    self, column: str, value: Union[str, int], write_event: bool = False\n) -&gt; None:\n\"\"\"Set the value for the supplied column in the current row, making a backup if\n    needed.\n\n    You can also use indexing of the `Form` object to set the current value of a\n    column. I.e. frm[{DataSet}].[{column}] = 'New value'.\n\n    Args:\n        column: The column you want to set the value for\n        value: A value to set the current record's column to\n        write_event: (optional) If True, writes an event to PySimpleGui as\n            `after_record_edit`.\n\n    Returns:\n        None\n    \"\"\"\n    rows = self.dataset.rows\n    dataset = self.dataset\n    logger.debug(f\"Setting current record for {dataset.key}.{column} = {value}\")\n    self.backup()\n    rows.loc[rows.index[self.index], column] = value\n    if write_event:\n        self.dataset.frm.window.write_event_value(\n            \"after_record_edit\",\n            {\n                \"frm_reference\": dataset.frm,\n                \"data_key\": dataset.key,\n                \"column\": column,\n                \"value\": value,\n            },\n        )\n    # call callback\n    if \"after_record_edit\" in dataset.callbacks:\n        dataset.callbacks[\"after_record_edit\"](\n            dataset.frm, dataset.frm.window, dataset.key\n        )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet","title":"<code>DataSet</code>  <code>dataclass</code>","text":"<p>DataSet objects are used for an internal representation of database tables.</p> <p>DataSet instances are added by the following Form methods: add_dataset, auto_add_datasets. A DataSet is synonymous for a SQL Table (though you can technically have multiple DataSet objects referencing the same table, with each DataSet object having its own sorting, where clause, etc.). Note: While users will interact with DataSet objects often in pysimplesql, they typically aren't created manually by the user.</p> <p>Parameters:</p> Name Type Description Default <code>data_key</code> <code>InitVar[str]</code> <p>The name you are assigning to this DataSet object (I.e. 'people') Accessible via key.</p> required <code>frm_reference</code> <code>InitVar[Form]</code> <p>This is a reference to the @ Form object, for convenience. Accessible via frm</p> required <code>table</code> <code>str</code> <p>Name of the table</p> required <code>pk_column</code> <code>str</code> <p>The name of the column containing the primary key for this table.</p> required <code>description_column</code> <code>str</code> <p>The name of the column used for display to users (normally in a combobox or listbox).</p> required <code>query</code> <code>Optional[str]</code> <p>You can optionally set an initial query here. If none is provided, it will default to \"SELECT * FROM {table}\"</p> <code>''</code> <code>order_clause</code> <code>Optional[str]</code> <p>The sort order of the returned query. If none is provided it will default to \"ORDER BY {description_column} ASC\"</p> <code>''</code> <code>filtered</code> <code>bool</code> <p>(optional) If True, the relationships will be considered and an appropriate WHERE clause will be generated. False will display all records in the table.</p> <code>True</code> <code>prompt_save</code> <p>(optional) Default: Mode set in Form. Prompt to save changes when dirty records are present. There are two modes available, PROMPT_MODE to prompt to save when unsaved changes are present. AUTOSAVE_MODE to automatically save when unsaved changes are present.</p> required <code>save_quiet</code> <code>bool</code> <p>(optional) Default: Set in Form. True to skip info popup on save. Error popups will still be shown.</p> <code>None</code> <code>duplicate_children</code> <code>bool</code> <p>(optional) Default: Set in Form. If record has children, prompt user to choose to duplicate current record, or both.</p> <code>None</code> <code>validate_mode</code> <code>ValidateMode</code> <p>STRICT to prevent invalid values from being entered. RELAXED allows invalid input, but ensures validation occurs before saving to the database.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>key</code> <code>str</code> <p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.description_column","title":"<code>description_column: str</code>  <code>instance-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.key","title":"<code>key: str = field_(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Short for 'data_key'</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.frm","title":"<code>frm: Form = field_(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.driver","title":"<code>driver: Driver = field_(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.relationships","title":"<code>relationships: RelationshipStore = field_(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.rows","title":"<code>rows: pd.DataFrame = field_(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.join_clause","title":"<code>join_clause: str = field_(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.where_clause","title":"<code>where_clause: str = field_(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.search_order","title":"<code>search_order: List[str] = field_(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TODO</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.row_count","title":"<code>row_count: int</code>  <code>property</code>","text":"<p>Returns the number of rows in the dataset. If the dataset is not a pandas DataFrame, returns 0.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of rows in the dataset.</p>"},{"location":"#pysimplesql.pysimplesql.DataSet.__getitem__","title":"<code>__getitem__(column)</code>","text":"<p>Retrieve the value of the specified column in the current row.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The key of the column to retrieve.</p> required <p>Returns:</p> Type Description <code>Union[str, int]</code> <p>The current value of the specified column.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __getitem__(self, column: str) -&gt; Union[str, int]:\n\"\"\"Retrieve the value of the specified column in the current row.\n\n    Args:\n        column: The key of the column to retrieve.\n\n    Returns:\n        The current value of the specified column.\n    \"\"\"\n    return self.current.get_value(column)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.__setitem__","title":"<code>__setitem__(column, value)</code>","text":"<p>Set the value of the specified column in the current row.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <p>The key of the column to set.</p> required <code>value</code> <code>Union[str, int]</code> <p>The value to set the column to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __setitem__(self, column, value: Union[str, int]) -&gt; None:\n\"\"\"Set the value of the specified column in the current row.\n\n    Args:\n        column: The key of the column to set.\n        value: The value to set the column to.\n\n    Returns:\n        None\n    \"\"\"\n    self.current.set_value(column, value)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.purge_form","title":"<code>purge_form(frm, reset_keygen)</code>  <code>classmethod</code>","text":"<p>Purge the tracked instances related to frm.</p> <p>Parameters:</p> Name Type Description Default <code>frm</code> <code>Form</code> <p>the Form to purge DataSet` instances from</p> required <code>reset_keygen</code> <code>bool</code> <p>Reset the keygen after purging?</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>@classmethod\ndef purge_form(cls, frm: Form, reset_keygen: bool) -&gt; None:\n\"\"\"Purge the tracked instances related to frm.\n\n    Args:\n        frm: the `Form` to purge `DataSet`` instances from\n        reset_keygen: Reset the keygen after purging?\n\n    Returns:\n        None\n    \"\"\"\n    new_instances = []\n    selector_keys = []\n\n    for dataset in DataSet.instances:\n        if dataset.frm != frm:\n            new_instances.append(dataset)\n        else:\n            logger.debug(\n                f\"Removing DataSet {dataset.key} related to \"\n                f\"{frm.driver.__class__.__name__}\"\n            )\n            # we need to get a list of elements to purge from the keygen\n            for s in dataset.selector:\n                selector_keys.append(s[\"element\"].key)\n\n    # Reset the keygen for selectors and elements from this Form\n    # This is probably a little hack-ish, perhaps I should relocate the keygen?\n    if reset_keygen:\n        for k in selector_keys:\n            keygen.reset_key(k)\n        keygen.reset_from_form(frm)\n    # Update the internally tracked instances\n    DataSet.instances = new_instances\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_prompt_save","title":"<code>set_prompt_save(mode)</code>","text":"<p>Set the prompt to save action when navigating records.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>Use PROMPT_MODE to prompt to save when unsaved changes are present. AUTOSAVE_MODE to automatically save when unsaved changes are present.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_prompt_save(self, mode: int) -&gt; None:\n\"\"\"Set the prompt to save action when navigating records.\n\n    Args:\n        mode: Use `PROMPT_MODE` to prompt to save when unsaved changes are present.\n            `AUTOSAVE_MODE` to automatically save when unsaved changes are present.\n\n    Returns:\n        None\n    \"\"\"\n    self._prompt_save = mode\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_search_order","title":"<code>set_search_order(order)</code>","text":"<p>Set the search order when using the search box.</p> <p>This is a list of column names to be searched, in order</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>List[str]</code> <p>A list of column names to search</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_search_order(self, order: List[str]) -&gt; None:\n\"\"\"Set the search order when using the search box.\n\n    This is a list of column names to be searched, in order\n\n    Args:\n        order: A list of column names to search\n\n    Returns:\n        None\n    \"\"\"\n    self.search_order = order\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_callback","title":"<code>set_callback(callback, fctn)</code>","text":"<p>Set DataSet callbacks. A runtime error will be thrown if the callback is not supported.</p> The following callbacks are supported <ul> <li>before_save: called before a record is saved. The save will continue if     the callback returns true, or the record will rollback if the callback     returns false.</li> <li>after_save: called after a record is saved. The save will commit to the     database if the callback returns true, else it will rollback the     transaction</li> <li>before_update: Alias for before_save</li> <li>after_update:  Alias for after_save</li> <li>before_delete: called before a record is deleted.  The delete will move     forward if the callback returns true, else the transaction will rollback</li> <li>after_delete: called after a record is deleted. The delete will commit to     the database if the callback returns true, else it will rollback the     transaction</li> <li>before_duplicate: called before a record is duplicate.  The duplicate will     move forward if the callback returns true, else the transaction will     rollback</li> <li>after_duplicate: called after a record is duplicate. The duplicate will     commit to the database if the callback returns true, else it will     rollback the transaction</li> <li>before_search: called before searching.  The search will continue if the     callback returns True</li> <li>after_search: called after a search has been performed.  The record change     will undo if the callback returns False</li> <li>record_changed: called after a record has changed (previous,next, etc.)</li> <li>after_record_edit: called after the internal DataSet row is edited via a     <code>sg.Table</code> cell-edit, or field live-update.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>str</code> <p>The name of the callback, from the list above</p> required <code>fctn</code> <code>Callable[[Form, Window, key], bool]</code> <p>The function to call. Note, the function must take at least two parameters, a Form instance, and a <code>sg.Window</code> instance, with an optional key, and return True or False</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_callback(\n    self, callback: str, fctn: Callable[[Form, sg.Window, DataSet.key], bool]\n) -&gt; None:\n\"\"\"Set DataSet callbacks. A runtime error will be thrown if the callback is not\n    supported.\n\n    The following callbacks are supported:\n        - before_save: called before a record is saved. The save will continue if\n            the callback returns true, or the record will rollback if the callback\n            returns false.\n        - after_save: called after a record is saved. The save will commit to the\n            database if the callback returns true, else it will rollback the\n            transaction\n        - before_update: Alias for before_save\n        - after_update:  Alias for after_save\n        - before_delete: called before a record is deleted.  The delete will move\n            forward if the callback returns true, else the transaction will rollback\n        - after_delete: called after a record is deleted. The delete will commit to\n            the database if the callback returns true, else it will rollback the\n            transaction\n        - before_duplicate: called before a record is duplicate.  The duplicate will\n            move forward if the callback returns true, else the transaction will\n            rollback\n        - after_duplicate: called after a record is duplicate. The duplicate will\n            commit to the database if the callback returns true, else it will\n            rollback the transaction\n        - before_search: called before searching.  The search will continue if the\n            callback returns True\n        - after_search: called after a search has been performed.  The record change\n            will undo if the callback returns False\n        - record_changed: called after a record has changed (previous,next, etc.)\n        - after_record_edit: called after the internal `DataSet` row is edited via a\n            `sg.Table` cell-edit, or `field` live-update.\n\n    Args:\n        callback: The name of the callback, from the list above\n        fctn: The function to call. Note, the function must take at least two\n            parameters, a `Form` instance, and a `sg.Window` instance, with\n            an optional `DataSet.key`, and return True or False\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(f\"Callback {callback} being set on table {self.table}\")\n    supported = [\n        \"before_save\",\n        \"after_save\",\n        \"before_delete\",\n        \"after_delete\",\n        \"before_duplicate\",\n        \"after_duplicate\",\n        \"before_update\",\n        \"after_update\",  # Aliases for before/after_save\n        \"before_search\",\n        \"after_search\",\n        \"record_changed\",\n        \"after_record_edit\",\n    ]\n    if callback in supported:\n        # handle our convenience aliases\n        callback = \"before_save\" if callback == \"before_update\" else callback\n        callback = \"after_save\" if callback == \"after_update\" else callback\n        self.callbacks[callback] = lambda *args: self._invoke_callback(fctn, *args)\n    else:\n        raise RuntimeError(f'Callback \"{callback}\" not supported.')\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_transform","title":"<code>set_transform(fn)</code>","text":"<p>Set a transform on the data for this DataSet.</p> <p>Here you can set custom a custom transform to both decode data from the database and encode data written to the database. This allows you to have dates stored as timestamps in the database yet work with a human-readable format in the GUI and within PySimpleSQL. This transform happens only while PySimpleSQL actually reads from or writes to the database.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>A callable function to preform encode/decode. This function should take three arguments: query, row (which will be populated by a dictionary of the row data), and an encode parameter (1 to encode, 0 to decode - see constants TFORM_ENCODE and TFORM_DECODE). Note that this transform works on one row at a time. See the example 'journal_with_data_manipulation.py' for a usage example.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_transform(self, fn: Callable) -&gt; None:\n\"\"\"Set a transform on the data for this `DataSet`.\n\n    Here you can set custom a custom transform to both decode data from the\n    database and encode data written to the database. This allows you to have dates\n    stored as timestamps in the database yet work with a human-readable format in\n    the GUI and within PySimpleSQL. This transform happens only while PySimpleSQL\n    actually reads from or writes to the database.\n\n    Args:\n        fn: A callable function to preform encode/decode. This function should\n            take three arguments: query, row (which will be populated by a\n            dictionary of the row data), and an encode parameter (1 to encode, 0 to\n            decode - see constants `TFORM_ENCODE` and `TFORM_DECODE`). Note that\n            this transform works on one row at a time. See the example\n            'journal_with_data_manipulation.py' for a usage example.\n\n    Returns:\n        None\n    \"\"\"\n    self.transform = fn\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_query","title":"<code>set_query(query)</code>","text":"<p>Set the query string for the DataSet.</p> <p>This is more for advanced users.  It defaults to \"SELECT * FROM {table};\" This can override the default</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string you would like to associate with the table</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_query(self, query: str) -&gt; None:\n\"\"\"Set the query string for the `DataSet`.\n\n    This is more for advanced users.  It defaults to \"SELECT * FROM {table};\"\n    This can override the default\n\n    Args:\n        query: The query string you would like to associate with the table\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(f\"Setting {self.table} query to {query}\")\n    self.query = query\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_join_clause","title":"<code>set_join_clause(clause)</code>","text":"<p>Set the DataSet object's join string.</p> <p>This is more for advanced users, as it will automatically generate from the database Relationships otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>clause</code> <code>str</code> <p>The join clause, such as \"LEFT JOIN That on This.pk=That.fk\"</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_join_clause(self, clause: str) -&gt; None:\n\"\"\"Set the `DataSet` object's join string.\n\n    This is more for advanced users, as it will automatically generate from the\n    database Relationships otherwise.\n\n    Args:\n        clause: The join clause, such as \"LEFT JOIN That on This.pk=That.fk\"\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(f\"Setting {self.table} join clause to {clause}\")\n    self.join_clause = clause\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_where_clause","title":"<code>set_where_clause(clause)</code>","text":"<p>Set the DataSet object's where clause.</p> <p>This is ADDED TO the auto-generated where clause from Relationship data</p> <p>Parameters:</p> Name Type Description Default <code>clause</code> <code>str</code> <p>The where clause, such as \"WHERE pkThis=100\"</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_where_clause(self, clause: str) -&gt; None:\n\"\"\"Set the `DataSet` object's where clause.\n\n    This is ADDED TO the auto-generated where clause from Relationship data\n\n    Args:\n        clause: The where clause, such as \"WHERE pkThis=100\"\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(\n        f\"Setting {self.table} where clause to {clause} for DataSet {self.key}\"\n    )\n    self.where_clause = clause\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_order_clause","title":"<code>set_order_clause(clause)</code>","text":"<p>Set the DataSet object's order clause.</p> <p>This is more for advanced users, as it will automatically generate from the database Relationships otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>clause</code> <code>str</code> <p>The order clause, such as \"Order by name ASC\"</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_order_clause(self, clause: str) -&gt; None:\n\"\"\"Set the `DataSet` object's order clause.\n\n    This is more for advanced users, as it will automatically generate from the\n    database Relationships otherwise.\n\n    Args:\n        clause: The order clause, such as \"Order by name ASC\"\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(f\"Setting {self.table} order clause to {clause}\")\n    self.order_clause = clause\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.update_column_info","title":"<code>update_column_info(column_info=None)</code>","text":"<p>Generate column information for the DataSet object.</p> <p>This may need done, for example, when a manual query using joins is used. This is more for advanced users.</p> <p>Parameters:</p> Name Type Description Default <code>column_info</code> <code>ColumnInfo</code> <p>(optional) A ColumnInfo instance. Defaults to being generated by the SQLDriver.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update_column_info(self, column_info: ColumnInfo = None) -&gt; None:\n\"\"\"Generate column information for the `DataSet` object.\n\n    This may need done, for example, when a manual query using joins is used. This\n    is more for advanced users.\n\n    Args:\n        column_info: (optional) A `ColumnInfo` instance. Defaults to being generated\n            by the `SQLDriver`.\n\n    Returns:\n        None\n    \"\"\"\n    # Now we need to set  new column names, as the query could have changed\n    if column_info is not None:\n        self.column_info = column_info\n    else:\n        self.column_info = self.driver.column_info(self.table)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_description_column","title":"<code>set_description_column(column)</code>","text":"<p>Set the DataSet object's description column.</p> <p>This is the column that will display in Listboxes, Comboboxes, Tables, etc. By default, this is initialized to either the 'description','name' or 'title' column, or the 2nd column of the table if none of those columns exist. This method allows you to specify a different column to use as the description for the record.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The name of the column to use</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_description_column(self, column: str) -&gt; None:\n\"\"\"Set the `DataSet` object's description column.\n\n    This is the column that will display in Listboxes, Comboboxes, Tables, etc. By\n    default, this is initialized to either the 'description','name' or 'title'\n    column, or the 2nd column of the table if none of those columns exist. This\n    method allows you to specify a different column to use as the description for\n    the record.\n\n    Args:\n        column: The name of the column to use\n\n    Returns:\n        None\n    \"\"\"\n    self.description_column = column\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.records_changed","title":"<code>records_changed(column=None, recursive=True)</code>","text":"<p>Checks if records have been changed.</p> <p>This is done by comparing PySimpleGUI control values with the stored DataSet values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Limit the changed records search to just the supplied column name</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>True to check related DataSet instances</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True or False on whether changed records were found</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def records_changed(self, column: str = None, recursive: bool = True) -&gt; bool:\n\"\"\"Checks if records have been changed.\n\n    This is done by comparing PySimpleGUI control values with the stored `DataSet`\n    values.\n\n    Args:\n        column: Limit the changed records search to just the supplied column name\n        recursive: True to check related `DataSet` instances\n\n    Returns:\n        True or False on whether changed records were found\n    \"\"\"\n    logger.debug(f'Checking if records have changed in table \"{self.table}\"...')\n\n    # Virtual rows wills always be considered dirty\n    if self.pk_is_virtual():\n        return True\n\n    if self.current.has_backup and not self.current.get().equals(\n        self.current.get_original()\n    ):\n        return True\n\n    dirty = False\n    # First check the current record to see if it's dirty\n    for mapped in self.frm.element_map:\n        # Compare the DB version to the GUI version\n        if mapped.table == self.table:\n            # if passed custom column name\n            if column is not None and mapped.column != column:\n                continue\n\n            # if sg.Text\n            if isinstance(mapped.element, sg.Text):\n                continue\n\n            # don't check if there aren't any rows. Fixes checkbox = '' when no\n            # rows.\n            if not len(self.frm[mapped.table].rows.index):\n                continue\n\n            # Get the element value and cast it, so we can compare it to the\n            # database version.\n            element_val = self.column_info[mapped.column].cast(mapped.element.get())\n\n            # Get the table value.  If this is a keyed element, we need figure out\n            # the appropriate table column.\n            table_val = None\n            if mapped.where_column is not None:\n                for _, row in self.rows.iterrows():\n                    if row[mapped.where_column] == mapped.where_value:\n                        table_val = row[mapped.column]\n            else:\n                table_val = self[mapped.column]\n\n            new_value = self.value_changed(\n                mapped.column,\n                table_val,\n                element_val,\n                bool(isinstance(mapped.element, sg.Checkbox)),\n            )\n            if new_value is not Boolean.FALSE:\n                dirty = True\n                logger.debug(\"CHANGED RECORD FOUND!\")\n                logger.debug(\n                    f\"\\telement type: {type(element_val)} \"\n                    f\"column_type: {type(table_val)}\"\n                )\n                logger.debug(\n                    f\"\\t{mapped.element.Key}:{element_val} != \"\n                    f\"{mapped.column}:{table_val}\"\n                )\n                return dirty\n\n    # handle recursive checking next\n    if recursive:\n        for rel in self.frm.relationships:\n            if rel.parent_table == self.table and rel.on_update_cascade:\n                dirty = self.frm[rel.child_table].records_changed()\n                if dirty:\n                    break\n    return dirty\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.value_changed","title":"<code>value_changed(column_name, old_value, new_value, is_checkbox)</code>","text":"<p>Verifies if a new value is different from an old value and returns the cast value ready to be inserted into a database.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>The name of the column used in casting.</p> required <code>old_value</code> <p>The value to check against.</p> required <code>new_value</code> <p>The value being checked.</p> required <code>is_checkbox</code> <code>bool</code> <p>Whether or not additional logic should be applied to handle checkboxes.</p> required <p>Returns:</p> Type Description <code>Union[Any, Boolean]</code> <p>The cast value ready to be inserted into a database if the new value is</p> <code>Union[Any, Boolean]</code> <p>different from the old value. Returns FALSE otherwise.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def value_changed(\n    self, column_name: str, old_value, new_value, is_checkbox: bool\n) -&gt; Union[Any, Boolean]:\n\"\"\"Verifies if a new value is different from an old value and returns the cast\n    value ready to be inserted into a database.\n\n    Args:\n        column_name: The name of the column used in casting.\n        old_value: The value to check against.\n        new_value: The value being checked.\n        is_checkbox: Whether or not additional logic should be applied to handle\n            checkboxes.\n\n    Returns:\n        The cast value ready to be inserted into a database if the new value is\n        different from the old value. Returns `Boolean.FALSE` otherwise.\n    \"\"\"\n    table_val = old_value\n    # convert numpy to normal type\n    with contextlib.suppress(AttributeError):\n        table_val = table_val.tolist()\n\n    # get cast new value to correct type\n    for col in self.column_info:\n        if col.name == column_name:\n            new_value = col.cast(new_value)\n            element_val = new_value\n            table_val = col.cast(table_val)\n            break\n\n    if is_checkbox:\n        table_val = checkbox_to_bool(table_val)\n        element_val = checkbox_to_bool(element_val)\n\n    # Sanitize things a bit due to empty values being slightly different in\n    # the two cases.\n    if table_val is None:\n        table_val = \"\"\n\n    # Strip trailing whitespace from strings\n    if isinstance(table_val, str):\n        table_val = table_val.rstrip()\n    if isinstance(element_val, str):\n        element_val = element_val.rstrip()\n\n    # Make the comparison\n    # Temporary debug output\n    debug = False\n    if debug:\n        print(\n            f\"element: {element_val}({type(element_val)})\"\n            f\"db: {table_val}({type(table_val)})\"\n        )\n    if element_val != table_val:\n        return new_value if new_value is not None else \"\"\n    return Boolean.FALSE\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.prompt_save","title":"<code>prompt_save(update_elements=True)</code>","text":"<p>Prompts the user, asking if they want to save when changes are detected.</p> <p>This is called when the current record is about to change.</p> <p>Parameters:</p> Name Type Description Default <code>update_elements</code> <code>bool</code> <p>(optional) Passed to save_records() -&gt; save_record_recursive() to update_elements. Additionally used to discard changes if user reply's 'No' to prompt.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[Type[PromptSaveReturn], SAVE_FAIL]</code> <p>A prompt return value of one of the following: PROCEED,</p> <code>Union[Type[PromptSaveReturn], SAVE_FAIL]</code> <p>DISCARDED, or NONE.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def prompt_save(\n    self, update_elements: bool = True\n) -&gt; Union[Type[PromptSaveReturn], SAVE_FAIL]:\n\"\"\"Prompts the user, asking if they want to save when changes are detected.\n\n    This is called when the current record is about to change.\n\n    Args:\n        update_elements: (optional) Passed to `Form.save_records()` -&gt;\n            `DataSet.save_record_recursive()` to update_elements. Additionally used\n            to discard changes if user reply's 'No' to prompt.\n\n    Returns:\n        A prompt return value of one of the following: `PromptSaveReturn.PROCEED`,\n        `PromptSaveReturn.DISCARDED`, or `PromptSaveReturn.NONE`.\n    \"\"\"\n    # Return False if there is nothing to check or _prompt_save is False\n    if self.current.index is None or not self.row_count or not self._prompt_save:\n        return PromptSaveReturn.NONE\n\n    # See if any rows are virtual\n    vrows = len(self.virtual_pks)\n\n    # Check if any records have changed\n    changed = self.records_changed() or vrows\n    if changed:\n        if self._prompt_save == AUTOSAVE_MODE:\n            save_changes = \"yes\"\n        else:\n            save_changes = self.frm.popup.yes_no(\n                lang.dataset_prompt_save_title, lang.dataset_prompt_save\n            )\n        if save_changes == \"yes\":\n            # save this record's cascaded relationships, last to first\n            if (\n                self.frm.save_records(\n                    table=self.table, update_elements=update_elements\n                )\n                &amp; SAVE_FAIL\n            ):\n                logger.debug(\"Save failed during prompt-save. Resetting selectors\")\n                # set all selectors back to previous position\n                self.frm.update_selectors()\n                return SAVE_FAIL\n            return PromptSaveReturn.PROCEED\n        # if no\n        self.purge_virtual()\n        self.current.restore_backup()\n\n        # set_by_index already takes care of this, but just in-case this method is\n        # called another way.\n        if vrows and update_elements:\n            self.frm.update_elements(self.key)\n\n        return PromptSaveReturn.DISCARDED\n    # if no changes\n    return PromptSaveReturn.NONE\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.requery","title":"<code>requery(select_first=True, filtered=True, update_elements=True, requery_dependents=True)</code>","text":"<p>Requeries the table.</p> <p>The DataSet object maintains an internal representation of the actual database table. The requery method will query the actual database and sync the DataSet object to it.</p> <p>Parameters:</p> Name Type Description Default <code>select_first</code> <code>bool</code> <p>(optional) If True, the first record will be selected after the requery.</p> <code>True</code> <code>filtered</code> <code>bool</code> <p>(optional) If True, the relationships will be considered and an appropriate WHERE clause will be generated. If False all records in the table will be fetched.</p> <code>True</code> <code>update_elements</code> <code>bool</code> <p>(optional) Passed to first() to update_elements. Note that the select_first parameter must equal True to use this parameter.</p> <code>True</code> <code>requery_dependents</code> <code>bool</code> <p>(optional) passed to first() to requery_dependents. Note that the select_first parameter must = True to use this parameter.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def requery(\n    self,\n    select_first: bool = True,\n    filtered: bool = True,\n    update_elements: bool = True,\n    requery_dependents: bool = True,\n) -&gt; None:\n\"\"\"Requeries the table.\n\n    The `DataSet` object maintains an internal representation of\n    the actual database table. The requery method will query the actual database and\n    sync the `DataSet` object to it.\n\n    Args:\n        select_first: (optional) If True, the first record will be selected after\n            the requery.\n        filtered: (optional) If True, the relationships will be considered and an\n            appropriate WHERE clause will be generated. If False all records in the\n            table will be fetched.\n        update_elements: (optional) Passed to `DataSet.first()` to update_elements.\n            Note that the select_first parameter must equal True to use this\n            parameter.\n        requery_dependents: (optional) passed to `DataSet.first()` to\n            requery_dependents. Note that the select_first parameter must = True to\n            use this parameter.\n\n    Returns:\n        None\n    \"\"\"\n    join = \"\"\n    where = \"\"\n\n    if not self.filtered:\n        filtered = False\n\n    if filtered:\n        # Stop requery short if parent has no records or current row is virtual\n        parent_table = self.relationships.get_parent(self.table)\n        if parent_table and (\n            not len(self.frm[parent_table].rows.index)\n            or self.relationships.is_parent_virtual(self.table, self.frm)\n        ):\n            # purge rows\n            self.rows = Result.set(pd.DataFrame(columns=self.column_info.names))\n\n            if update_elements:\n                self.frm.update_elements(self.key)\n            if requery_dependents:\n                self.requery_dependents(update_elements=update_elements)\n            return\n\n        # else, get join/where clause like normal\n        join = self.driver.generate_join_clause(self)\n        where = self.driver.generate_where_clause(self)\n\n    query = self.query + \" \" + join + \" \" + where + \" \" + self.order_clause\n    # We want to store our sort settings before we wipe out the current DataFrame\n    try:\n        sort_settings = self.store_sort_settings()\n    except (AttributeError, KeyError):\n        sort_settings = [None, SORT_NONE]  # default for first query\n\n    rows = self.driver.execute(query)\n    self.rows = rows\n\n    if self.row_count and self.pk_column is not None:\n        if \"sort_order\" not in self.rows.attrs:\n            # Store the sort order as a dictionary in the attrs of the DataFrame\n            sort_order = self.rows[self.pk_column].to_list()\n            self.rows.attrs[\"sort_order\"] = {self.pk_column: sort_order}\n        # now we can restore the sort order\n        self.load_sort_settings(sort_settings)\n        self.sort(self.table)\n\n    # Perform transform one row at a time\n    if self.transform is not None:\n        self.rows = self.rows.apply(\n            lambda row: self.transform(self, row, TFORM_DECODE) or row, axis=1\n        )\n\n    # Strip trailing white space, as this is what sg[element].get() does, so we\n    # can have an equal comparison. Not the prettiest solution.  Will look into\n    # this more on the PySimpleGUI end and make a follow-up ticket.\n    # TODO: Is the [:,:] still needed now that we are working with DateFrames?\n    self.rows.loc[:, :] = self.rows.applymap(\n        lambda x: x.rstrip() if isinstance(x, str) else x\n    )\n\n    # fill in columns if empty\n    if self.rows.columns.empty:\n        self.rows = Result.set(pd.DataFrame(columns=self.column_info.names))\n\n    # reset search string\n    self.search_string = \"\"\n\n    if select_first:\n        self.first(\n            update_elements=update_elements,\n            requery_dependents=requery_dependents,\n            skip_prompt_save=True,  # already saved\n        )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.requery_dependents","title":"<code>requery_dependents(child=False, update_elements=True)</code>","text":"<p>Requery parent DataSet instances as defined by the relationships of the table.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>bool</code> <p>(optional) If True, will requery self. Default False; used to skip requery when called by parent.</p> <code>False</code> <code>update_elements</code> <code>bool</code> <p>(optional) passed to requery() -&gt; first() to update_elements.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def requery_dependents(\n    self, child: bool = False, update_elements: bool = True\n) -&gt; None:\n\"\"\"Requery parent `DataSet` instances as defined by the relationships of the\n    table.\n\n    Args:\n        child: (optional) If True, will requery self. Default False; used to skip\n            requery when called by parent.\n        update_elements: (optional) passed to `DataSet.requery()` -&gt;\n            `DataSet.first()` to update_elements.\n\n    Returns:\n        None\n    \"\"\"\n    if child:\n        # dependents=False: no recursive dependent requery\n        self.requery(update_elements=update_elements, requery_dependents=False)\n\n    for rel in self.relationships:\n        if rel.parent_table == self.table and rel.on_update_cascade:\n            logger.debug(\n                f\"Requerying dependent table {self.frm[rel.child_table].table}\"\n            )\n            self.frm[rel.child_table].requery_dependents(\n                child=True, update_elements=update_elements\n            )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.first","title":"<code>first(update_elements=True, requery_dependents=True, skip_prompt_save=False)</code>","text":"<p>Move to the first record of the table.</p> <p>Only one entry in the table is ever considered \"Selected\"  This is one of several functions that influences which record is currently selected. See first(), previous(), next(), last(), search(), set_by_pk(), set_by_index().</p> <p>Parameters:</p> Name Type Description Default <code>update_elements</code> <code>bool</code> <p>(optional) Update the GUI elements after switching records.</p> <code>True</code> <code>requery_dependents</code> <code>bool</code> <p>(optional) Requery dependents after switching records</p> <code>True</code> <code>skip_prompt_save</code> <code>bool</code> <p>(optional) True to skip prompting to save dirty records</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def first(\n    self,\n    update_elements: bool = True,\n    requery_dependents: bool = True,\n    skip_prompt_save: bool = False,\n) -&gt; None:\n\"\"\"Move to the first record of the table.\n\n    Only one entry in the table is ever considered \"Selected\"  This is one of\n    several functions that influences which record is currently selected. See\n    `DataSet.first()`, `DataSet.previous()`, `DataSet.next()`, `DataSet.last()`,\n    `DataSet.search()`, `DataSet.set_by_pk()`, `DataSet.set_by_index()`.\n\n    Args:\n        update_elements: (optional) Update the GUI elements after switching records.\n        requery_dependents: (optional) Requery dependents after switching records\n        skip_prompt_save: (optional) True to skip prompting to save dirty records\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(f\"Moving to the first record of table {self.table}\")\n    # prompt_save\n    if (\n        not skip_prompt_save\n        # don't update self/dependents if we are going to below anyway\n        and self.prompt_save(update_elements=False) == SAVE_FAIL\n    ):\n        return\n\n    self.current.index = 0\n    if update_elements:\n        self.frm.update_elements(self.key)\n    if requery_dependents:\n        self.requery_dependents(update_elements=update_elements)\n    # callback\n    if \"record_changed\" in self.callbacks:\n        self.callbacks[\"record_changed\"](self.frm, self.frm.window, self.key)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.last","title":"<code>last(update_elements=True, requery_dependents=True, skip_prompt_save=False)</code>","text":"<p>Move to the last record of the table.</p> <p>Only one entry in the table is ever considered \"Selected\". This is one of several functions that influences which record is currently selected. See first(), previous(), next(), last(), search(), set_by_pk(), set_by_index().</p> <p>Parameters:</p> Name Type Description Default <code>update_elements</code> <code>bool</code> <p>(optional) Update the GUI elements after switching records.</p> <code>True</code> <code>requery_dependents</code> <code>bool</code> <p>(optional) Requery dependents after switching records</p> <code>True</code> <code>skip_prompt_save</code> <code>bool</code> <p>(optional) True to skip prompting to save dirty records</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def last(\n    self,\n    update_elements: bool = True,\n    requery_dependents: bool = True,\n    skip_prompt_save: bool = False,\n) -&gt; None:\n\"\"\"Move to the last record of the table.\n\n    Only one entry in the table is ever considered \"Selected\". This is one of\n    several functions that influences which record is currently selected. See\n    `DataSet.first()`, `DataSet.previous()`, `DataSet.next()`, `DataSet.last()`,\n    `DataSet.search()`, `DataSet.set_by_pk()`, `DataSet.set_by_index()`.\n\n    Args:\n        update_elements: (optional) Update the GUI elements after switching records.\n        requery_dependents: (optional) Requery dependents after switching records\n        skip_prompt_save: (optional) True to skip prompting to save dirty records\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(f\"Moving to the last record of table {self.table}\")\n    # prompt_save\n    if (\n        not skip_prompt_save\n        # don't update self/dependents if we are going to below anyway\n        and self.prompt_save(update_elements=False) == SAVE_FAIL\n    ):\n        return\n\n    self.current.index = self.row_count - 1\n\n    if update_elements:\n        self.frm.update_elements(self.key)\n    if requery_dependents:\n        self.requery_dependents()\n    # callback\n    if \"record_changed\" in self.callbacks:\n        self.callbacks[\"record_changed\"](self.frm, self.frm.window, self.key)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.next","title":"<code>next(update_elements=True, requery_dependents=True, skip_prompt_save=False)</code>","text":"<p>Move to the next record of the table.</p> <p>Only one entry in the table is ever considered \"Selected\". This is one of several functions that influences which record is currently selected. See first(), previous(), next(), last(), search(), set_by_pk(), set_by_index().</p> <p>Parameters:</p> Name Type Description Default <code>update_elements</code> <code>bool</code> <p>(optional) Update the GUI elements after switching records.</p> <code>True</code> <code>requery_dependents</code> <code>bool</code> <p>(optional) Requery dependents after switching records</p> <code>True</code> <code>skip_prompt_save</code> <code>bool</code> <p>(optional) True to skip prompting to save dirty records</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def next(\n    self,\n    update_elements: bool = True,\n    requery_dependents: bool = True,\n    skip_prompt_save: bool = False,\n) -&gt; None:\n\"\"\"Move to the next record of the table.\n\n    Only one entry in the table is ever considered \"Selected\". This is one of\n    several functions that influences which record is currently selected. See\n    `DataSet.first()`, `DataSet.previous()`, `DataSet.next()`, `DataSet.last()`,\n    `DataSet.search()`, `DataSet.set_by_pk()`, `DataSet.set_by_index()`.\n\n    Args:\n        update_elements: (optional) Update the GUI elements after switching records.\n        requery_dependents: (optional) Requery dependents after switching records\n        skip_prompt_save: (optional) True to skip prompting to save dirty records\n\n    Returns:\n        None\n    \"\"\"\n    if self.current.index &lt; self.row_count - 1:\n        logger.debug(f\"Moving to the next record of table {self.table}\")\n        # prompt_save\n        if (\n            not skip_prompt_save\n            # don't update self/dependents if we are going to below anyway\n            and self.prompt_save(update_elements=False) == SAVE_FAIL\n        ):\n            return\n\n        self.current.index += 1\n        if update_elements:\n            self.frm.update_elements(self.key)\n        if requery_dependents:\n            self.requery_dependents()\n        # callback\n        if \"record_changed\" in self.callbacks:\n            self.callbacks[\"record_changed\"](self.frm, self.frm.window, self.key)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.previous","title":"<code>previous(update_elements=True, requery_dependents=True, skip_prompt_save=False)</code>","text":"<p>Move to the previous record of the table.</p> <p>Only one entry in the table is ever considered \"Selected\". This is one of several functions that influences which record is currently selected. See first(), previous(), next(), last(), search(), set_by_pk(), set_by_index().</p> <p>Parameters:</p> Name Type Description Default <code>update_elements</code> <code>bool</code> <p>(optional) Update the GUI elements after switching records.</p> <code>True</code> <code>requery_dependents</code> <code>bool</code> <p>(optional) Requery dependents after switching records</p> <code>True</code> <code>skip_prompt_save</code> <code>bool</code> <p>(optional) True to skip prompting to save dirty records</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def previous(\n    self,\n    update_elements: bool = True,\n    requery_dependents: bool = True,\n    skip_prompt_save: bool = False,\n) -&gt; None:\n\"\"\"Move to the previous record of the table.\n\n    Only one entry in the table is ever considered \"Selected\". This is one of\n    several functions that influences which record is currently selected. See\n    `DataSet.first()`, `DataSet.previous()`, `DataSet.next()`, `DataSet.last()`,\n    `DataSet.search()`, `DataSet.set_by_pk()`, `DataSet.set_by_index()`.\n\n    Args:\n        update_elements: (optional) Update the GUI elements after switching records.\n        requery_dependents: (optional) Requery dependents after switching records\n        skip_prompt_save: (optional) True to skip prompting to save dirty records\n\n    Returns:\n        None\n    \"\"\"\n    if self.current.index &gt; 0:\n        logger.debug(f\"Moving to the previous record of table {self.table}\")\n        # prompt_save\n        if (\n            not skip_prompt_save\n            # don't update self/dependents if we are going to below anyway\n            and self.prompt_save(update_elements=False) == SAVE_FAIL\n        ):\n            return\n\n        self.current.index -= 1\n        if update_elements:\n            self.frm.update_elements(self.key)\n        if requery_dependents:\n            self.requery_dependents()\n        # callback\n        if \"record_changed\" in self.callbacks:\n            self.callbacks[\"record_changed\"](self.frm, self.frm.window, self.key)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.search","title":"<code>search(search_string, update_elements=True, requery_dependents=True, skip_prompt_save=False, display_message=None)</code>","text":"<p>Move to the next record in the DataSet that contains search_string.</p> <p>Successive calls will search from the current position, and wrap around back to the beginning. The search order from set_search_order() will be used. If the search order is not set by the user, it will default to the description column (see set_description_column()). Only one entry in the table is ever considered \"Selected\"  This is one of several functions that influences which record is currently selected. See first(), previous(), next(), last(), search(), set_by_pk(), set_by_index().</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>str</code> <p>The search string to look for</p> required <code>update_elements</code> <code>bool</code> <p>(optional) Update the GUI elements after switching records.</p> <code>True</code> <code>requery_dependents</code> <code>bool</code> <p>(optional) Requery dependents after switching records</p> <code>True</code> <code>skip_prompt_save</code> <code>bool</code> <p>(optional) True to skip prompting to save dirty records</p> <code>False</code> <code>display_message</code> <code>bool</code> <p>Displays a message \"Search Failed: ...\", otherwise is silent on fail.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[SEARCH_FAILED, SEARCH_RETURNED, SEARCH_ABORTED]</code> <p>One of the following search values: SEARCH_FAILED, SEARCH_RETURNED,</p> <code>Union[SEARCH_FAILED, SEARCH_RETURNED, SEARCH_ABORTED]</code> <p>SEARCH_ABORTED.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def search(\n    self,\n    search_string: str,\n    update_elements: bool = True,\n    requery_dependents: bool = True,\n    skip_prompt_save: bool = False,\n    display_message: bool = None,\n) -&gt; Union[SEARCH_FAILED, SEARCH_RETURNED, SEARCH_ABORTED]:\n\"\"\"Move to the next record in the `DataSet` that contains `search_string`.\n\n    Successive calls will search from the current position, and wrap around back to\n    the beginning. The search order from `DataSet.set_search_order()` will be used.\n    If the search order is not set by the user, it will default to the description\n    column (see `DataSet.set_description_column()`). Only one entry in the table is\n    ever considered \"Selected\"  This is one of several functions that influences\n    which record is currently selected. See `DataSet.first()`, `DataSet.previous()`,\n    `DataSet.next()`, `DataSet.last()`, `DataSet.search()`, `DataSet.set_by_pk()`,\n    `DataSet.set_by_index()`.\n\n    Args:\n        search_string: The search string to look for\n        update_elements: (optional) Update the GUI elements after switching records.\n        requery_dependents: (optional) Requery dependents after switching records\n        skip_prompt_save: (optional) True to skip prompting to save dirty records\n        display_message: Displays a message \"Search Failed: ...\", otherwise is\n            silent on fail.\n\n    Returns:\n        One of the following search values: `SEARCH_FAILED`, `SEARCH_RETURNED`,\n        `SEARCH_ABORTED`.\n    \"\"\"\n    # See if the string is an element name\n    # TODO this is a bit of an ugly hack, but it works\n    if search_string in self.frm.window.key_dict:\n        search_string = self.frm.window[search_string].get()\n    if not search_string or not self.row_count:\n        return SEARCH_ABORTED\n\n    logger.debug(\n        f'Searching for a record of table {self.table} \"'\n        f'with search string \"{search_string}\"'\n    )\n    logger.debug(f\"DEBUG: {self.search_order} {self.rows.columns[0]}\")\n\n    # prompt_save\n    if (\n        not skip_prompt_save\n        # don't update self/dependents if we are going to below anyway\n        and self.prompt_save(update_elements=False) == SAVE_FAIL\n    ):\n        return None\n\n    # callback\n    if \"before_search\" in self.callbacks and not self.callbacks[\"before_search\"](\n        self.frm, self.frm.window, self.key\n    ):\n        return SEARCH_ABORTED\n\n    # Reset _prev_search if search_string is different\n    if search_string != self._prev_search.search_string:\n        self._prev_search = _PrevSearch(search_string)\n\n    # Reorder search_columns to start with the column in _prev_search\n    search_columns = self.search_order.copy()\n    if self._prev_search.column in search_columns:\n        idx = search_columns.index(self._prev_search.column)\n        search_columns = search_columns[idx:] + search_columns[:idx]\n\n    # reorder rows to be idx + 1, and wrap around back to the beginning\n    rows = self.rows.copy().reset_index()\n    idx = self.current.index + 1 % len(rows)\n    rows = pd.concat([rows.loc[idx:], rows.loc[:idx]])\n\n    # fill in descriptions for cols in search_order\n    rows = self.map_fk_descriptions(rows, self.search_order)\n\n    pk = None\n    for column in search_columns:\n        # update _prev_search column\n        self._prev_search.column = column\n\n        # search through processed rows, looking for search_string\n        result = rows[\n            rows[column].astype(str).str.contains(str(search_string), case=False)\n        ]\n        if not result.empty:\n            # save index for later, if callback returns False\n            old_index = self.current.index\n\n            # grab the first result\n            pk = result.iloc[0][self.pk_column]\n\n            # search next column if the same pk is found again\n            if pk in self._prev_search.pks:\n                continue\n\n            # if pk is same as one we are on, we can just updated_elements\n            if pk == self[self.pk_column]:\n                if update_elements:\n                    self.frm.update_elements(self.key)\n                if requery_dependents:\n                    self.requery_dependents()\n                return SEARCH_RETURNED\n\n            # otherwise, this is a new pk\n            break\n\n    if pk:\n        # Update _prev_search with the pk\n        self._prev_search.pks.append(pk)\n\n        # jump to the pk\n        self.set_by_pk(\n            pk=pk,\n            update_elements=update_elements,\n            requery_dependents=requery_dependents,\n            skip_prompt_save=True,\n        )\n\n        # callback\n        if \"after_search\" in self.callbacks and not self.callbacks[\"after_search\"](\n            self.frm, self.frm.window, self.key\n        ):\n            self.current.index = old_index\n            self.frm.update_elements(self.key)\n            self.requery_dependents()\n            return SEARCH_ABORTED\n\n        # record changed callback\n        if \"record_changed\" in self.callbacks:\n            self.callbacks[\"record_changed\"](self.frm, self.frm.window, self.key)\n        return SEARCH_RETURNED\n\n    # didn't find anything\n    self.frm.popup.ok(\n        lang.dataset_search_failed_title,\n        lang.dataset_search_failed.format_map(\n            LangFormat(search_string=search_string)\n        ),\n    )\n    return SEARCH_FAILED\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_by_index","title":"<code>set_by_index(index, update_elements=True, requery_dependents=True, skip_prompt_save=False, omit_elements=None)</code>","text":"<p>Move to the record of the table located at the specified index in DataSet.</p> <p>Only one entry in the table is ever considered \"Selected\". This is one of several functions that influences which record is currently selected. See first(), previous(), next(), last(), search(), set_by_pk(), set_by_index().</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the record to move to.</p> required <code>update_elements</code> <code>bool</code> <p>(optional) Update the GUI elements after switching records.</p> <code>True</code> <code>requery_dependents</code> <code>bool</code> <p>(optional) Requery dependents after switching records</p> <code>True</code> <code>skip_prompt_save</code> <code>bool</code> <p>(optional) True to skip prompting to save dirty records</p> <code>False</code> <code>omit_elements</code> <code>List[str]</code> <p>(optional) A list of elements to omit from updating</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_by_index(\n    self,\n    index: int,\n    update_elements: bool = True,\n    requery_dependents: bool = True,\n    skip_prompt_save: bool = False,\n    omit_elements: List[str] = None,\n) -&gt; None:\n\"\"\"Move to the record of the table located at the specified index in DataSet.\n\n    Only one entry in the table is ever considered \"Selected\". This is one of\n    several functions that influences which record is currently selected. See\n    `DataSet.first()`, `DataSet.previous()`, `DataSet.next()`, `DataSet.last()`,\n    `DataSet.search()`, `DataSet.set_by_pk()`, `DataSet.set_by_index()`.\n\n    Args:\n        index: The index of the record to move to.\n        update_elements: (optional) Update the GUI elements after switching records.\n        requery_dependents: (optional) Requery dependents after switching records\n        skip_prompt_save: (optional) True to skip prompting to save dirty records\n        omit_elements: (optional) A list of elements to omit from updating\n\n    Returns:\n        None\n    \"\"\"\n    # if already there\n    if self.current.index == index:\n        return\n\n    logger.debug(f\"Moving to the record at index {index} on {self.table}\")\n    if omit_elements is None:\n        omit_elements = []\n\n    if skip_prompt_save is False:\n        # see if sg.Table has potential changes\n        if len(omit_elements) and self.records_changed(recursive=False):\n            # most likely will need to update, either to\n            # discard virtual or update after save\n            omit_elements = []\n        # don't update self/dependents if we are going to below anyway\n        if self.prompt_save(update_elements=False) == SAVE_FAIL:\n            return\n\n    self.current.index = index\n    if update_elements:\n        self.frm.update_elements(self.key, omit_elements=omit_elements)\n    if requery_dependents:\n        self.requery_dependents()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.set_by_pk","title":"<code>set_by_pk(pk, update_elements=True, requery_dependents=True, skip_prompt_save=False, omit_elements=None)</code>","text":"<p>Move to the record with this primary key.</p> <p>This is useful when modifying a record (such as renaming).  The primary key can be stored, the record re-named, and then the current record selection updated regardless of the new sort order.</p> <p>Only one entry in the table is ever considered \"Selected\". This is one of several functions that influences which record is currently selected. See first(), previous(), next(), last(), search(), set_by_pk(), set_by_index().</p> <p>Parameters:</p> Name Type Description Default <code>pk</code> <code>int</code> <p>The record to move to containing the primary key</p> required <code>update_elements</code> <code>bool</code> <p>(optional) Update the GUI elements after switching records.</p> <code>True</code> <code>requery_dependents</code> <code>bool</code> <p>(optional) Requery dependents after switching records</p> <code>True</code> <code>skip_prompt_save</code> <code>bool</code> <p>(optional) True to skip prompting to save dirty records</p> <code>False</code> <code>omit_elements</code> <code>list[str]</code> <p>(optional) A list of elements to omit from updating</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_by_pk(\n    self,\n    pk: int,\n    update_elements: bool = True,\n    requery_dependents: bool = True,\n    skip_prompt_save: bool = False,\n    omit_elements: list[str] = None,\n) -&gt; None:\n\"\"\"Move to the record with this primary key.\n\n    This is useful when modifying a record (such as renaming).  The primary key can\n    be stored, the record re-named, and then the current record selection updated\n    regardless of the new sort order.\n\n    Only one entry in the table is ever considered \"Selected\". This is one of\n    several functions that influences which record is currently selected. See\n    `DataSet.first()`, `DataSet.previous()`, `DataSet.next()`, `DataSet.last()`,\n    `DataSet.search()`, `DataSet.set_by_pk()`, `DataSet.set_by_index()`.\n\n    Args:\n        pk: The record to move to containing the primary key\n        update_elements: (optional) Update the GUI elements after switching records.\n        requery_dependents: (optional) Requery dependents after switching records\n        skip_prompt_save: (optional) True to skip prompting to save dirty records\n        omit_elements: (optional) A list of elements to omit from updating\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(f\"Setting table {self.table} record by primary key {pk}\")\n\n    # Get the numerical index of where the primary key is located.\n    # If the pk value can't be found, set to the last index\n    try:\n        idx = [\n            i for i, value in enumerate(self.rows[self.pk_column]) if value == pk\n        ]\n    except (IndexError, KeyError):\n        idx = None\n        logger.debug(\"Error finding pk!\")\n\n    idx = idx[0] if idx else self.row_count\n\n    self.set_by_index(\n        index=idx,\n        update_elements=update_elements,\n        requery_dependents=requery_dependents,\n        skip_prompt_save=skip_prompt_save,\n        omit_elements=omit_elements,\n    )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.get_keyed_value","title":"<code>get_keyed_value(value_column, key_column, key_value)</code>","text":"<p>Return value_column where<code>key_column</code>=key_value.</p> <p>Useful for datastores with key/value pairs.</p> <p>Parameters:</p> Name Type Description Default <code>value_column</code> <code>str</code> <p>The column to fetch the value from</p> required <code>key_column</code> <code>str</code> <p>The column in which to search for the value</p> required <code>key_value</code> <code>Union[str, int]</code> <p>The value to search for</p> required <p>Returns:</p> Type Description <code>Union[str, int, None]</code> <p>Returns the value found in value_column</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_keyed_value(\n    self, value_column: str, key_column: str, key_value: Union[str, int]\n) -&gt; Union[str, int, None]:\n\"\"\"Return `value_column` where` key_column`=`key_value`.\n\n    Useful for datastores with key/value pairs.\n\n    Args:\n        value_column: The column to fetch the value from\n        key_column: The column in which to search for the value\n        key_value: The value to search for\n\n    Returns:\n        Returns the value found in `value_column`\n    \"\"\"\n    for _, row in self.rows.iterrows():\n        if row[key_column] == key_value:\n            return row[value_column]\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.add_selector","title":"<code>add_selector(element, data_key, where_column=None, where_value=None)</code>","text":"<p>Use an element such as a listbox, combobox or a table as a selector item for this table.</p> <p>Note: This is not typically used by the end user, as this is called from the selector() convenience function.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>the PySimpleGUI element used as a selector element</p> required <code>data_key</code> <code>str</code> <p>the DataSet item this selector will operate on</p> required <code>where_column</code> <code>str</code> <p>(optional)</p> <code>None</code> <code>where_value</code> <code>str</code> <p>(optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def add_selector(\n    self,\n    element: sg.Element,\n    data_key: str,\n    where_column: str = None,\n    where_value: str = None,\n) -&gt; None:\n\"\"\"Use an element such as a listbox, combobox or a table as a selector item for\n    this table.\n\n    Note: This is not typically used by the end user, as this is called from the\n    `selector()` convenience function.\n\n    Args:\n        element: the PySimpleGUI element used as a selector element\n        data_key: the `DataSet` item this selector will operate on\n        where_column: (optional)\n        where_value: (optional)\n\n    Returns:\n        None\n    \"\"\"\n    if not isinstance(element, (sg.Listbox, sg.Slider, sg.Combo, sg.Table)):\n        raise RuntimeError(\n            f\"add_selector() error: {element} is not a supported element.\"\n        )\n\n    logger.debug(f\"Adding {element.Key} as a selector for the {self.table} table.\")\n    d = {\n        \"element\": element,\n        \"data_key\": data_key,\n        \"where_column\": where_column,\n        \"where_value\": where_value,\n    }\n    self.selector.append(d)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.insert_record","title":"<code>insert_record(values=None, skip_prompt_save=False)</code>","text":"<p>Insert a new record virtually in the DataSet object.</p> <p>If values are passed, it will initially set those columns to the values (I.e. {'name': 'New Record', 'note': ''}), otherwise they will be fetched from the database if present.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Dict[str, Union[str, int]]</code> <p>column:value pairs</p> <code>None</code> <code>skip_prompt_save</code> <code>bool</code> <p>Skip prompting the user to save dirty records before the insert.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def insert_record(\n    self, values: Dict[str, Union[str, int]] = None, skip_prompt_save: bool = False\n) -&gt; None:\n\"\"\"Insert a new record virtually in the `DataSet` object.\n\n    If values are passed, it will initially set those columns to the values (I.e.\n    {'name': 'New Record', 'note': ''}), otherwise they will be fetched from the\n    database if present.\n\n    Args:\n        values: column:value pairs\n        skip_prompt_save: Skip prompting the user to save dirty records before the\n            insert.\n\n    Returns:\n        None\n    \"\"\"\n    # prompt_save\n    if (\n        not skip_prompt_save\n        # don't update self/dependents if we are going to below anyway\n        and self.prompt_save(update_elements=False) == SAVE_FAIL\n    ):\n        return\n\n    # Don't insert if parent has no records or is virtual\n    parent_table = self.relationships.get_parent(self.table)\n    if (\n        parent_table\n        and not len(self.frm[parent_table].rows)\n        or self.relationships.is_parent_virtual(self.table, self.frm)\n    ):\n        logger.debug(f\"{parent_table=} is empty or current row is virtual\")\n        return\n\n    # Get a new dict for a new row with default values already filled in\n    new_values = self.column_info.default_row_dict(self)\n\n    # If the values parameter was passed in, overwrite any values in the dict\n    if values is not None:\n        for k, v in values.items():\n            if k in new_values:\n                new_values[k] = v\n\n    # Make sure we take into account the foreign key relationships...\n    for r in self.relationships:\n        if self.table == r.child_table and r.on_update_cascade:\n            new_values[r.fk_column] = self.frm[r.parent_table].current.pk\n\n    # Update the pk to match the expected pk the driver would generate on insert.\n    new_values[self.pk_column] = self.driver.next_pk(self.table, self.pk_column)\n\n    # Insert the new values using DataSet.insert_row(),\n    # marking the new row as virtual\n    self.insert_row(new_values)\n\n    # and move to the new record\n    # do this in insert_record, because possibly current.index is already 0\n    # and set_by_index will return early before update/requery if so.\n    self.current.index = self.row_count\n    self.frm.update_elements(self.key)\n    self.requery_dependents()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.save_record","title":"<code>save_record(display_message=None, update_elements=True, validate_fields=None)</code>","text":"<p>Save the currently selected record.</p> <p>Saves any changes made via the GUI back to the database.  The before_save and after_save callbacks will call your own functions for error checking if needed!.</p> <p>Parameters:</p> Name Type Description Default <code>display_message</code> <code>bool</code> <p>Displays a message \"Updates saved successfully\", otherwise is silent on success.</p> <code>None</code> <code>update_elements</code> <code>bool</code> <p>Update the GUI elements after saving</p> <code>True</code> <code>validate_fields</code> <code>bool</code> <p>Validate fields before saving to database.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>SAVE_NONE, SAVE_FAIL or SAVE_SUCCESS masked with SHOW_MESSAGE</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def save_record(\n    self,\n    display_message: bool = None,\n    update_elements: bool = True,\n    validate_fields: bool = None,\n) -&gt; int:\n\"\"\"Save the currently selected record.\n\n    Saves any changes made via the GUI back to the database.  The\n    before_save and after_save `DataSet.callbacks` will call your\n    own functions for error checking if needed!.\n\n    Args:\n        display_message: Displays a message \"Updates saved successfully\", otherwise\n            is silent on success.\n        update_elements: Update the GUI elements after saving\n        validate_fields: Validate fields before saving to database.\n\n    Returns:\n        SAVE_NONE, SAVE_FAIL or SAVE_SUCCESS masked with SHOW_MESSAGE\n    \"\"\"\n    logger.debug(f\"Saving records for table {self.table}...\")\n    if display_message is None:\n        display_message = not self.save_quiet\n\n    if validate_fields is None:\n        validate_fields = self.validate_mode\n\n    # Ensure that there is actually something to save\n    if not self.row_count:\n        self.frm.popup.info(\n            lang.dataset_save_empty, display_message=display_message\n        )\n        return SAVE_NONE + SHOW_MESSAGE\n\n    # callback\n    if \"before_save\" in self.callbacks and not self.callbacks[\"before_save\"](\n        self.frm, self.frm.window, self.key\n    ):\n        logger.debug(\"We are not saving!\")\n        if update_elements:\n            self.frm.update_elements(self.key)\n        if display_message:\n            self.frm.popup.ok(\n                lang.dataset_save_callback_false_title,\n                lang.dataset_save_callback_false,\n            )\n        return SAVE_FAIL + SHOW_MESSAGE\n\n    # Check right away to see if any records have changed, no need to proceed any\n    # further than we have to.\n    if not self.records_changed(recursive=False) and self.frm.force_save is False:\n        self.frm.popup.info(lang.dataset_save_none, display_message=display_message)\n        return SAVE_NONE + SHOW_MESSAGE\n\n    # Work with a copy of the original row and transform it if needed\n    # While saving, we are working with just the current row of data,\n    # unless it's 'keyed' via ?/=\n    current_row = self.current.get().copy()\n\n    # Track the keyed queries we have to run.\n    # Set to None, so we can tell later if there were keyed elements\n    # {'column':column, 'changed_row': row, 'where_clause': where_clause}\n    keyed_queries: Optional[List] = None\n\n    # Propagate GUI data back to the stored current_row\n    for mapped in [m for m in self.frm.element_map if m.dataset == self]:\n        # skip if sg.Text\n        if isinstance(mapped.element, sg.Text):\n            continue\n\n        # convert the data into the correct type using the domain in ColumnInfo\n        if isinstance(mapped.element, sg.Combo):\n            # try to get ElementRow pk\n            try:\n                element_val = self.column_info[mapped.column].cast(\n                    mapped.element.get().get_pk_ignore_placeholder()\n                )\n            # of if plain-ole combobox:\n            except AttributeError:\n                element_val = self.column_info[mapped.column].cast(\n                    mapped.element.get()\n                )\n        else:\n            element_val = self.column_info[mapped.column].cast(mapped.element.get())\n\n        # Looked for keyed elements first\n        if mapped.where_column is not None:\n            if keyed_queries is None:\n                # Make the list here so != None if keyed elements\n                keyed_queries = []\n            for index, row in self.rows.iterrows():\n                if (\n                    row[mapped.where_column] == mapped.where_value\n                    and row[mapped.column] != element_val\n                ):\n                    # This record has changed.  We will save it\n\n                    # propagate the value back to self.rows\n                    self.rows.loc[\n                        self.rows.index[index], mapped.column\n                    ] = element_val\n\n                    changed = {mapped.column: element_val}\n                    where_col = self.driver.quote_column(mapped.where_column)\n                    where_val = self.driver.quote_value(mapped.where_value)\n                    where_clause = f\"WHERE {where_col} = {where_val}\"\n                    keyed_queries.append(\n                        {\n                            \"column\": mapped.column,\n                            \"changed_row\": changed,\n                            \"where_clause\": where_clause,\n                        }\n                    )\n        else:\n            # field elements override _CellEdit's\n            current_row[mapped.column] = element_val\n\n    # create diff of columns if not virtual\n    new_dict = current_row.fillna(\"\").to_dict()\n\n    if self.pk_is_virtual():\n        changed_row_dict = new_dict\n    else:\n        old_dict = self.current.get_original().fillna(\"\").to_dict()\n        changed_row_dict = {\n            key: new_dict[key]\n            for key in new_dict\n            if old_dict.get(key) != new_dict[key]\n        }\n\n    # Remove the pk column, any virtual or generated columns\n    changed_row_dict = {\n        col: value\n        for col, value in changed_row_dict.items()\n        if col != self.pk_column\n        and col not in self.column_info.get_virtual_names()\n        and not self.column_info[col].generated\n    }\n\n    if not bool(changed_row_dict) and not keyed_queries:\n        # if user is not using liveupdate, they can change something using celledit\n        # but then change it back in field element (which overrides the celledit)\n        # this refreshes the selector/comboboxes so that gui is up-to-date.\n        if self.current.has_backup:\n            self.current.restore_backup()\n            self.frm.update_selectors(self.key)\n            self.frm.update_fields(self.key)\n        return SAVE_NONE + SHOW_MESSAGE\n\n    # apply any transformations\n    if self.transform is not None:\n        self.transform(self, changed_row_dict, TFORM_ENCODE)\n\n    # check to make sure we have valid inputs\n    if validate_fields:\n        invalid_response = {}\n        for col, value in changed_row_dict.items():\n            response = self.column_info[col].validate(value)\n            if response.exception:\n                invalid_response[col] = response\n        if invalid_response:\n            msg = f\"{lang.dataset_save_validate_error_header}\"\n            for col, response in invalid_response.items():\n                field = lang.dataset_save_validate_error_field.format_map(\n                    LangFormat(field=col)\n                )\n                exception = lang[response.exception].format_map(\n                    LangFormat(value=response.value, rule=response.rule)\n                )\n                msg += f\"{field}{exception}\\n\"\n            self.frm.popup.ok(lang.dataset_save_validate_error_title, msg)\n            return SAVE_FAIL\n\n    # check to see if cascading-fk has changed before we update database\n    cascade_fk_changed = False\n    cascade_fk_column = self.relationships.get_update_cascade_fk_column(self.table)\n    if cascade_fk_column:\n        # check if fk\n        for mapped in self.frm.element_map:\n            if mapped.dataset == self and mapped.column == cascade_fk_column:\n                cascade_fk_changed = self.records_changed(\n                    column=cascade_fk_column, recursive=False\n                )\n\n    # Update the database from the stored rows\n    # ----------------------------------------\n\n    # reset search string\n    self.search_string = \"\"\n\n    # Save or Insert the record as needed\n    if keyed_queries is not None:\n        # Now execute all the saved queries from earlier\n        for q in keyed_queries:\n            # Update the database from the stored rows\n            if self.transform is not None:\n                self.transform(self, q[\"changed_row\"], TFORM_ENCODE)\n            result = self.driver.save_record(\n                self, q[\"changed_row\"], q[\"where_clause\"]\n            )\n            if result.attrs[\"exception\"] is not None:\n                self.frm.popup.ok(\n                    lang.dataset_save_keyed_fail_title,\n                    lang.dataset_save_keyed_fail.format_map(\n                        LangFormat(exception=result.exception)\n                    ),\n                )\n                self.driver.rollback()\n                return SAVE_FAIL  # Do not show the message in this case\n\n    else:\n        if self.pk_is_virtual():\n            result = self.driver.insert_record(\n                self.table, self.current.pk, self.pk_column, changed_row_dict\n            )\n        else:\n            result = self.driver.save_record(self, changed_row_dict)\n\n        if result.attrs[\"exception\"] is not None:\n            self.frm.popup.ok(\n                lang.dataset_save_fail_title,\n                lang.dataset_save_fail.format_map(\n                    LangFormat(exception=result.attrs[\"exception\"])\n                ),\n            )\n            self.driver.rollback()\n            return SAVE_FAIL  # Do not show the message in this case\n\n        # Store the pk, so we can move to it later - use the value returned in the\n        # attrs if possible. The expected pk may have changed from autoincrement\n        # and/or concurrent access.\n        pk = (\n            result.attrs[\"lastrowid\"]\n            if result.attrs[\"lastrowid\"] is not None\n            else self.current.pk\n        )\n        self.current.set_value(self.pk_column, pk, write_event=False)\n\n        # then update the current row data\n        self.rows.iloc[self.current.index] = current_row\n\n        # If child changes parent, move index back and requery/requery_dependents\n        if (\n            cascade_fk_changed and not self.pk_is_virtual()\n        ):  # Virtual rows already requery, and have no dependents.\n            self.frm[self.table].requery(select_first=False)  # keep spot in table\n            self.frm[self.table].requery_dependents()\n\n        # Lets refresh our data\n        if self.pk_is_virtual():\n            # Requery so that the new row honors the order clause\n            self.requery(select_first=False, update_elements=False)\n            if update_elements:\n                # Then move to the record\n                self.set_by_pk(\n                    pk,\n                    skip_prompt_save=True,\n                    requery_dependents=False,\n                )\n                # only need to reset the Insert button\n                self.frm.update_actions()\n\n    # callback\n    if \"after_save\" in self.callbacks and not self.callbacks[\"after_save\"](\n        self.frm, self.frm.window, self.key\n    ):\n        self.driver.rollback()\n        return SAVE_FAIL + SHOW_MESSAGE\n\n    # If we made it here, we can commit the changes, since the save and insert above\n    # do not commit or rollback\n    self.driver.commit()\n\n    # Sort so the saved row honors the current order.\n    if \"sort_column\" in self.rows.attrs and self.rows.attrs[\"sort_column\"]:\n        self.sort(self.table)\n\n    # Discard backup\n    self.purge_row_backup()\n\n    if update_elements:\n        self.frm.update_elements(self.key)\n\n    # if the description_column has changed, make sure to update other elements\n    # that may depend on it, that otherwise wouldn't be requeried because they are\n    # not setup as on_update_cascade.\n    if self.description_column in changed_row_dict:\n        dependent_columns = self.relationships.get_dependent_columns(\n            self.frm, self.table\n        )\n        for key, col in dependent_columns.items():\n            self.frm.update_fields(key, columns=[col], combo_values_only=True)\n            if self.frm[key].column_likely_in_selector(col):\n                self.frm.update_selectors(key)\n\n    logger.debug(\"Record Saved!\")\n    self.frm.popup.info(lang.dataset_save_success, display_message=display_message)\n\n    return SAVE_SUCCESS + SHOW_MESSAGE\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.save_record_recursive","title":"<code>save_record_recursive(results, display_message=False, check_prompt_save=False, update_elements=True)</code>","text":"<p>Recursively save changes, taking into account the relationships of the tables.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>SaveResultsDict</code> <p>Used in save_records to collect save_record returns. Pass an empty dict to get list of {table : result}</p> required <code>display_message</code> <code>bool</code> <p>Passed to save_record. Displays a message that updates were saved successfully, otherwise is silent on success.</p> <code>False</code> <code>check_prompt_save</code> <code>bool</code> <p>Used when called from prompt_save. Updates elements without saving if individual _prompt_save() is False.</p> <code>False</code> <code>update_elements</code> <code>bool</code> <p>Update GUI elements, additionally passed to dependents.</p> <code>True</code> <p>Returns:</p> Type Description <code>SaveResultsDict</code> <p>dict of {table : results}</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def save_record_recursive(\n    self,\n    results: SaveResultsDict,\n    display_message: bool = False,\n    check_prompt_save: bool = False,\n    update_elements: bool = True,\n) -&gt; SaveResultsDict:\n\"\"\"Recursively save changes, taking into account the relationships of the\n    tables.\n\n    Args:\n        results: Used in `Form.save_records` to collect `DataSet.save_record`\n            returns. Pass an empty dict to get list of {table : result}\n        display_message: Passed to `DataSet.save_record`. Displays a message that\n            updates were saved successfully, otherwise is silent on success.\n        check_prompt_save: Used when called from `Form.prompt_save`. Updates\n            elements without saving if individual `DataSet._prompt_save()` is False.\n        update_elements: Update GUI elements, additionally passed to dependents.\n\n    Returns:\n        dict of {table : results}\n    \"\"\"\n    for rel in self.relationships:\n        if rel.parent_table == self.table and rel.on_update_cascade:\n            self.frm[rel.child_table].save_record_recursive(\n                results=results,\n                display_message=display_message,\n                check_prompt_save=check_prompt_save,\n                update_elements=update_elements,\n            )\n    # if dataset-level doesn't allow prompt_save\n    if check_prompt_save and self._prompt_save is False:\n        if update_elements:\n            self.frm.update_elements(self.key)\n        results[self.table] = PromptSaveReturn.NONE\n        return results\n    # otherwise, proceed\n    result = self.save_record(\n        display_message=display_message, update_elements=update_elements\n    )\n    results[self.table] = result\n    return results\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.delete_record","title":"<code>delete_record(cascade=True)</code>","text":"<p>Delete the currently selected record.</p> <p>The before_delete and after_delete callbacks are run during this process to give some control over the process.</p> <p>Parameters:</p> Name Type Description Default <code>cascade</code> <code>bool</code> <p>Delete child records (as defined by Relationships that were set up) before deleting this record.</p> <code>True</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def delete_record(\n    self, cascade: bool = True\n):  # TODO: check return type, we return True below\n\"\"\"Delete the currently selected record.\n\n    The before_delete and after_delete callbacks are run during this process\n    to give some control over the process.\n\n    Args:\n        cascade: Delete child records (as defined by `Relationship`s that were set\n            up) before deleting this record.\n\n    Returns:\n        None\n    \"\"\"\n    # Ensure that there is actually something to delete\n    if not self.row_count:\n        return None\n\n    # callback\n    if \"before_delete\" in self.callbacks and not self.callbacks[\"before_delete\"](\n        self.frm, self.frm.window, self.key\n    ):\n        return None\n\n    children = []\n    if cascade:\n        children = self.relationships.get_delete_cascade_tables(self.table)\n\n    msg_children = \", \".join(children)\n    if len(children):\n        msg = lang.delete_cascade.format_map(LangFormat(children=msg_children))\n    else:\n        msg = lang.delete_single\n    answer = self.frm.popup.yes_no(lang.delete_title, msg)\n    if answer == \"no\":\n        return True\n\n    if self.pk_is_virtual():\n        self.purge_virtual()\n        self.frm.update_elements(self.key)\n        # only need to reset the Insert button\n        self.frm.update_actions()\n        return None\n\n    # Delete child records first!\n    result = self.driver.delete_record(self, True)\n\n    if (\n        not isinstance(result, pd.DataFrame)\n        and result == DELETE_RECURSION_LIMIT_ERROR\n    ):\n        self.frm.popup.ok(\n            lang.delete_failed_title,\n            lang.delete_failed.format_map(\n                LangFormat(exception=lang.delete_recursion_limit_error)\n            ),\n        )\n    elif result.attrs[\"exception\"] is not None:\n        self.frm.popup.ok(\n            lang.delete_failed_title,\n            lang.delete_failed.format_map(LangFormat(exception=result.exception)),\n        )\n\n    # callback\n    if \"after_delete\" in self.callbacks:\n        if not self.callbacks[\"after_delete\"](self.frm, self.frm.window, self.key):\n            self.driver.rollback()\n        else:\n            self.driver.commit()\n    else:\n        self.driver.commit()\n\n    self.requery(select_first=False)\n    self.frm.update_elements(self.key)\n    self.requery_dependents()\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.duplicate_record","title":"<code>duplicate_record(children=None, skip_prompt_save=False)</code>","text":"<p>Duplicate the currently selected record.</p> <p>The before_duplicate and after_duplicate callbacks are run during this process to give some control over the process.</p> <p>Parameters:</p> Name Type Description Default <code>children</code> <code>bool</code> <p>Duplicate child records (as defined by Relationships that were set up) before duplicating this record.</p> <code>None</code> <code>skip_prompt_save</code> <code>bool</code> <p>(optional) True to skip prompting to save dirty records</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[bool, None]</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def duplicate_record(\n    self,\n    children: bool = None,\n    skip_prompt_save: bool = False,\n) -&gt; Union[bool, None]:  # TODO check return type, returns True within\n\"\"\"Duplicate the currently selected record.\n\n    The before_duplicate and after_duplicate callbacks are run during this\n    process to give some control over the process.\n\n    Args:\n        children: Duplicate child records (as defined by `Relationship`s that were\n            set up) before duplicating this record.\n        skip_prompt_save: (optional) True to skip prompting to save dirty records\n\n    Returns:\n        None\n    \"\"\"\n    # Ensure that there is actually something to duplicate\n    if not self.row_count or self.pk_is_virtual():\n        return None\n\n    # prompt_save\n    if (\n        not skip_prompt_save\n        # don't update self/dependents if we are going to below anyway\n        and self.prompt_save(update_elements=False) == SAVE_FAIL\n    ):\n        return None\n\n    # callback\n    if \"before_duplicate\" in self.callbacks and not self.callbacks[\n        \"before_duplicate\"\n    ](self.frm, self.frm.window, self.key):\n        return None\n\n    if children is None:\n        children = self.duplicate_children\n\n    child_list = []\n    if children:\n        child_list = self.relationships.get_update_cascade_tables(self.table)\n\n    msg_children = \", \".join(child_list)\n    msg = lang.duplicate_child.format_map(\n        LangFormat(children=msg_children)\n    ).splitlines()\n    layout = [[sg.T(line, font=\"bold\")] for line in msg]\n    if len(child_list):\n        answer = sg.Window(\n            lang.duplicate_child_title,\n            [\n                layout,\n                [\n                    sg.Button(\n                        button_text=lang.duplicate_child_button_dupparent,\n                        key=\"parent\",\n                        use_ttk_buttons=themepack.use_ttk_buttons,\n                        pad=themepack.popup_button_pad,\n                    )\n                ],\n                [\n                    sg.Button(\n                        button_text=lang.duplicate_child_button_dupboth,\n                        key=\"cascade\",\n                        use_ttk_buttons=themepack.use_ttk_buttons,\n                        pad=themepack.popup_button_pad,\n                    )\n                ],\n                [\n                    sg.Button(\n                        button_text=lang.button_cancel,\n                        key=\"cancel\",\n                        use_ttk_buttons=themepack.use_ttk_buttons,\n                        pad=themepack.popup_button_pad,\n                    )\n                ],\n            ],\n            keep_on_top=True,\n            modal=True,\n            ttk_theme=themepack.ttk_theme,\n            icon=themepack.icon,\n        ).read(close=True)\n        if answer[0] == \"parent\":\n            children = False\n        elif answer[0] in [\"cancel\", None]:\n            return True\n    else:\n        msg = lang.duplicate_single\n        answer = self.frm.popup.yes_no(lang.duplicate_single_title, msg)\n        if answer == \"no\":\n            return True\n    # Store our current pk, so we can move to it if the duplication fails\n    pk = self.current.pk\n\n    # Have the driver duplicate the record\n    result = self.driver.duplicate_record(self, children)\n    if result.attrs[\"exception\"]:\n        self.driver.rollback()\n        self.frm.popup.ok(\n            lang.duplicate_failed_title,\n            lang.duplicate_failed.format_map(\n                LangFormat(exception=result.attrs[\"exception\"])\n            ),\n        )\n    else:\n        pk = result.attrs[\"lastrowid\"]\n\n    # callback\n    if \"after_duplicate\" in self.callbacks:\n        if not self.callbacks[\"after_duplicate\"](\n            self.frm, self.frm.window, self.key\n        ):\n            self.driver.rollback()\n        else:\n            self.driver.commit()\n    else:\n        self.driver.commit()\n    self.driver.commit()\n\n    # requery and move to new pk\n    self.requery(select_first=False)\n    self.set_by_pk(pk, skip_prompt_save=True)\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.get_description_for_pk","title":"<code>get_description_for_pk(pk)</code>","text":"<p>Get the description from the DataSet on the matching pk.</p> <p>Return the description from description_column for the row where the pk_column = pk.</p> <p>Parameters:</p> Name Type Description Default <code>pk</code> <code>int</code> <p>The primary key from which to find the description for</p> required <p>Returns:</p> Type Description <code>Union[str, int, None]</code> <p>The value found in the description column, or None if nothing is found</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_description_for_pk(self, pk: int) -&gt; Union[str, int, None]:\n\"\"\"Get the description from the `DataSet` on the matching pk.\n\n    Return the description from `DataSet.description_column` for the row where the\n    `DataSet.pk_column` = `pk`.\n\n    Args:\n        pk: The primary key from which to find the description for\n\n    Returns:\n        The value found in the description column, or None if nothing is found\n    \"\"\"\n    # We don't want to update other views comboboxes/tableviews until row is\n    # actually saved. So first check their current\n    current_row = self.current.get_original()\n    if current_row[self.pk_column] == pk:\n        return current_row[self.description_column]\n    try:\n        index = self.rows.loc[self.rows[self.pk_column] == pk].index[0]\n        return self.rows[self.description_column].iloc[index]\n    except IndexError:\n        return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.pk_is_virtual","title":"<code>pk_is_virtual(pk=None)</code>","text":"<p>Check whether pk is virtual.</p> <p>Parameters:</p> Name Type Description Default <code>pk</code> <code>int</code> <p>The pk to check. If None, the pk of the current row will be checked.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True or False based on whether the row is virtual</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def pk_is_virtual(self, pk: int = None) -&gt; bool:\n\"\"\"Check whether pk is virtual.\n\n    Args:\n        pk: The pk to check. If None, the pk of the current row will be checked.\n\n    Returns:\n        True or False based on whether the row is virtual\n    \"\"\"\n    if not self.row_count:\n        return False\n\n    if pk is None:\n        pk = self.current.get()[self.pk_column]\n\n    return bool(pk in self.virtual_pks)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.purge_row_backup","title":"<code>purge_row_backup()</code>","text":"<p>Deletes the backup row from the dataset.</p> <p>This method sets the \"row_backup\" attribute of the dataset to None.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def purge_row_backup(self) -&gt; None:\n\"\"\"Deletes the backup row from the dataset.\n\n    This method sets the \"row_backup\" attribute of the dataset to None.\n    \"\"\"\n    self.rows.attrs[\"row_backup\"] = None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.table_values","title":"<code>table_values(columns=None, mark_unsaved=False, apply_search_filter=False, apply_cell_format_fn=True)</code>","text":"<p>Create a values list of TableRowss for use in a PySimpleGUI Table element.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>List[str]</code> <p>A list of column names to create table values for. Defaults to getting them from the rows DataFrame.</p> <code>None</code> <code>mark_unsaved</code> <code>bool</code> <p>Place a marker next to virtual records, or records with unsaved changes.</p> <code>False</code> <code>apply_search_filter</code> <code>bool</code> <p>Filter rows to only those columns in search_order that contain search_string.</p> <code>False</code> <code>apply_cell_format_fn</code> <code>bool</code> <p>If set, apply() <code>DataSet.column_info[col].cell_format_fn</code> to rows column</p> <code>True</code> <p>Returns:</p> Type Description <code>List[TableRow]</code> <p>A list of TableRows suitable for using with PySimpleGUI Table element</p> <code>List[TableRow]</code> <p>values.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def table_values(\n    self,\n    columns: List[str] = None,\n    mark_unsaved: bool = False,\n    apply_search_filter: bool = False,\n    apply_cell_format_fn: bool = True,\n) -&gt; List[TableRow]:\n\"\"\"Create a values list of `TableRows`s for use in a PySimpleGUI Table element.\n\n    Args:\n        columns: A list of column names to create table values for. Defaults to\n            getting them from the `DataSet.rows` DataFrame.\n        mark_unsaved: Place a marker next to virtual records, or records with\n            unsaved changes.\n        apply_search_filter: Filter rows to only those columns in\n            `DataSet.search_order` that contain `DataSet.search_string`.\n        apply_cell_format_fn: If set, apply()\n            `DataSet.column_info[col].cell_format_fn` to rows column\n\n    Returns:\n        A list of `TableRow`s suitable for using with PySimpleGUI Table element\n        values.\n    \"\"\"\n    if not self.row_count:\n        return []\n\n    try:\n        all_columns = list(self.rows.columns)\n    except IndexError:\n        all_columns = []\n\n    columns = all_columns if columns is None else columns\n\n    rows = self.rows.copy()\n    pk_column = self.pk_column\n\n    if mark_unsaved:\n        virtual_row_pks = self.virtual_pks.copy()\n        # add pk of current row if it has changes\n        if self.current.has_backup and not self.current.get().equals(\n            self.current.get_original()\n        ):\n            virtual_row_pks.append(\n                self.rows.loc[\n                    self.rows[pk_column] == self.current.get()[pk_column],\n                    pk_column,\n                ].to_numpy()[0]\n            )\n\n        # Create a new column 'marker' with the desired values\n        rows[\"marker\"] = \" \"\n        mask = rows[pk_column].isin(virtual_row_pks)\n        rows.loc[mask, \"marker\"] = themepack.marker_unsaved\n    else:\n        rows[\"marker\"] = \" \"\n\n    # get fk descriptions\n    rows = self.map_fk_descriptions(rows, columns)\n\n    # return early if empty\n    if rows.empty:\n        return []\n\n    # filter rows to only contain search, or virtual/unsaved row\n    if apply_search_filter and self.search_string not in EMPTY:\n        masks = [\n            rows[col].astype(str).str.contains(self.search_string, case=False)\n            | rows[pk_column].isin(virtual_row_pks)\n            for col in self.search_order\n        ]\n        mask_pd = pd.concat(masks, axis=1).any(axis=1)\n        # Apply the mask to filter the DataFrame\n        rows = rows[mask_pd]\n\n    # apply cell format functions\n    if apply_cell_format_fn:\n        for column in columns:\n            if self.column_info[column] and self.column_info[column].cell_format_fn:\n                fn = self.column_info[column].cell_format_fn\n                rows[column] = rows[column].apply(fn)\n\n    # set the pk to the index to use below\n    rows[\"pk_idx\"] = rows[pk_column].copy()\n    rows = rows.set_index(\"pk_idx\")\n\n    # insert the marker\n    columns.insert(0, \"marker\")\n\n    # resort rows with requested columns\n    rows = rows[columns]\n\n    # fastest way yet to generate list of TableRows\n    return [\n        TableRow(pk, values.tolist())\n        for pk, values in zip(\n            rows.index,\n            np.vstack((rows.fillna(\"\").astype(\"O\").to_numpy().T, rows.index)).T,\n        )\n    ]\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.column_likely_in_selector","title":"<code>column_likely_in_selector(column)</code>","text":"<p>Determines whether the given column is likely to be displayed in a selector.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The name of the column to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the column is likely to be displayed, False otherwise.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def column_likely_in_selector(self, column: str) -&gt; bool:\n\"\"\"Determines whether the given column is likely to be displayed in a selector.\n\n    Args:\n        column: The name of the column to check.\n\n    Returns:\n        True if the column is likely to be displayed, False otherwise.\n    \"\"\"\n    # If there are no sg.Table selectors, return False\n    if not any(\n        isinstance(e[\"element\"], sg.PySimpleGUI.Table) for e in self.selector\n    ):\n        return False\n\n    # If table headings are not used, assume the column is displayed, return True\n    if not any(\"TableBuilder\" in e[\"element\"].metadata for e in self.selector):\n        return True\n\n    # Otherwise, Return True/False if the column is in the list of table headings\n    return any(\n        \"TableBuilder\" in e[\"element\"].metadata\n        and column in e[\"element\"].metadata[\"TableBuilder\"].columns\n        for e in self.selector\n    )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.combobox_values","title":"<code>combobox_values(column_name, insert_placeholder=True)</code>","text":"<p>Returns the values to use in a sg.Combobox as a list of ElementRow objects.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>The name of the table column for which to get the values.</p> required <code>insert_placeholder</code> <code>bool</code> <p>If True, inserts combo_placeholder as first value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[List[ElementRow], None]</code> <p>A list of ElementRow objects representing the possible values for the</p> <code>Union[List[ElementRow], None]</code> <p>combobox column, or None if no matching relationship is found.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def combobox_values(\n    self, column_name: str, insert_placeholder: bool = True\n) -&gt; Union[List[ElementRow], None]:\n\"\"\"Returns the values to use in a sg.Combobox as a list of ElementRow objects.\n\n    Args:\n        column_name: The name of the table column for which to get the values.\n        insert_placeholder: If True, inserts `Languagepack.combo_placeholder` as\n            first value.\n\n    Returns:\n        A list of ElementRow objects representing the possible values for the\n        combobox column, or None if no matching relationship is found.\n    \"\"\"\n    if not self.row_count:\n        return None\n\n    rels = self.relationships.get_rels_for(self.table)\n    rel = next((r for r in rels if r.fk_column == column_name), None)\n    if rel is None:\n        return None\n\n    if not self.frm[rel.parent_table].row_count:\n        return None\n\n    rows = self.frm[rel.parent_table].rows.copy()\n    pk_column = self.frm[rel.parent_table].pk_column\n    description = self.frm[rel.parent_table].description_column\n\n    # revert to original row (so unsaved changes don't show up in dropdowns)\n    parent_current_row = self.frm[rel.parent_table].current.get_original()\n    rows.iloc[self.frm[rel.parent_table].current.index] = parent_current_row\n\n    # fastest way yet to generate this list of ElementRow\n    combobox_values = [\n        ElementRow(*values)\n        for values in np.column_stack((rows[pk_column], rows[description]))\n    ]\n\n    if insert_placeholder:\n        combobox_values.insert(0, ElementRow(\"Null\", lang.combo_placeholder))\n    return combobox_values\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.get_related_table_for_column","title":"<code>get_related_table_for_column(column)</code>","text":"<p>Get parent table name as it relates to this column.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name to get related table information for</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the related table, or the current table if none are found</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_related_table_for_column(self, column: str) -&gt; str:\n\"\"\"Get parent table name as it relates to this column.\n\n    Args:\n        column: The column name to get related table information for\n\n    Returns:\n        The name of the related table, or the current table if none are found\n    \"\"\"\n    rels = self.relationships.get_rels_for(self.table)\n    for rel in rels:\n        if column == rel.fk_column:\n            return rel.parent_table\n    return self.table  # None could be found, return our own table instead\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.map_fk_descriptions","title":"<code>map_fk_descriptions(rows, columns=None)</code>","text":"<p>Maps foreign key descriptions to the specified columns in the given DataFrame.</p> Note <p>If passing in rows, please pass in a copy, eg: <code>frm[data_key].rows.copy()</code></p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>DataFrame</code> <p>The DataFrame containing the data to be processed.</p> required <code>columns</code> <code>list[str]</code> <p>(Optional) The list of column names to map foreign key descriptions to. If none are provided, all columns of the DataFrame will be searched for foreign-key relationships.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The processed DataFrame with foreign key descriptions mapped to the specified columns.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def map_fk_descriptions(\n    self, rows: pd.DataFrame, columns: list[str] = None\n) -&gt; pd.DataFrame:\n\"\"\"Maps foreign key descriptions to the specified columns in the given\n    DataFrame.\n\n\n    Note:\n        If passing in `DataSet.rows`, please pass in a copy, eg:\n        ```frm[data_key].rows.copy()```\n\n    Args:\n        rows: The DataFrame containing the data to be processed.\n        columns: (Optional) The list of column names to map foreign key descriptions\n            to. If none are provided, all columns of the DataFrame will be searched\n            for foreign-key relationships.\n\n    Returns:\n        The processed DataFrame with foreign key descriptions mapped to the\n            specified columns.\n    \"\"\"\n    if columns is None:\n        columns = rows.columns\n\n    # get fk descriptions\n    rels = self.relationships.get_rels_for(self.table)\n    for col in columns:\n        for rel in rels:\n            if col == rel.fk_column:\n                # return early if parent is empty\n                if not self.frm[rel.parent_table].row_count:\n                    return rows\n\n                parent_df = self.frm[rel.parent_table].rows\n                parent_pk_column = self.frm[rel.parent_table].pk_column\n\n                # get this before map(), to revert below\n                parent_current_row = self.frm[\n                    rel.parent_table\n                ].current.get_original()\n                condition = rows[col] == parent_current_row[parent_pk_column]\n\n                # map descriptions to fk column\n                description_column = self.frm[rel.parent_table].description_column\n                mapping_dict = parent_df.set_index(parent_pk_column)[\n                    description_column\n                ].to_dict()\n                rows[col] = rows[col].map(mapping_dict)\n\n                # revert any unsaved changes for the single row\n                rows.loc[condition, col] = parent_current_row[description_column]\n\n                # we only want transform col once\n                break\n    return rows\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.quick_editor","title":"<code>quick_editor(pk_update_funct=None, funct_param=None, skip_prompt_save=False, column_attributes=None)</code>","text":"<p>The quick editor is a dynamic PySimpleGUI Window for quick editing of tables. This is very useful for putting a button next to a combobox or listbox so that the available values can be added/edited/deleted easily. Note: This is not typically used by the end user, as it can be configured from the field() convenience function.</p> <p>Parameters:</p> Name Type Description Default <code>pk_update_funct</code> <code>Callable</code> <p>(optional) A function to call to determine the pk to select by default when the quick editor loads.</p> <code>None</code> <code>funct_param</code> <code>any</code> <p>(optional) A parameter to pass to the 'pk_update_funct'</p> <code>None</code> <code>skip_prompt_save</code> <code>bool</code> <p>(Optional) True to skip prompting to save dirty records</p> <code>False</code> <code>column_attributes</code> <code>dict</code> <p>(Optional) Dictionary specifying column attributes for column_info. The dictionary should be in the form {column_name: {attribute: value}}.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def quick_editor(\n    self,\n    pk_update_funct: Callable = None,\n    funct_param: any = None,\n    skip_prompt_save: bool = False,\n    column_attributes: dict = None,\n) -&gt; None:\n\"\"\"The quick editor is a dynamic PySimpleGUI Window for quick editing of tables.\n    This is very useful for putting a button next to a combobox or listbox so that\n    the available values can be added/edited/deleted easily.\n    Note: This is not typically used by the end user, as it can be configured from\n    the `field()` convenience function.\n\n    Args:\n        pk_update_funct: (optional) A function to call to determine the pk to select\n            by default when the quick editor loads.\n        funct_param: (optional) A parameter to pass to the 'pk_update_funct'\n        skip_prompt_save: (Optional) True to skip prompting to save dirty records\n        column_attributes: (Optional) Dictionary specifying column attributes for\n            `DataSet.column_info`. The dictionary should be in the form\n            {column_name: {attribute: value}}.\n\n    Returns:\n        None\n    \"\"\"\n    # prompt_save\n    if (\n        not skip_prompt_save\n        # don't update self/dependents if we are going to below anyway\n        and self.prompt_save(update_elements=False) == SAVE_FAIL\n    ):\n        return\n\n    # Reset the keygen to keep consistent naming\n    logger.info(\"Creating Quick Editor window\")\n    keygen.reset()\n    data_key = self.key\n    layout = []\n    table_builder = TableBuilder(\n        num_rows=10,\n        sort_enable=True,\n        allow_cell_edits=True,\n        add_save_heading_button=True,\n        style=TableStyler(row_height=25),\n    )\n\n    for col in self.column_info.names:\n        # set widths\n        width = int(55 / (len(self.column_info.names) - 1))\n        if col == self.pk_column:\n            # make pk column either max length of contained pks, or len of name\n            width = int(\n                np.nanmax([self.rows[col].astype(str).map(len).max(), len(col) + 1])\n            )\n            justify = \"left\"\n        elif self.column_info[col] and self.column_info[col].python_type in [\n            int,\n            float,\n            Decimal,\n        ]:\n            justify = \"right\"\n        else:\n            justify = \"left\"\n        table_builder.add_column(\n            col, col.capitalize(), width=width, col_justify=justify\n        )\n\n    layout.append(\n        [\n            selector(\n                data_key,\n                table_builder,\n                key=f\"{data_key}:quick_editor\",\n            )\n        ]\n    )\n    y_pad = 10\n    layout.append([actions(data_key, edit_protect=False)])\n    layout.append([sg.Sizer(h_pixels=0, v_pixels=y_pad)])\n\n    fields_layout = [[sg.Sizer(h_pixels=0, v_pixels=y_pad)]]\n\n    rels = self.relationships.get_rels_for(self.table)\n    for col in self.column_info.names:\n        found = False\n        column = f\"{data_key}.{col}\"\n        # make sure isn't pk\n        if col != self.pk_column:\n            # display checkboxes\n            if (\n                self.column_info[column]\n                and self.column_info[column].python_type == bool\n            ):\n                fields_layout.append([field(column, sg.Checkbox)])\n                found = True\n                break\n            # or display sg.combos\n            for rel in rels:\n                if col == rel.fk_column:\n                    fields_layout.append(\n                        [field(column, sg.Combo, quick_editor=False)]\n                    )\n                    found = True\n                    break\n            # otherwise, just display a regular input\n            if not found:\n                fields_layout.append([field(column)])\n\n    fields_layout.append([sg.Sizer(h_pixels=0, v_pixels=y_pad)])\n    layout.append([sg.Frame(\"Fields\", fields_layout, expand_x=True)])\n    layout.append([sg.Sizer(h_pixels=0, v_pixels=10)])\n    layout.append(\n        [\n            sg.StatusBar(\n                \" \" * 100,\n                key=\"info:quick_editor\",\n                metadata={\"type\": ElementType.INFO},\n            )\n        ],\n    )\n\n    quick_win = sg.Window(\n        lang.quick_edit_title.format_map(LangFormat(data_key=data_key)),\n        layout,\n        keep_on_top=True,\n        modal=True,\n        finalize=True,\n        ttk_theme=themepack.ttk_theme,  # Must, otherwise will redraw window\n        icon=themepack.icon,\n        enable_close_attempted_event=True,\n    )\n    quick_frm = Form(\n        self.frm.driver,\n        bind_window=quick_win,\n        live_update=True,\n    )\n\n    # Select the current entry to start with\n    if pk_update_funct is not None:\n        if funct_param is None:\n            quick_frm[data_key].set_by_pk(pk_update_funct())\n        else:\n            quick_frm[data_key].set_by_pk(pk_update_funct(funct_param))\n\n    if column_attributes:\n        for col, kwargs in column_attributes.items():\n            if quick_frm[data_key].column_info[col]:\n                for attr, value in kwargs.items():\n                    quick_frm[data_key].column_info[col][attr] = value\n\n    while True:\n        event, values = quick_win.read()\n\n        if quick_frm.process_events(event, values):\n            logger.debug(\n                f\"PySimpleSQL Quick Editor event handler handled the event {event}!\"\n            )\n        if event == \"-WINDOW CLOSE ATTEMPTED-\":\n            if quick_frm.popup.popup_info:\n                quick_frm.popup.popup_info.close()\n            self.requery()\n            self.frm.update_elements()\n            quick_win.close()\n            quick_frm.close(close_driver=False)\n            break\n        logger.debug(f\"This event ({event}) is not yet handled.\")\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.add_simple_transform","title":"<code>add_simple_transform(transforms)</code>","text":"<p>Merge a dictionary of transforms into the _simple_transform dictionary.</p> Example <pre><code>{'entry_date' : {\n    'decode' : lambda row,col: datetime.utcfromtimestamp(int(row[col])).strftime('%m/%d/%y'),\n    'encode' : lambda row,col: datetime.strptime(row[col], '%m/%d/%y').replace(tzinfo=timezone.utc).timestamp(),\n}}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>transforms</code> <code>SimpleTransformsDict</code> <p>A dict of dicts containing either 'encode' or 'decode' along with a callable to do the transform. See example above</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def add_simple_transform(self, transforms: SimpleTransformsDict) -&gt; None:\n\"\"\"Merge a dictionary of transforms into the `DataSet._simple_transform`\n    dictionary.\n\n    Example:\n        ```python\n        {'entry_date' : {\n            'decode' : lambda row,col: datetime.utcfromtimestamp(int(row[col])).strftime('%m/%d/%y'),\n            'encode' : lambda row,col: datetime.strptime(row[col], '%m/%d/%y').replace(tzinfo=timezone.utc).timestamp(),\n        }}\n        ```\n\n    Args:\n        transforms: A dict of dicts containing either 'encode' or 'decode' along\n            with a callable to do the transform. See example above\n\n    Returns:\n        None\n    \"\"\"  # noqa: E501\n    for k, v in transforms.items():\n        if not callable(v):\n            RuntimeError(f\"Transform for {k} must be callable!\")\n        self._simple_transform[k] = v\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.purge_virtual","title":"<code>purge_virtual()</code>","text":"<p>Purge virtual rows from the DataFrame.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def purge_virtual(self) -&gt; None:\n\"\"\"Purge virtual rows from the DataFrame.\n\n    Returns:\n        None\n    \"\"\"\n    # remove the rows where virtual is True in place, along with the corresponding\n    # virtual attribute\n    virtual_rows = self.rows[self.rows[self.pk_column].isin(self.virtual_pks)]\n    self.rows = self.rows.drop(index=virtual_rows.index)\n    self.rows.attrs[\"virtual\"] = []\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.sort_by_column","title":"<code>sort_by_column(column, table, reverse=False)</code>","text":"<p>Sort the DataFrame by column. Using the mapped relationships of the database, foreign keys will automatically sort based on the parent table's description column, rather than the foreign key number.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The name of the column to sort the DataFrame by</p> required <code>table</code> <code>str</code> <p>The name of the table the column belongs to</p> required <code>reverse</code> <code>bool</code> <p>Reverse the sort; False = ASC, True = DESC</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def sort_by_column(self, column: str, table: str, reverse: bool = False) -&gt; None:\n\"\"\"Sort the DataFrame by column. Using the mapped relationships of the database,\n    foreign keys will automatically sort based on the parent table's description\n    column, rather than the foreign key number.\n\n    Args:\n        column: The name of the column to sort the DataFrame by\n        table: The name of the table the column belongs to\n        reverse: Reverse the sort; False = ASC, True = DESC\n\n    Returns:\n        None\n    \"\"\"\n    # Target sorting by this DataFrame\n\n    # We don't want to sort by foreign keys directly - we want to sort by the\n    # description column of the foreign table that the foreign key references\n    tmp_column = None\n    rels = self.relationships.get_rels_for(table)\n\n    transformed = False\n    for rel in rels:\n        if column == rel.fk_column:\n            # Copy the specified column and apply mapping to obtain fk descriptions\n            column_copy = pd.DataFrame(self.rows[column].copy())\n            column_copy = self.map_fk_descriptions(column_copy, [column])[column]\n\n            # Assign the transformed column to the temporary column\n            tmp_column = f\"temp_{rel.parent_table}.{rel.pk_column}\"\n            self.rows[tmp_column] = column_copy\n\n            # Use the temporary column as the new sorting column\n            column = tmp_column\n\n            transformed = True\n            break\n\n    # handling datetime\n    # TODO: user-defined format\n    if (\n        not transformed\n        and self.column_info[column]\n        and self.column_info[column].python_type in (dt.date, dt.time, dt.datetime)\n    ):\n        tmp_column = f\"temp_{column}\"\n        self.rows[tmp_column] = pd.to_datetime(self.rows[column])\n        column = tmp_column\n\n    # sort\n    try:\n        self.rows = self.rows.sort_values(\n            column,\n            ascending=not reverse,\n        )\n    except (KeyError, TypeError) as e:\n        logger.debug(f\"DataFrame could not sort by column {column}. {e}\")\n    finally:\n        # Drop the temporary description column (if it exists)\n        if tmp_column is not None:\n            self.rows = self.rows.drop(columns=tmp_column, errors=\"ignore\")\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.sort_by_index","title":"<code>sort_by_index(index, table, reverse=False)</code>","text":"<p>Sort the self.rows DataFrame by column index Using the mapped relationships of the database, foreign keys will automatically sort based on the parent table's description column, rather than the foreign key number.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the column to sort the DateFrame by</p> required <code>table</code> <code>str</code> <p>The name of the table the column belongs to</p> required <code>reverse</code> <code>bool</code> <p>Reverse the sort; False = ASC, True = DESC</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def sort_by_index(self, index: int, table: str, reverse: bool = False) -&gt; None:\n\"\"\"Sort the self.rows DataFrame by column index Using the mapped relationships\n    of the database, foreign keys will automatically sort based on the parent\n    table's description column, rather than the foreign key number.\n\n    Args:\n        index: The index of the column to sort the DateFrame by\n        table: The name of the table the column belongs to\n        reverse: Reverse the sort; False = ASC, True = DESC\n\n    Returns:\n        None\n    \"\"\"\n    column = self.rows.columns[index]\n    self.sort_by_column(column, table, reverse)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.store_sort_settings","title":"<code>store_sort_settings()</code>","text":"<p>Store the current sort settingg. Sort settings are just the sort column and reverse setting. Sort order can be restored with load_sort_settings().</p> <p>Returns:</p> Type Description <code>list</code> <p>A list containing the sort_column and the sort_reverse</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def store_sort_settings(self) -&gt; list:\n\"\"\"Store the current sort settingg. Sort settings are just the sort column and\n    reverse setting. Sort order can be restored with `DataSet.load_sort_settings()`.\n\n    Returns:\n        A list containing the sort_column and the sort_reverse\n    \"\"\"\n    return [self.rows.attrs[\"sort_column\"], self.rows.attrs[\"sort_reverse\"]]\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.load_sort_settings","title":"<code>load_sort_settings(sort_settings)</code>","text":"<p>Load a previously stored sort setting. Sort settings are just the sort columm and reverse setting.</p> <p>Parameters:</p> Name Type Description Default <code>sort_settings</code> <code>list</code> <p>A list as returned by store_sort_settings()</p> required Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def load_sort_settings(self, sort_settings: list) -&gt; None:\n\"\"\"Load a previously stored sort setting. Sort settings are just the sort columm\n    and reverse setting.\n\n    Args:\n        sort_settings: A list as returned by `DataSet.store_sort_settings()`\n    \"\"\"\n    self.rows.attrs[\"sort_column\"] = sort_settings[0]\n    self.rows.attrs[\"sort_reverse\"] = sort_settings[1]\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.sort_reset","title":"<code>sort_reset()</code>","text":"<p>Reset the sort order to the original order as defined by the DataFram index.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def sort_reset(self) -&gt; None:\n\"\"\"Reset the sort order to the original order as defined by the DataFram index.\n\n    Returns:\n        None\n    \"\"\"\n    # Restore the original sort order\n    self.rows = self.rows.sort_index()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.sort","title":"<code>sort(table, update_elements=True, sort_order=None)</code>","text":"<p>Sort according to the internal sort_column and sort_reverse variables. This is a good way to re-sort without changing the sort_cycle.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table associated with this DataSet.  Passed along to sort_by_column()</p> required <code>update_elements</code> <code>bool</code> <p>Update associated selectors and navigation buttons, and table header sort marker.</p> <code>True</code> <code>sort_order</code> <p>A SORT_* constant (SORT_NONE, SORT_ASC, SORT_DESC). Note that the update_elements parameter must = True to use</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def sort(self, table: str, update_elements: bool = True, sort_order=None) -&gt; None:\n\"\"\"Sort according to the internal sort_column and sort_reverse variables. This\n    is a good way to re-sort without changing the sort_cycle.\n\n    Args:\n        table: The table associated with this DataSet.  Passed along to\n            `DataSet.sort_by_column()`\n        update_elements: Update associated selectors and navigation buttons, and\n            table header sort marker.\n        sort_order: A SORT_* constant (SORT_NONE, SORT_ASC, SORT_DESC).\n            Note that the update_elements parameter must = True to use\n\n    Returns:\n        None\n    \"\"\"\n    pk = self.current.pk\n    if self.rows.attrs[\"sort_column\"] is None:\n        logger.debug(\"Sort column is None.  Resetting sort.\")\n        self.sort_reset()\n    else:\n        logger.debug(f\"Sorting by column {self.rows.attrs['sort_column']}\")\n        self.sort_by_column(\n            self.rows.attrs[\"sort_column\"], table, self.rows.attrs[\"sort_reverse\"]\n        )\n    self.set_by_pk(\n        pk,\n        update_elements=False,\n        requery_dependents=False,\n        skip_prompt_save=True,\n    )\n    if update_elements and self.row_count:\n        self.frm.update_selectors(self.key)\n        self.frm.update_actions(self.key)\n        self._update_headings(self.rows.attrs[\"sort_column\"], sort_order)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.sort_cycle","title":"<code>sort_cycle(column, table, update_elements=True)</code>","text":"<p>Cycle between original sort order of the DataFrame, ASC by column, and DESC by column with each call.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name to cycle the sort on</p> required <code>table</code> <code>str</code> <p>The table that the column belongs to</p> required <code>update_elements</code> <code>bool</code> <p>Passed to sort to update update associated selectors and navigation buttons, and table header sort marker.</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>A sort constant; SORT_NONE, SORT_ASC, or SORT_DESC</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def sort_cycle(self, column: str, table: str, update_elements: bool = True) -&gt; int:\n\"\"\"Cycle between original sort order of the DataFrame, ASC by column, and DESC\n    by column with each call.\n\n    Args:\n        column: The column name to cycle the sort on\n        table: The table that the column belongs to\n        update_elements: Passed to `DataSet.sort` to update update associated\n            selectors and navigation buttons, and table header sort marker.\n\n    Returns:\n        A sort constant; SORT_NONE, SORT_ASC, or SORT_DESC\n    \"\"\"\n    if column != self.rows.attrs[\"sort_column\"]:\n        self.rows.attrs[\"sort_column\"] = column\n        self.rows.attrs[\"sort_reverse\"] = False\n        self.sort(table, update_elements=update_elements, sort_order=SORT_ASC)\n        return SORT_ASC\n    if not self.rows.attrs[\"sort_reverse\"]:\n        self.rows.attrs[\"sort_reverse\"] = True\n        self.sort(table, update_elements=update_elements, sort_order=SORT_DESC)\n        return SORT_DESC\n    self.rows.attrs[\"sort_reverse\"] = False\n    self.rows.attrs[\"sort_column\"] = None\n    self.sort(table, update_elements=update_elements, sort_order=SORT_NONE)\n    return SORT_NONE\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.insert_row","title":"<code>insert_row(row, idx=None)</code>","text":"<p>Insert a new virtual row into the DataFrame. Virtual rows are ones that exist in memory, but not in the database. When a save action is performed, virtual rows will be added into the database.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>dict</code> <p>A dict representation of a row of data</p> required <code>idx</code> <code>int</code> <p>The index where the row should be inserted (default to last index)</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def insert_row(self, row: dict, idx: int = None) -&gt; None:\n\"\"\"Insert a new virtual row into the DataFrame. Virtual rows are ones that exist\n    in memory, but not in the database. When a save action is performed, virtual\n    rows will be added into the database.\n\n    Args:\n        row: A dict representation of a row of data\n        idx: The index where the row should be inserted (default to last index)\n\n    Returns:\n        None\n    \"\"\"\n    row_series = pd.Series(row, dtype=object)\n    # Infer better data types for the Series\n    # row_series = row_series.infer_objects()\n    if self.rows.empty:\n        self.rows = Result.set(\n            pd.concat([self.rows, row_series.to_frame().T], ignore_index=True)\n        )\n    else:\n        attrs = self.rows.attrs.copy()\n\n        # TODO: idx currently does nothing\n        if idx is None:\n            idx = self.row_count\n\n        self.rows = pd.concat(\n            [self.rows, row_series.to_frame().T], ignore_index=True\n        )\n        self.rows.attrs = attrs\n\n    self.rows.attrs[\"virtual\"].append(row[self.pk_column])\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.DataSet.validate_field","title":"<code>validate_field(column_name, new_value, widget=None, display_message=False)</code>","text":"<p>Validate the given field value for the specified column.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>The name of the column to validate the field against.</p> required <code>new_value</code> <code>Any</code> <p>The new value to validate.</p> required <code>widget</code> <p>The widget associated with the field. (Optional)</p> <code>None</code> <code>display_message</code> <code>bool</code> <p>Flag to display validation messages. (Default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the field value is valid, False otherwise.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def validate_field(\n    self,\n    column_name: str,\n    new_value: Any,\n    widget=None,\n    display_message: bool = False,\n) -&gt; bool:\n\"\"\"Validate the given field value for the specified column.\n\n    Args:\n        column_name: The name of the column to validate the field against.\n        new_value: The new value to validate.\n        widget: The widget associated with the field. (Optional)\n        display_message: Flag to display validation messages. (Default: False)\n\n    Returns:\n        True if the field value is valid, False otherwise.\n    \"\"\"\n    if column_name in self.column_info:\n        # Validate the new value against the column's validation rules\n        response = self.column_info[column_name].validate(new_value)\n        # If validation fails, display an error message and return False\n        if response.exception:\n            self.frm.popup.info(\n                lang[response.exception].format_map(\n                    LangFormat(value=response.value, rule=response.rule)\n                ),\n                display_message=display_message,\n            )\n            if widget and themepack.validate_exception_animation is not None:\n                themepack.validate_exception_animation(widget)\n            return False\n        # If validation passes, update the info element and return True\n        self.frm.popup.update_info_element(erase=True)\n        return True\n    logger.debug(f\"{column_name} not in dataset.column_info!\")\n    return None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form","title":"<code>Form</code>  <code>dataclass</code>","text":"<p>Form class.</p> <p>Maintains an internal version of the actual database DataSet objects can be accessed by key, I.e. frm['data_key'].</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>SQLDriver</code> <p>Supported SQLDriver. See Sqlite(), Mysql(), Postgres()</p> required <code>bind_window</code> <code>InitVar[Window]</code> <p>Bind this window to the Form</p> <code>None</code> <code>parent</code> <code>Form</code> <p>(optional)Parent Form to base dataset off of</p> <code>None</code> <code>filter</code> <code>str</code> <p>(optional) Only import elements with the same filter set. Typically set with field(), but can also be set manually as a dict with the key 'filter' set in the element's metadata</p> <code>None</code> <code>select_first</code> <code>InitVar[bool]</code> <p>(optional) Default:True. For each top-level parent, selects first row, populating children as well.</p> <code>True</code> <code>prompt_save</code> <p>(optional) Default:PROMPT_MODE. Prompt to save changes when dirty records are present. There are two modes available, PROMPT_MODE to prompt to save when unsaved changes are present. AUTOSAVE_MODE to automatically save when unsaved changes are present.</p> required <code>save_quiet</code> <code>bool</code> <p>(optional) Default:False. True to skip info popup on save. Error popups will still be shown.</p> <code>False</code> <code>duplicate_children</code> <code>bool</code> <p>(optional) Default:True. If record has children, prompt user to choose to duplicate current record, or both.</p> <code>True</code> <code>description_column_names</code> <code>List[str]</code> <p>(optional) A list of names to use for the DataSet object's description column, displayed in Listboxes, Comboboxes, and Tables instead of the primary key. The first matching column of the table is given priority. If no match is found, the second column is used. Default list: ['description', 'name', 'title'].</p> <code>field(default_factory=lambda : ['description', 'name', 'title'])</code> <code>live_update</code> <code>bool</code> <p>(optional) Default value is False. If True, changes made in a field will be immediately pushed to associated selectors. If False, changes will be pushed only after a save action.</p> <code>False</code> <code>validate_mode</code> <code>ValidateMode</code> <p>Passed to DataSet init to set validate mode. STRICT to prevent invalid values from being entered. RELAXED allows invalid input, but ensures validation occurs before saving to the database.</p> <code>RELAXED</code> <p>Returns:</p> Type Description <p>None</p>"},{"location":"#pysimplesql.pysimplesql.Form.close","title":"<code>close(reset_keygen=True, close_driver=True)</code>","text":"<p>Safely close out the Form.</p> <p>Parameters:</p> Name Type Description Default <code>reset_keygen</code> <code>bool</code> <p>True to reset the keygen for this Form</p> <code>True</code> <code>close_driver</code> <code>bool</code> <p>True to also close associated driver</p> <code>True</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def close(self, reset_keygen: bool = True, close_driver: bool = True) -&gt; None:\n\"\"\"Safely close out the `Form`.\n\n    Args:\n        reset_keygen: True to reset the keygen for this `Form`\n        close_driver: True to also close associated `Form.driver`\n    \"\"\"\n    # First delete the dataset associated\n    DataSet.purge_form(self, reset_keygen)\n    if self.popup.popup_info:\n        self.popup.popup_info.close()\n    Form.purge_instance(self)\n    if close_driver:\n        self.driver.close()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.bind","title":"<code>bind(win)</code>","text":"<p>Bind the PySimpleGUI Window to the Form for the purpose of GUI element, event and relationship mapping. This can happen automatically on Form creation with the bind parameter and is not typically called by the end user. This function literally just groups all the auto_* methods. auto_map_elements(), auto_map_events().</p> <p>Parameters:</p> Name Type Description Default <code>win</code> <code>Window</code> <p>The PySimpleGUI window</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def bind(self, win: sg.Window) -&gt; None:\n\"\"\"Bind the PySimpleGUI Window to the Form for the purpose of GUI element, event\n    and relationship mapping. This can happen automatically on `Form` creation with\n    the bind parameter and is not typically called by the end user. This function\n    literally just groups all the auto_* methods. `Form.auto_map_elements()`,\n    `Form.auto_map_events()`.\n\n    Args:\n        win: The PySimpleGUI window\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(\"Binding Window to Form\")\n    self.window = win\n    self.popup = Popup(self.window)\n    self.auto_map_elements(win)\n    self.auto_map_events(win)\n    self.update_elements()\n    # Creating cell edit instance, even if we arn't going to use it.\n    self._celledit = _CellEdit(self)\n    self.window.TKroot.bind(\"&lt;Double-Button-1&gt;\", self._celledit)\n    self._liveupdate = _LiveUpdate(self)\n    if self.live_update:\n        self.set_live_update(enable=True)\n    logger.debug(\"Binding finished!\")\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.execute","title":"<code>execute(query)</code>","text":"<p>Execute a query.</p> <p>Convenience function to pass along to execute.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to execute</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas DataFrame object with attrs set for lastrowid and exception</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def execute(self, query: str) -&gt; pd.DataFrame:\n\"\"\"Execute a query.\n\n    Convenience function to pass along to `SQLDriver.execute`.\n\n    Args:\n        query: The query to execute\n\n    Returns:\n        A pandas DataFrame object with attrs set for lastrowid and exception\n    \"\"\"\n    return self.driver.execute(query)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.commit","title":"<code>commit()</code>","text":"<p>Commit a transaction.</p> <p>Convenience function to pass along to commit().</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def commit(self) -&gt; None:\n\"\"\"Commit a transaction.\n\n    Convenience function to pass along to `SQLDriver.commit()`.\n\n    Returns:\n        None\n    \"\"\"\n    self.driver.commit()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.set_callback","title":"<code>set_callback(callback_name, fctn)</code>","text":"<p>Set Form callbacks.</p> <p>A runtime error will be raised if the callback is not supported. The following callbacks are supported: update_elements Called after elements are updated via update_elements(). This allows for other GUI manipulation on each update of the GUI edit_enable Called before editing mode is enabled. This can be useful for asking for a password for example edit_disable Called after the editing mode is disabled.</p> <p>{element_name} Called while updating MAPPED element. This overrides the default element update implementation. Note that the {element_name} callback function needs to return a value to pass to Win[element].update()</p> <p>Parameters:</p> Name Type Description Default <code>callback_name</code> <code>str</code> <p>The name of the callback, from the list above</p> required <code>fctn</code> <code>Callable[[Form, Window], Union[None, bool]]</code> <p>The function to call. Note, the function must take in two parameters, a Form instance, and a PySimpleGUI.Window instance</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_callback(\n    self, callback_name: str, fctn: Callable[[Form, sg.Window], Union[None, bool]]\n) -&gt; None:\n\"\"\"Set `Form` callbacks.\n\n    A runtime error will be raised if the callback is not\n    supported. The following callbacks are supported: update_elements Called after\n    elements are updated via `Form.update_elements()`. This allows for other GUI\n    manipulation on each update of the GUI edit_enable Called before editing mode is\n    enabled. This can be useful for asking for a password for example edit_disable\n    Called after the editing mode is disabled.\n\n    {element_name} Called while updating MAPPED element. This overrides the default\n    element update implementation. Note that the {element_name} callback function\n    needs to return a value to pass to Win[element].update()\n\n    Args:\n        callback_name: The name of the callback, from the list above\n        fctn: The function to call. Note, the function must take in two parameters,\n            a Form instance, and a PySimpleGUI.Window instance\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(f\"Callback {callback_name} being set on Form\")\n    supported = [\"update_elements\", \"edit_enable\", \"edit_disable\"]\n\n    # Add in mapped elements\n    for mapped in self.element_map:\n        supported.append(mapped.element.key)\n\n    # Add in other window elements\n    for element in self.window.key_dict:\n        supported.append(element)\n\n    if callback_name in supported:\n        self.callbacks[callback_name] = fctn\n    else:\n        raise RuntimeError(\n            f'Callback \"{callback_name}\" not supported. callback: {callback_name} '\n            f\"supported: {supported}\"\n        )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.add_dataset","title":"<code>add_dataset(data_key, table, pk_column, description_column, query='', order_clause='')</code>","text":"<p>Manually add a DataSet object to the Form When you attach to a database, PySimpleSQL isn't aware of what it contains until this command is run Note that auto_add_datasets() does this automatically, which is called when a Form is created.</p> <p>Parameters:</p> Name Type Description Default <code>data_key</code> <code>str</code> <p>The key to give this DataSet.  Use frm['data_key'] to access it.</p> required <code>table</code> <code>str</code> <p>The name of the table in the database</p> required <code>pk_column</code> <code>str</code> <p>The primary key column of the table in the database</p> required <code>description_column</code> <code>str</code> <p>The column to be used to display to users in listboxes, comboboxes, etc.</p> required <code>query</code> <code>str</code> <p>The initial query for the table.  Auto generates \"SELECT * FROM {table}\" if none is passed</p> <code>''</code> <code>order_clause</code> <code>str</code> <p>The initial sort order for the query</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def add_dataset(\n    self,\n    data_key: str,\n    table: str,\n    pk_column: str,\n    description_column: str,\n    query: str = \"\",\n    order_clause: str = \"\",\n) -&gt; None:\n\"\"\"Manually add a `DataSet` object to the `Form` When you attach to a database,\n    PySimpleSQL isn't aware of what it contains until this command is run Note that\n    `Form.auto_add_datasets()` does this automatically, which is called when a\n    `Form` is created.\n\n    Args:\n        data_key: The key to give this `DataSet`.  Use frm['data_key'] to access it.\n        table: The name of the table in the database\n        pk_column: The primary key column of the table in the database\n        description_column: The column to be used to display to users in listboxes,\n            comboboxes, etc.\n        query: The initial query for the table.  Auto generates \"SELECT * FROM\n            {table}\" if none is passed\n        order_clause: The initial sort order for the query\n\n    Returns:\n        None\n    \"\"\"\n    self.datasets.update(\n        {\n            data_key: DataSet(\n                data_key,\n                self,\n                table,\n                pk_column,\n                description_column,\n                query,\n                order_clause,\n            )\n        }\n    )\n    # set a default sort order\n    self[data_key].set_search_order([description_column])\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.set_fk_column_cascade","title":"<code>set_fk_column_cascade(child_table, fk_column, update_cascade=None, delete_cascade=None)</code>","text":"<p>Set a foreign key's update_cascade and delete_cascade behavior.</p> <p>auto_add_relationships() does this automatically from the database schema.</p> <p>Parameters:</p> Name Type Description Default <code>child_table</code> <code>str</code> <p>Child table with the foreign key.</p> required <code>fk_column</code> <code>str</code> <p>Foreign key column of the child table.</p> required <code>update_cascade</code> <code>bool</code> <p>True to requery and filter child table on selected parent primary key.</p> <code>None</code> <code>delete_cascade</code> <code>bool</code> <p>True to delete dependent child records if parent record is deleted.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_fk_column_cascade(\n    self,\n    child_table: str,\n    fk_column: str,\n    update_cascade: bool = None,\n    delete_cascade: bool = None,\n) -&gt; None:\n\"\"\"Set a foreign key's update_cascade and delete_cascade behavior.\n\n    `SQLDriver.auto_add_relationships()` does this automatically from the database\n    schema.\n\n    Args:\n        child_table: Child table with the foreign key.\n        fk_column: Foreign key column of the child table.\n        update_cascade: True to requery and filter child table on selected parent\n            primary key.\n        delete_cascade: True to delete dependent child records if parent record is\n            deleted.\n\n    Returns:\n        None\n    \"\"\"\n    for rel in self.relationships:\n        if rel.child_table == child_table and rel.fk_column == fk_column:\n            logger.info(f\"Updating {fk_column=} self.relationships.\")\n            if update_cascade is not None:\n                rel.update_cascade = update_cascade\n            if delete_cascade is not None:\n                rel.delete_cascade = delete_cascade\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.auto_add_datasets","title":"<code>auto_add_datasets()</code>","text":"<p>Automatically add DataSet objects from the database.</p> <p>Works by looping through the tables available and creating a DataSet object for each. Each dataset key by default name of the table.</p> <p>This is called automatically when a <code>Form</code> is created. Note that add_dataset() can do this manually on a per-table basis.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def auto_add_datasets(self) -&gt; None:\n\"\"\"Automatically add `DataSet` objects from the database.\n\n    Works by looping through the tables available and creating a `DataSet` object\n    for each. Each dataset key by default name of the table.\n\n    This is called automatically when a `Form ` is created. Note that\n    `Form.add_dataset()` can do this manually on a per-table basis.\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(\n        \"Automatically generating dataset for each table in the sqlite database\"\n    )\n    # Clear any current dataset so successive calls won't double the entries\n    self.datasets = {}\n    tables = self.driver.get_tables()\n    for table in tables:\n        column_info = self.driver.column_info(table)\n\n        # auto generate description column.  Default it to the 2nd column,\n        # but can be overwritten below\n        description_column = column_info.col_name(1)\n        for col in column_info.names:\n            if col in self.description_column_names:\n                description_column = col\n                break\n\n        # Get our pk column\n        pk_column = self.driver.pk_column(table)\n\n        data_key = table\n        logger.debug(\n            f'Adding DataSet \"{data_key}\" on table {table} to Form with primary '\n            f\"key {pk_column} and description of {description_column}\"\n        )\n        self.add_dataset(data_key, table, pk_column, description_column)\n        self.datasets[data_key].column_info = column_info\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.map_element","title":"<code>map_element(element, dataset, column, where_column=None, where_value=None)</code>","text":"<p>Map a PySimpleGUI element to a specific DataSet column.  This is what makes the GUI automatically update to the contents of the database.  This happens automatically when a PySimpleGUI Window is bound to a Form by using the bind parameter of Form creation, or by executing auto_map_elements() as long as the element metadata is configured properly. This method can be used to manually map any element to any DataSet column regardless of metadata configuration.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>A PySimpleGUI Element</p> required <code>dataset</code> <code>DataSet</code> <p>A DataSet object</p> required <code>column</code> <code>str</code> <p>The name of the column to bind to the element</p> required <code>where_column</code> <code>str</code> <p>Used for ke, value shorthand TODO: expand on this</p> <code>None</code> <code>where_value</code> <code>str</code> <p>Used for ey, value shorthand TODO: expand on this</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def map_element(\n    self,\n    element: sg.Element,\n    dataset: DataSet,\n    column: str,\n    where_column: str = None,\n    where_value: str = None,\n) -&gt; None:\n\"\"\"Map a PySimpleGUI element to a specific `DataSet` column.  This is what makes\n    the GUI automatically update to the contents of the database.  This happens\n    automatically when a PySimpleGUI Window is bound to a `Form` by using the bind\n    parameter of `Form` creation, or by executing `Form.auto_map_elements()` as long\n    as the element metadata is configured properly. This method can be used to\n    manually map any element to any `DataSet` column regardless of metadata\n    configuration.\n\n    Args:\n        element: A PySimpleGUI Element\n        dataset: A `DataSet` object\n        column: The name of the column to bind to the element\n        where_column: Used for ke, value shorthand TODO: expand on this\n        where_value: Used for ey, value shorthand TODO: expand on this\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(f\"Mapping element {element.key}\")\n    self.element_map.append(\n        ElementMap(element, dataset, column, where_column, where_value)\n    )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.add_info_element","title":"<code>add_info_element(element)</code>","text":"<p>Add an element to be updated with info messages.</p> <p>Must be either</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Union[StatusBar, Text]</code> <p>A PySimpleGUI Element</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def add_info_element(self, element: Union[sg.StatusBar, sg.Text]) -&gt; None:\n\"\"\"Add an element to be updated with info messages.\n\n    Must be either\n\n    Args:\n        element: A PySimpleGUI Element\n\n    Returns:\n        None\n    \"\"\"\n    if not isinstance(element, (sg.StatusBar, sg.Text)):\n        logger.debug(f\"Can only add info {element!s}\")\n        return\n    logger.debug(f\"Mapping element {element.key}\")\n    self.popup.info_elements.append(element)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.auto_map_elements","title":"<code>auto_map_elements(win, keys=None)</code>","text":"<p>Automatically map PySimpleGUI Elements to DataSet columns. A special naming convention has to be used for automatic mapping to happen.  Note that map_element() can be used to manually map an Element to a column. Automatic mapping relies on a special naming convention as well as certain data in the Element's metadata. The convenience functions field(), selector(), and actions() do this automatically and should be used in almost all cases to make elements that conform to this standard, but this information will allow you to do this manually if needed. For individual fields, Element keys must be named 'Table.column'. Additionally, the metadata must contain a dict with the key of 'type' set to FIELD. For selectors, the key can be named whatever you want, but the metadata must contain a dict with the key of 'type' set to SELECTOR.</p> <p>Parameters:</p> Name Type Description Default <code>win</code> <code>Window</code> <p>A PySimpleGUI Window</p> required <code>keys</code> <code>List[str]</code> <p>(optional) Limit the auto mapping to this list of Element keys</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def auto_map_elements(self, win: sg.Window, keys: List[str] = None) -&gt; None:\n\"\"\"Automatically map PySimpleGUI Elements to `DataSet` columns. A special naming\n    convention has to be used for automatic mapping to happen.  Note that\n    `Form.map_element()` can be used to manually map an Element to a column.\n    Automatic mapping relies on a special naming convention as well as certain data\n    in the Element's metadata. The convenience functions `field()`, `selector()`,\n    and `actions()` do this automatically and should be used in almost all cases to\n    make elements that conform to this standard, but this information will allow you\n    to do this manually if needed. For individual fields, Element keys must be named\n    'Table.column'. Additionally, the metadata must contain a dict with the key of\n    'type' set to `ElementType.FIELD`. For selectors, the key can be named whatever\n    you want, but the metadata must contain a dict with the key of 'type' set to\n    `ElementType.SELECTOR`.\n\n    Args:\n        win: A PySimpleGUI Window\n        keys: (optional) Limit the auto mapping to this list of Element keys\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(\"Automapping elements\")\n    # Clear previously mapped elements so successive calls won't produce duplicates\n    self.element_map = []\n    for key in win.key_dict:\n        element = win[key]\n\n        # Skip this element if there is no metadata present\n        if not isinstance(element.metadata, dict):\n            continue\n\n        # Process the filter to ensure this element should be mapped to this Form\n        if (\n            \"filter\" in element.metadata\n            and element.metadata[\"filter\"] == self.filter\n        ):\n            element.metadata[\"Form\"] = self\n        if self.filter is None and \"filter\" not in element.metadata:\n            element.metadata[\"Form\"] = self\n\n        # Skip this element if it's an event\n        if element.metadata[\"type\"] == ElementType.EVENT:\n            continue\n\n        if element.metadata[\"Form\"] != self:\n            continue\n        # If we passed in a custom list of elements\n        if keys is not None and key not in keys:\n            continue\n\n        # Map Record Element\n        if element.metadata[\"type\"] == ElementType.FIELD:\n            # Does this record imply a where clause (indicated by ?)\n            # If so, we can strip out the information we need\n            data_key = element.metadata[\"data_key\"]\n            field = element.metadata[\"field\"]\n            if \"?\" in field:\n                table_info, where_info = field.split(\"?\")\n            else:\n                table_info = field\n                where_info = None\n            try:\n                table, col = table_info.split(\".\")\n            except ValueError:\n                table, col = table_info, None\n\n            if where_info is None:\n                where_column = where_value = None\n            else:\n                where_column, where_value = where_info.split(\"=\")\n\n            # make sure we don't use reserved keywords that could end up in a query\n            for keyword in [table, col, where_column, where_value]:\n                if keyword is not None and keyword:\n                    self.driver.check_keyword(keyword)\n\n            # DataSet objects are named after the tables they represent\n            # (with an optional prefix)\n            # TODO: How to handle the prefix?\n            # TODO: check in DataSet.table\n            if table in self.datasets and col in self[table].column_info:\n                # Map this element to DataSet.column\n                self.map_element(\n                    element, self[table], col, where_column, where_value\n                )\n                if isinstance(element, (_EnhancedInput, _EnhancedMultiline)) and (\n                    col in self[table].column_info.names\n                    and self[table].column_info[col].notnull\n                ):\n                    element.add_placeholder(\n                        placeholder=lang.notnull_placeholder,\n                        color=themepack.placeholder_color,\n                    )\n                if (\n                    isinstance(element, _EnhancedInput)\n                    and col in self[table].column_info.names\n                ):\n                    element.add_validate(self[table], col)\n\n        # Map Selector Element\n        elif element.metadata[\"type\"] == ElementType.SELECTOR:\n            k = element.metadata[\"table\"]\n            if k is None:\n                continue\n            if element.metadata[\"Form\"] != self:\n                continue\n            if \"?\" in k:\n                table_info, where_info = k.split(\"?\")\n                where_column, where_value = where_info.split(\"=\")\n            else:\n                table_info = k\n                where_column = where_value = None\n            data_key = table_info\n\n            if data_key in self.datasets:\n                self[data_key].add_selector(\n                    element, data_key, where_column, where_value\n                )\n\n                # Enable sorting if TableBuilder is present\n                if (\n                    isinstance(element, sg.Table)\n                    and \"TableBuilder\" in element.metadata\n                ):\n                    table_builder: TableBuilder = element.metadata[\"TableBuilder\"]\n                    # We need a whole chain of things to happen\n                    # when a heading is clicked on:\n                    # 1 Run the ResultRow.sort_cycle() with the correct column name\n                    # 2 Run TableBuilder._update_headings() with the:\n                    #   Table element, sort_column, sort_reverse\n                    # 3 Run update_elements() to see the changes\n                    table_builder._enable_heading_function(\n                        element,\n                        _HeadingCallback(self, data_key),\n                    )\n\n            else:\n                logger.debug(f\"Can not add selector {element!s}\")\n\n        elif element.metadata[\"type\"] == ElementType.INFO:\n            self.add_info_element(element)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.set_element_clauses","title":"<code>set_element_clauses(element, where_clause=None, order_clause=None)</code>","text":"<p>Set the where and/or order clauses for the specified element in the element map.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>A PySimpleGUI Element</p> required <code>where_clause</code> <code>str</code> <p>(optional) The where clause to set</p> <code>None</code> <code>order_clause</code> <code>str</code> <p>(optional) The order clause to set</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_element_clauses(\n    self, element: sg.Element, where_clause: str = None, order_clause: str = None\n) -&gt; None:\n\"\"\"Set the where and/or order clauses for the specified element in the element\n    map.\n\n    Args:\n        element: A PySimpleGUI Element\n        where_clause: (optional) The where clause to set\n        order_clause: (optional) The order clause to set\n\n    Returns:\n        None\n    \"\"\"\n    for mapped in self.element_map:\n        if mapped.element == element:\n            mapped.where_clause = where_clause\n            mapped.order_clause = order_clause\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.map_event","title":"<code>map_event(event, fctn, table=None)</code>","text":"<p>Manually map a PySimpleGUI event (returned by Window.read()) to a callable. The callable will execute when the event is detected by process_events(). Most users will not have to manually map any events, as auto_map_events() will create most needed events when a PySimpleGUI Window is bound to a Form by using the bind parameter of Form creation, or by executing auto_map_elements().</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event to watch for, as returned by PySimpleGUI Window.read() (an element name for example)</p> required <code>fctn</code> <code>Callable[[None], None]</code> <p>The callable to run when the event is detected. It should take no parameters and have no return value</p> required <code>table</code> <code>str</code> <p>(optional) currently not used</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def map_event(\n    self, event: str, fctn: Callable[[None], None], table: str = None\n) -&gt; None:\n\"\"\"Manually map a PySimpleGUI event (returned by Window.read()) to a callable.\n    The callable will execute when the event is detected by `Form.process_events()`.\n    Most users will not have to manually map any events, as `Form.auto_map_events()`\n    will create most needed events when a PySimpleGUI Window is bound to a `Form` by\n    using the bind parameter of `Form` creation, or by executing\n    `Form.auto_map_elements()`.\n\n    Args:\n        event: The event to watch for, as returned by PySimpleGUI Window.read() (an\n            element name for example)\n        fctn: The callable to run when the event is detected. It should take no\n            parameters and have no return value\n        table: (optional) currently not used\n\n    Returns:\n        None\n    \"\"\"\n    dic = {\"event\": event, \"function\": fctn, \"table\": table}\n    logger.debug(f\"Mapping event {event} to function {fctn}\")\n    self.event_map.append(dic)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.replace_event","title":"<code>replace_event(event, fctn, table=None)</code>","text":"<p>Replace an event that was manually mapped with auto_map_events() or map_event(). The callable will execute.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event to watch for, as returned by PySimpleGUI Window.read() (an element name for example)</p> required <code>fctn</code> <code>Callable[[None], None]</code> <p>The callable to run when the event is detected. It should take no parameters and have no return value</p> required <code>table</code> <code>str</code> <p>(optional) currently not used</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def replace_event(\n    self, event: str, fctn: Callable[[None], None], table: str = None\n) -&gt; None:\n\"\"\"Replace an event that was manually mapped with `Form.auto_map_events()` or\n    `Form.map_event()`. The callable will execute.\n\n    Args:\n        event: The event to watch for, as returned by PySimpleGUI Window.read() (an\n            element name for example)\n        fctn: The callable to run when the event is detected. It should take no\n            parameters and have no return value\n        table: (optional) currently not used\n\n    Returns:\n        None\n    \"\"\"\n    for e in self.event_map:\n        if e[\"event\"] == event:\n            e[\"function\"] = fctn\n            e[\"table\"] = table if table is not None else e[\"table\"]\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.auto_map_events","title":"<code>auto_map_events(win)</code>","text":"<p>Automatically map events. pysimplesql relies on certain events to function properly. This method maps all the record navigation (previous, next, etc.) and database actions (insert, delete, save, etc.).  Note that the event mapper is very general-purpose, and you can add your own event triggers to the mapper using map_event(), or even replace one of the auto-generated ones if you have specific needs by using replace_event().</p> <p>Parameters:</p> Name Type Description Default <code>win</code> <code>Window</code> <p>A PySimpleGUI Window</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def auto_map_events(self, win: sg.Window) -&gt; None:\n\"\"\"Automatically map events. pysimplesql relies on certain events to function\n    properly. This method maps all the record navigation (previous, next, etc.) and\n    database actions (insert, delete, save, etc.).  Note that the event mapper is\n    very general-purpose, and you can add your own event triggers to the mapper\n    using `Form.map_event()`, or even replace one of the auto-generated ones if you\n    have specific needs by using `Form.replace_event()`.\n\n    Args:\n        win: A PySimpleGUI Window\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(\"Automapping events\")\n    # Clear mapped events to ensure successive calls won't produce duplicates\n    self.event_map = []\n\n    for key in win.key_dict:\n        # key = str(key)  # sometimes end up with an integer element 0?TODO:Research\n        element = win[key]\n        # Skip this element if there is no metadata present\n        if not isinstance(element.metadata, dict):\n            logger.debug(f\"Skipping mapping of {key}\")\n            continue\n        if element.metadata[\"Form\"] != self:\n            continue\n        if element.metadata[\"type\"] == ElementType.EVENT:\n            event_type = element.metadata[\"event_type\"]\n            table = element.metadata[\"table\"]\n            column = element.metadata[\"column\"]\n            function = element.metadata[\"function\"]\n            funct = None\n\n            data_key = table\n            data_key = data_key if data_key in self.datasets else None\n            if event_type == EventType.FIRST:\n                if data_key:\n                    funct = self[data_key].first\n            elif event_type == EventType.PREVIOUS:\n                if data_key:\n                    funct = self[data_key].previous\n            elif event_type == EventType.NEXT:\n                if data_key:\n                    funct = self[data_key].next\n            elif event_type == EventType.LAST:\n                if data_key:\n                    funct = self[data_key].last\n            elif event_type == EventType.SAVE:\n                if data_key:\n                    funct = self[data_key].save_record\n            elif event_type == EventType.INSERT:\n                if data_key:\n                    funct = self[data_key].insert_record\n            elif event_type == EventType.DELETE:\n                if data_key:\n                    funct = self[data_key].delete_record\n            elif event_type == EventType.DUPLICATE:\n                if data_key:\n                    funct = self[data_key].duplicate_record\n            elif event_type == EventType.EDIT_PROTECT_DB:\n                self.edit_protect()  # Enable it!\n                funct = self.edit_protect\n            elif event_type == EventType.SAVE_DB:\n                funct = self.save_records\n            elif event_type == EventType.SEARCH:\n                # Build the search box name\n                search_element, command = key.split(\":\")\n                search_box = f\"{search_element}:search_input\"\n                if data_key:\n                    funct = functools.partial(self[data_key].search, search_box)\n                    # add placeholder\n                    self.window[search_box].add_placeholder(\n                        placeholder=lang.search_placeholder,\n                        color=themepack.placeholder_color,\n                    )\n                    # bind dataset\n                    self.window[search_box].bind_dataset(self[data_key])\n            elif event_type == EventType.QUICK_EDIT:\n                quick_editor_kwargs = {}\n                if \"quick_editor_kwargs\" in element.metadata:\n                    quick_editor_kwargs = element.metadata[\"quick_editor_kwargs\"]\n                referring_table = table\n                table = self[table].get_related_table_for_column(column)\n                funct = functools.partial(\n                    self[table].quick_editor,\n                    self[referring_table].current.get_value,\n                    column,\n                    **quick_editor_kwargs if quick_editor_kwargs else {},\n                )\n            elif event_type == EventType.FUNCTION:\n                funct = function\n            else:\n                logger.debug(f\"Unsupported event_type: {event_type}\")\n\n            if funct is not None:\n                self.map_event(key, funct, data_key)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.edit_protect","title":"<code>edit_protect()</code>","text":"<p>The edit protect system allows records to be protected from accidental editing by disabling the insert, delete, duplicate and save buttons on the GUI. A button to toggle the edit protect mode can easily be added by using the actions() convenience function.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def edit_protect(self) -&gt; None:\n\"\"\"The edit protect system allows records to be protected from accidental\n    editing by disabling the insert, delete, duplicate and save buttons on the GUI.\n    A button to toggle the edit protect mode can easily be added by using the\n    `actions()` convenience function.\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(\"Toggling edit protect mode.\")\n    # Callbacks\n    if (\n        self._edit_protect\n        and \"edit_enable\" in self.callbacks\n        and not self.callbacks[\"edit_enable\"](self, self.window)\n    ):\n        return\n    if (\n        not self._edit_protect\n        and \"edit_disable\" in self.callbacks\n        and not self.callbacks[\"edit_disable\"](self, self.window)\n    ):\n        return\n\n    self._edit_protect = not self._edit_protect\n    self.update_elements(edit_protect_only=True)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.get_edit_protect","title":"<code>get_edit_protect()</code>","text":"<p>Get the current edit protect state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if edit protect is enabled, False if not enabled</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_edit_protect(self) -&gt; bool:\n\"\"\"Get the current edit protect state.\n\n    Returns:\n        True if edit protect is enabled, False if not enabled\n    \"\"\"\n    return self._edit_protect\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.prompt_save","title":"<code>prompt_save()</code>","text":"<p>Prompt to save if any GUI changes are found the affect any table on this form. The helps prevent data entry loss when performing an action that changes the current record of a DataSet.</p> <p>Returns:</p> Type Description <code>Type[PromptSaveReturn]</code> <p>One of the prompt constant values: PromptSaveReturn.PROCEED,</p> <code>Type[PromptSaveReturn]</code> <p>PromptSaveReturn.DISCARDED, PromptSaveReturn.NONE</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def prompt_save(self) -&gt; Type[PromptSaveReturn]:\n\"\"\"Prompt to save if any GUI changes are found the affect any table on this\n    form. The helps prevent data entry loss when performing an action that changes\n    the current record of a `DataSet`.\n\n    Returns:\n        One of the prompt constant values: PromptSaveReturn.PROCEED,\n        PromptSaveReturn.DISCARDED, PromptSaveReturn.NONE\n    \"\"\"\n    user_prompted = False  # Has the user been prompted yet?\n    for data_key in self.datasets:\n        if not self[data_key]._prompt_save:\n            continue\n\n        if self[data_key].records_changed(recursive=False) and not user_prompted:\n            # only show popup once, regardless of how many dataset have changed\n            user_prompted = True\n            if self._prompt_save == AUTOSAVE_MODE:\n                save_changes = \"yes\"\n            else:\n                save_changes = self.popup.yes_no(\n                    lang.form_prompt_save_title, lang.form_prompt_save\n                )\n            if save_changes != \"yes\":\n                # update the elements to erase any GUI changes,\n                # since we are choosing not to save\n                for data_key_ in self.datasets:\n                    self[data_key_].purge_virtual()\n                    self[data_key_].current.restore_backup()\n                self.update_elements()\n                # We did have a change, regardless if the user chose not to save\n                return PromptSaveReturn.DISCARDED\n            break\n    if user_prompted:\n        self.save_records(check_prompt_save=True)\n    return PromptSaveReturn.PROCEED if user_prompted else PromptSaveReturn.NONE\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.set_prompt_save","title":"<code>set_prompt_save(mode)</code>","text":"<p>Set the prompt to save action when navigating records for all DataSet objects associated with this Form.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>Use PROMPT_MODE to prompt to save when unsaved changes are present. AUTOSAVE_MODE to autosave when unsaved changes are present.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_prompt_save(self, mode: int) -&gt; None:\n\"\"\"Set the prompt to save action when navigating records for all `DataSet`\n    objects associated with this `Form`.\n\n    Args:\n        mode: Use `PROMPT_MODE` to prompt to save when unsaved changes are present.\n            `AUTOSAVE_MODE` to autosave when unsaved changes are present.\n\n    Returns:\n        None\n    \"\"\"\n    self._prompt_save = mode\n    for data_key in self.datasets:\n        self[data_key].set_prompt_save(mode)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.set_force_save","title":"<code>set_force_save(force=False)</code>","text":"<p>Force save without checking for changes first, so even an unchanged record will be written back to the database.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>True to force unchanged records to save.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_force_save(self, force: bool = False) -&gt; None:\n\"\"\"Force save without checking for changes first, so even an unchanged record\n    will be written back to the database.\n\n    Args:\n        force: True to force unchanged records to save.\n\n    Returns:\n        None\n    \"\"\"\n    self.force_save = force\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.set_live_update","title":"<code>set_live_update(enable)</code>","text":"<p>Toggle the immediate sync of field elements with other elements in Form.</p> <p>When live-update is enabled, changes in a field element are immediately reflected in other elements in the same Form. This is achieved by binding the Window to watch for events that may trigger updates, such as mouse clicks, key presses, or selection changes in a combo box.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>If True, changes in a field element are immediately reflected in other elements in the same Form. If False, live-update is disabled.</p> required Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_live_update(self, enable: bool) -&gt; None:\n\"\"\"Toggle the immediate sync of field elements with other elements in Form.\n\n    When live-update is enabled, changes in a field element are immediately\n    reflected in other elements in the same Form. This is achieved by binding the\n    Window to watch for events that may trigger updates, such as mouse clicks, key\n    presses, or selection changes in a combo box.\n\n    Args:\n        enable: If True, changes in a field element are immediately reflected in\n            other elements in the same Form. If False, live-update is disabled.\n    \"\"\"\n    bind_events = [\"&lt;ButtonRelease-1&gt;\", \"&lt;KeyPress&gt;\", \"&lt;&lt;ComboboxSelected&gt;&gt;\"]\n    if enable and not self._liveupdate_binds:\n        self.live_update = True\n        for event in bind_events:\n            self._liveupdate_binds[event] = self.window.TKroot.bind(\n                event, self._liveupdate, \"+\"\n            )\n    elif not enable and self._liveupdate_binds:\n        for event, bind in self._liveupdate_binds.items():\n            self.window.TKroot.unbind(event, bind)\n        self._liveupdate_binds = {}\n        self.live_update = False\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.save_records","title":"<code>save_records(table=None, cascade_only=False, check_prompt_save=False, update_elements=True)</code>","text":"<p>Save records of all DataSet objects` associated with this Form.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Name of table to save, as well as any cascaded relationships. Used in prompt_save()</p> <code>None</code> <code>cascade_only</code> <code>bool</code> <p>Save only tables with cascaded relationships. Default False.</p> <code>False</code> <code>check_prompt_save</code> <code>bool</code> <p>Passed to save_record_recursive to check if individual DataSet has prompt_save enabled. Used when save_records() is called from prompt_save().</p> <code>False</code> <code>update_elements</code> <code>bool</code> <p>(optional) Passed to save_record_recursive()</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[SAVE_SUCCESS, SAVE_FAIL, SAVE_NONE]</code> <p>result - can be used with RETURN BITMASKS</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def save_records(\n    self,\n    table: str = None,\n    cascade_only: bool = False,\n    check_prompt_save: bool = False,\n    update_elements: bool = True,\n) -&gt; Union[SAVE_SUCCESS, SAVE_FAIL, SAVE_NONE]:\n\"\"\"Save records of all `DataSet` objects` associated with this `Form`.\n\n    Args:\n        table: Name of table to save, as well as any cascaded relationships. Used in\n            `DataSet.prompt_save()`\n        cascade_only: Save only tables with cascaded relationships. Default False.\n        check_prompt_save: Passed to `DataSet.save_record_recursive` to check if\n            individual `DataSet` has prompt_save enabled. Used when\n            `Form.save_records()` is called from `Form.prompt_save()`.\n        update_elements: (optional) Passed to `Form.save_record_recursive()`\n\n    Returns:\n        result - can be used with RETURN BITMASKS\n    \"\"\"\n    if check_prompt_save:\n        logger.debug(\"Saving records in all datasets that allow prompt_save...\")\n    else:\n        logger.debug(\"Saving records in all datasets...\")\n\n    display_message = not self.save_quiet\n\n    result = 0\n    show_message = True\n    failed_tables = []\n\n    if table:\n        tables = [table]  # if passed single table\n    # for cascade_only, build list of top-level dataset that have children\n    elif cascade_only:\n        tables = [\n            dataset.table\n            for dataset in self.datasets.values()\n            if len(self.relationships.get_update_cascade_tables(dataset.table))\n            and self.relationships.get_parent(dataset.table) is None\n        ]\n    # default behavior, build list of top-level dataset (ones without a parent)\n    else:\n        tables = [\n            dataset.table\n            for dataset in self.datasets.values()\n            if self.relationships.get_parent(dataset.table) is None\n        ]\n\n    # call save_record_recursive on tables, which saves from last to first.\n    result_list = []\n    for q in tables:\n        res = self[q].save_record_recursive(\n            results={},\n            display_message=False,\n            check_prompt_save=check_prompt_save,\n            update_elements=update_elements,\n        )\n        result_list.append(res)\n\n    # flatten list of result dicts\n    results = {k: v for d in result_list for k, v in d.items()}\n    logger.debug(f\"Form.save_records - results of tables - {results}\")\n\n    # get tables that failed\n    for t, res in results.items():\n        if not res &amp; SHOW_MESSAGE:\n            show_message = (\n                False  # Only one instance of not showing the message hides all\n            )\n        if res &amp; SAVE_FAIL:\n            failed_tables.append(t)\n        result |= res\n\n    # Build a descriptive message, since the save spans many tables potentially\n    msg = \"\"\n    msg_tables = \", \".join(failed_tables)\n    if result &amp; SAVE_FAIL:\n        if result &amp; SAVE_SUCCESS:\n            msg = lang.form_save_partial\n        msg += lang.form_save_problem.format_map(LangFormat(tables=msg_tables))\n        if show_message:\n            self.popup.ok(lang.form_save_problem_title, msg)\n        return result\n    msg = lang.form_save_success if result &amp; SAVE_SUCCESS else lang.form_save_none\n    if show_message:\n        self.popup.info(msg, display_message=display_message)\n    return result\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.update_elements","title":"<code>update_elements(target_data_key=None, edit_protect_only=False, omit_elements=None)</code>","text":"<p>Updated the GUI elements to reflect values from the database for this Form instance only. Not to be confused with the main update_elements(), which updates GUI elements for all Form instances. This method also executes update_selectors(), which updates selector elements.</p> <p>Parameters:</p> Name Type Description Default <code>target_data_key</code> <code>str</code> <p>(optional) dataset key to update elements for, otherwise updates elements for all datasets</p> <code>None</code> <code>edit_protect_only</code> <code>bool</code> <p>(optional) If true, only update items affected by edit_protect</p> <code>False</code> <code>omit_elements</code> <code>List[str]</code> <p>A list of elements to omit updating</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update_elements(\n    self,\n    target_data_key: str = None,\n    edit_protect_only: bool = False,\n    omit_elements: List[str] = None,\n) -&gt; None:\n\"\"\"Updated the GUI elements to reflect values from the database for this `Form`\n    instance only. Not to be confused with the main `update_elements()`, which\n    updates GUI elements for all `Form` instances. This method also executes\n    `update_selectors()`, which updates selector elements.\n\n    Args:\n        target_data_key: (optional) dataset key to update elements for, otherwise\n            updates elements for all datasets\n        edit_protect_only: (optional) If true, only update items affected by\n            edit_protect\n        omit_elements: A list of elements to omit updating\n\n    Returns:\n        None\n    \"\"\"\n    if omit_elements is None:\n        omit_elements = []\n\n    msg = \"edit protect\" if edit_protect_only else \"PySimpleGUI\"\n    logger.debug(f\"update_elements(): Updating {msg} elements\")\n    # Disable/Enable action elements based on edit_protect or other situations\n\n    for data_key in self.datasets:\n        if target_data_key is not None and data_key != target_data_key:\n            continue\n\n        # disable mapped elements for this table if\n        # there are no records in this table or edit protect mode\n        disable = not self[data_key].row_count or self._edit_protect\n        self.update_element_states(data_key, disable)\n\n    self.update_actions(target_data_key)\n\n    if edit_protect_only:\n        return\n\n    self.update_fields(target_data_key, omit_elements)\n\n    self.update_selectors(target_data_key, omit_elements)\n\n    # Run callbacks\n    if \"update_elements\" in self.callbacks:\n        # Running user update function\n        logger.info(\"Running the update_elements callback...\")\n        self.callbacks[\"update_elements\"](self, self.window)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.update_actions","title":"<code>update_actions(target_data_key=None)</code>","text":"<p>Update state for action-buttons.</p> <p>Parameters:</p> Name Type Description Default <code>target_data_key</code> <code>str</code> <p>(optional) dataset key to update elements for, otherwise updates elements for all datasets</p> <code>None</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update_actions(self, target_data_key: str = None) -&gt; None:\n\"\"\"Update state for action-buttons.\n\n    Args:\n        target_data_key: (optional) dataset key to update elements for, otherwise\n            updates elements for all datasets\n    \"\"\"\n    win = self.window\n    for data_key in self.datasets:\n        if target_data_key is not None and data_key != target_data_key:\n            continue\n\n        # call row_count @property once\n        row_count = self[data_key].row_count\n\n        for m in (m for m in self.event_map if m[\"table\"] == self[data_key].table):\n            # Disable delete and mapped elements for this table if there are no\n            # records in this table or edit protect mode\n            if \":table_delete\" in m[\"event\"]:\n                disable = not row_count or self._edit_protect\n                win[m[\"event\"]].update(disabled=disable)\n\n            # Disable duplicate if no rows, edit protect, or current row virtual\n            elif \":table_duplicate\" in m[\"event\"]:\n                disable = bool(\n                    not row_count\n                    or self._edit_protect\n                    or self[data_key].pk_is_virtual()\n                )\n                win[m[\"event\"]].update(disabled=disable)\n\n            # Disable first/prev if only 1 row, or first row\n            elif \":table_first\" in m[\"event\"] or \":table_previous\" in m[\"event\"]:\n                disable = row_count &lt; 2 or self[data_key].current.index == 0\n                win[m[\"event\"]].update(disabled=disable)\n\n            # Disable next/last if only 1 row, or last row\n            elif \":table_next\" in m[\"event\"] or \":table_last\" in m[\"event\"]:\n                disable = row_count &lt; 2 or (\n                    self[data_key].current.index == row_count - 1\n                )\n                win[m[\"event\"]].update(disabled=disable)\n\n            # Disable insert on children with no parent/virtual parent records or\n            # edit protect mode\n            elif \":table_insert\" in m[\"event\"]:\n                parent = self.relationships.get_parent(data_key)\n                if parent is not None:\n                    disable = bool(\n                        not self[parent].row_count\n                        or self._edit_protect\n                        or self.relationships.is_parent_virtual(\n                            self[data_key].table, self\n                        )\n                    )\n                else:\n                    disable = self._edit_protect\n                win[m[\"event\"]].update(disabled=disable)\n\n            # Disable db_save when needed\n            elif \":db_save\" in m[\"event\"] or \":save_table\" in m[\"event\"]:\n                disable = not row_count or self._edit_protect\n                win[m[\"event\"]].update(disabled=disable)\n\n            # Enable/Disable quick edit buttons\n            elif \":quick_edit\" in m[\"event\"]:\n                win[m[\"event\"]].update(disabled=disable)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.update_fields","title":"<code>update_fields(target_data_key=None, omit_elements=None, columns=None, combo_values_only=False)</code>","text":"<p>Updated the field elements to reflect their rows DataFrame for this Form instance only.</p> <p>Parameters:</p> Name Type Description Default <code>target_data_key</code> <code>str</code> <p>(optional) dataset key to update elements for, otherwise updates elements for all datasets</p> <code>None</code> <code>omit_elements</code> <code>List[str]</code> <p>A list of elements to omit updating</p> <code>None</code> <code>columns</code> <code>List[str]</code> <p>A list of column names to update</p> <code>None</code> <code>combo_values_only</code> <code>bool</code> <p>Updates the value list only for comboboxes.</p> <code>False</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update_fields(\n    self,\n    target_data_key: str = None,\n    omit_elements: List[str] = None,\n    columns: List[str] = None,\n    combo_values_only: bool = False,\n) -&gt; None:\n\"\"\"Updated the field elements to reflect their `rows` DataFrame for this `Form`\n    instance only.\n\n    Args:\n        target_data_key: (optional) dataset key to update elements for, otherwise\n            updates elements for all datasets\n        omit_elements: A list of elements to omit updating\n        columns: A list of column names to update\n        combo_values_only: Updates the value list only for comboboxes.\n    \"\"\"\n    if omit_elements is None:\n        omit_elements = []\n\n    if columns is None:\n        columns = []\n\n    # Render GUI Elements\n    # d= dictionary (the element map dictionary)\n    for mapped in self.element_map:\n        # If the optional target_data_key parameter was passed, we will only update\n        # elements bound to that table\n        if (\n            target_data_key is not None\n            and mapped.table != self[target_data_key].table\n        ):\n            continue\n\n        # skip updating this element if requested\n        if mapped.element in omit_elements:\n            continue\n\n        if combo_values_only and not isinstance(mapped.element, sg.Combo):\n            continue\n\n        if len(columns) and mapped.column not in columns:\n            continue\n\n        # Update Markers\n        # --------------------------------------------------------------------------\n        # Show the Required Record marker if the column has notnull set and\n        # this is a virtual row\n        marker_key = mapped.element.key + \":marker\"\n        try:\n            if mapped.dataset.pk_is_virtual():\n                # get the column name from the key\n                col = mapped.column\n                # get notnull from the column info\n                if (\n                    col in mapped.dataset.column_info.names\n                    and mapped.dataset.column_info[col].notnull\n                ):\n                    self.window[marker_key].update(\n                        visible=True,\n                        text_color=themepack.marker_required_color,\n                    )\n            else:\n                self.window[marker_key].update(visible=False)\n                if self.window is not None:\n                    self.window[marker_key].update(visible=False)\n        except AttributeError:\n            self.window[marker_key].update(visible=False)\n\n        updated_val = None\n        # If there is a callback for this element, use it\n        if mapped.element.key in self.callbacks:\n            self.callbacks[mapped.element.key]()\n\n        if mapped.where_column is not None:\n            # We are looking for a key,value pair or similar.\n            # Sift through and see what to put\n            updated_val = mapped.dataset.get_keyed_value(\n                mapped.column, mapped.where_column, mapped.where_value\n            )\n            # TODO, may need to add more??\n            if isinstance(mapped.element, sg.Checkbox):\n                updated_val = checkbox_to_bool(updated_val)\n\n        elif isinstance(mapped.element, sg.Combo):\n            # Update elements with foreign dataset first\n            # This will basically only be things like comboboxes\n            # Find the relationship to determine which table to get data from\n            combo_vals = mapped.dataset.combobox_values(mapped.column)\n            if not combo_vals:\n                logger.info(\n                    f\"Error! Could not find related data for element \"\n                    f\"{mapped.element.key} bound to DataSet \"\n                    f\"key {mapped.table}, column: {mapped.column}\"\n                )\n                # we don't want to update the list in this case, as it was most\n                # likely supplied and not tied to data\n                updated_val = mapped.dataset[mapped.column]\n                mapped.element.update(updated_val)\n                continue\n\n            # else, first...\n            # set to currently selected pk in gui\n            if combo_values_only:\n                match_val = mapped.element.get().get_pk()\n            # or set to what is saved in current row\n            else:\n                match_val = mapped.dataset[mapped.column]\n\n            # grab first matching entry (value)\n            updated_val = next(\n                (entry for entry in combo_vals if entry.get_pk() == match_val),\n                None,\n            )\n            # and update element\n            mapped.element.update(values=combo_vals)\n\n        elif isinstance(mapped.element, sg.Text):\n            rels = self.relationships.get_rels_for(mapped.dataset.table)\n            found = False\n            # try to get description of linked if foreign-key\n            for rel in rels:\n                if mapped.column == rel.fk_column:\n                    updated_val = mapped.dataset.frm[\n                        rel.parent_table\n                    ].get_description_for_pk(mapped.dataset[mapped.column])\n                    found = True\n                    break\n            if not found:\n                updated_val = mapped.dataset[mapped.column]\n            mapped.element.update(\"\")\n\n        elif isinstance(mapped.element, sg.Table):\n            # Tables use an array of arrays for values.  Note that the headings\n            # can't be changed.\n            values = mapped.dataset.table_values()\n            # Select the current one\n            pk = mapped.dataset.current.pk\n\n            if len(values):  # noqa SIM108\n                # set index to pk\n                index = [[v[0] for v in values].index(pk)]\n            else:  # if empty\n                index = []\n\n            # Update table, and set vertical scroll bar to follow selected element\n            update_table_element(self.window, mapped.element, values, index)\n            continue\n\n        elif isinstance(mapped.element, (sg.Input, sg.Multiline)):\n            # Update the element in the GUI\n            # For text objects, lets clear it first...\n\n            # HACK for sqlite query not making needed keys! This will clear\n            mapped.element.update(\"\")\n\n            updated_val = mapped.dataset[mapped.column]\n\n        elif isinstance(mapped.element, sg.Checkbox):\n            updated_val = checkbox_to_bool(mapped.dataset[mapped.column])\n\n        elif isinstance(mapped.element, sg.Image):\n            val = mapped.dataset[mapped.column]\n\n            try:\n                val = eval(val)\n            except:  # noqa: E722\n                # treat it as a filename\n                mapped.element.update(val)\n            else:\n                # update the bytes data\n                mapped.element.update(data=val)\n            # Prevent the update from triggering below, since we are doing it here\n            updated_val = None\n        else:\n            sg.popup(f\"Unknown element type {type(mapped.element)}\")\n\n        # Finally, we will update the actual GUI element!\n        if updated_val is not None:\n            mapped.element.update(updated_val)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.update_selectors","title":"<code>update_selectors(target_data_key=None, omit_elements=None, search_filter_only=False)</code>","text":"<p>Updated the selector elements to reflect their rows DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>target_data_key</code> <code>str</code> <p>(optional) dataset key to update elements for, otherwise updates elements for all datasets.</p> <code>None</code> <code>omit_elements</code> <code>List[str]</code> <p>A list of elements to omit updating</p> <code>None</code> <code>search_filter_only</code> <code>bool</code> <p>Only update Table elements that have enabled apply_search_filter.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update_selectors(\n    self,\n    target_data_key: str = None,\n    omit_elements: List[str] = None,\n    search_filter_only: bool = False,\n) -&gt; None:\n\"\"\"Updated the selector elements to reflect their `rows` DataFrame.\n\n    Args:\n        target_data_key: (optional) dataset key to update elements for, otherwise\n            updates elements for all datasets.\n        omit_elements: A list of elements to omit updating\n        search_filter_only: Only update Table elements that have enabled\n            `TableBuilder.apply_search_filter`.\n\n    Returns:\n        None\n    \"\"\"\n    if omit_elements is None:\n        omit_elements = []\n\n    # ---------\n    # SELECTORS\n    # ---------\n    # We can update the selector elements\n    # We do it down here because it's not a mapped element...\n    # Check for selector events\n    for data_key, dataset in self.datasets.items():\n        if target_data_key is not None and target_data_key != data_key:\n            continue\n\n        if len(dataset.selector):\n            for e in dataset.selector:\n                logger.debug(\"update_elements: SELECTOR FOUND\")\n                # skip updating this element if requested\n                if e[\"element\"] in omit_elements:\n                    continue\n\n                element: sg.Element = e[\"element\"]\n                logger.debug(f\"{type(element)}\")\n                pk_column = dataset.pk_column\n                description_column = dataset.description_column\n                if element.key in self.callbacks:\n                    self.callbacks[element.key]()\n\n                if isinstance(element, (sg.Listbox, sg.Combo)):\n                    logger.debug(\"update_elements: List/Combo selector found...\")\n                    lst = []\n                    for _, r in dataset.rows.iterrows():\n                        if e[\"where_column\"] is not None:\n                            # TODO: Kind of a hackish way to check for equality.\n                            if str(r[e[\"where_column\"]]) == str(e[\"where_value\"]):\n                                lst.append(\n                                    ElementRow(r[pk_column], r[description_column])\n                                )\n                            else:\n                                pass\n                        else:\n                            lst.append(\n                                ElementRow(r[pk_column], r[description_column])\n                            )\n\n                    element.update(\n                        values=lst,\n                        set_to_index=dataset.current.index,\n                    )\n\n                    # set vertical scroll bar to follow selected element\n                    # (for listboxes only)\n                    if isinstance(element, sg.Listbox):\n                        try:\n                            element.set_vscroll_position(\n                                dataset.current.index / len(lst)\n                            )\n                        except ZeroDivisionError:\n                            element.set_vscroll_position(0)\n\n                elif isinstance(element, sg.Slider):\n                    # Re-range the element depending on the number of records\n                    l = dataset.row_count  # noqa: E741\n                    element.update(value=dataset.current.index + 1, range=(1, l))\n\n                elif isinstance(element, sg.Table):\n                    logger.debug(\"update_elements: Table selector found...\")\n                    # Populate entries\n                    apply_search_filter = False\n                    columns = None  # default to all columns\n\n                    if \"TableBuilder\" in element.metadata:\n                        columns = element.metadata[\"TableBuilder\"].columns\n                        apply_search_filter = element.metadata[\n                            \"TableBuilder\"\n                        ].apply_search_filter\n\n                    # skip Tables that don't request search_filter\n                    if search_filter_only and not apply_search_filter:\n                        continue\n\n                    values = dataset.table_values(\n                        columns,\n                        mark_unsaved=True,\n                        apply_search_filter=apply_search_filter,\n                    )\n\n                    # Get the primary key to select.\n                    # Use the list above instead of getting it directly\n                    # from the table, as the data has yet to be updated\n                    pk = dataset.current.pk\n\n                    found = False\n                    if len(values):\n                        # set to index by pk\n                        try:\n                            index = [[v.pk for v in values].index(pk)]\n                            found = True\n                        except ValueError:\n                            index = []\n                    else:  # if empty\n                        index = []\n\n                    logger.debug(f\"Selector:: index:{index} found:{found}\")\n\n                    # Update table, and set vertical scroll bar to follow\n                    update_table_element(self.window, element, values, index)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.requery_all","title":"<code>requery_all(select_first=True, filtered=True, update_elements=True, requery_dependents=True)</code>","text":"<p>Requeries all DataSet objects associated with this Form. This effectively re-loads the data from the database into DataSet objects.</p> <p>Parameters:</p> Name Type Description Default <code>select_first</code> <code>bool</code> <p>passed to requery() -&gt; first(). If True, the first record will be selected after the requery</p> <code>True</code> <code>filtered</code> <code>bool</code> <p>passed to requery(). If True, the relationships will be considered and an appropriate WHERE clause will be generated. False will display all records from the table.</p> <code>True</code> <code>update_elements</code> <code>bool</code> <p>passed to requery() -&gt; first() to update_elements(). Note that the select_first parameter must = True to use this parameter.</p> <code>True</code> <code>requery_dependents</code> <code>bool</code> <p>passed to requery() -&gt; first() to requery_dependents(). Note that the select_first parameter must = True to use this parameter.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def requery_all(\n    self,\n    select_first: bool = True,\n    filtered: bool = True,\n    update_elements: bool = True,\n    requery_dependents: bool = True,\n) -&gt; None:\n\"\"\"Requeries all `DataSet` objects associated with this `Form`. This effectively\n    re-loads the data from the database into `DataSet` objects.\n\n    Args:\n        select_first: passed to `DataSet.requery()` -&gt; `DataSet.first()`. If True,\n            the first record will be selected after the requery\n        filtered: passed to `DataSet.requery()`. If True, the relationships will be\n            considered and an appropriate WHERE clause will be generated. False will\n            display all records from the table.\n        update_elements: passed to `DataSet.requery()` -&gt; `DataSet.first()` to\n            `Form.update_elements()`. Note that the select_first parameter must =\n            True to use this parameter.\n        requery_dependents: passed to `DataSet.requery()` -&gt; `DataSet.first()` to\n            `Form.requery_dependents()`. Note that the select_first parameter must =\n            True to use this parameter.\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(\"Requerying all datasets\")\n\n    # first let datasets requery through cascade\n    for data_key in self.datasets:\n        if self.relationships.get_parent(data_key) is None:\n            self[data_key].requery(\n                select_first=select_first,\n                filtered=filtered,\n                update_elements=update_elements,\n                requery_dependents=requery_dependents,\n            )\n\n    # fill in any datasets that are empty\n    for data_key in self.datasets:\n        if self[data_key].rows.columns.empty:\n            self[data_key].rows = Result.set(\n                pd.DataFrame(columns=self[data_key].column_info.names)\n            )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.process_events","title":"<code>process_events(event, values)</code>","text":"<p>Process mapped events for this specific Form instance.</p> <p>Not to be confused with the main process_events(), which processes events for ALL Form instances. This should be called once per iteration in your event loop. Note: Events handled are responsible for requerying and updating elements as needed.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event returned by PySimpleGUI.read()</p> required <code>values</code> <code>list</code> <p>the values returned by PySimpleGUI.read()</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if an event was handled, False otherwise</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def process_events(self, event: str, values: list) -&gt; bool:\n\"\"\"Process mapped events for this specific `Form` instance.\n\n    Not to be confused with the main `process_events()`, which processes events for\n    ALL `Form` instances. This should be called once per iteration in your event\n    loop. Note: Events handled are responsible for requerying and updating elements\n    as needed.\n\n    Args:\n        event: The event returned by PySimpleGUI.read()\n        values: the values returned by PySimpleGUI.read()\n\n    Returns:\n        True if an event was handled, False otherwise\n    \"\"\"\n    if self.window is None:\n        logger.info(\n            \"***** Form appears to be unbound. \"\n            \"Do you have frm.bind(win) in your code? *****\"\n        )\n        return False\n    if event:\n        for e in self.event_map:\n            if e[\"event\"] == event:\n                logger.debug(f\"Executing event {event} via event mapping.\")\n                e[\"function\"]()\n                logger.debug(\"Done processing event!\")\n                return True\n\n        # Check for  selector events\n        for _data_key, dataset in self.datasets.items():\n            if len(dataset.selector):\n                for e in dataset.selector:\n                    element: sg.Element = e[\"element\"]\n                    if element.key == event and len(dataset.rows) &gt; 0:\n                        changed = False  # assume that a change will not take place\n                        if isinstance(element, sg.Listbox):\n                            row = values[element.Key][0]\n                            dataset.set_by_pk(row.get_pk())\n                            changed = True\n                        elif isinstance(element, sg.Slider):\n                            dataset.set_by_index(int(values[event]) - 1)\n                            changed = True\n                        elif isinstance(element, sg.Combo):\n                            row = values[event]\n                            dataset.set_by_pk(row.get_pk())\n                            changed = True\n                        elif isinstance(element, sg.Table) and len(values[event]):\n                            if isinstance(element, LazyTable):\n                                pk = int(values[event])\n                            else:\n                                index = values[event][0]\n                                pk = self.window[event].Values[index].pk\n                            # no need to update the selector!\n                            dataset.set_by_pk(pk, True, omit_elements=[element])\n\n                            changed = True\n                        if changed and \"record_changed\" in dataset.callbacks:\n                            dataset.callbacks[\"record_changed\"](self, self.window)\n                        return changed\n    return False\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.update_element_states","title":"<code>update_element_states(table, disable=None, visible=None)</code>","text":"<p>Disable/enable and/or show/hide all elements associated with a table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>table name associated with elements to disable/enable</p> required <code>disable</code> <code>bool</code> <p>True/False to disable/enable element(s), None for no change</p> <code>None</code> <code>visible</code> <code>bool</code> <p>True/False to make elements visible or not, None for no change</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update_element_states(\n    self, table: str, disable: bool = None, visible: bool = None\n) -&gt; None:\n\"\"\"Disable/enable and/or show/hide all elements associated with a table.\n\n    Args:\n        table: table name associated with elements to disable/enable\n        disable: True/False to disable/enable element(s), None for no change\n        visible: True/False to make elements visible or not, None for no change\n\n    Returns:\n        None\n    \"\"\"\n    for mapped in self.element_map:\n        if mapped.table != table:\n            continue\n        element = mapped.element\n        if isinstance(element, (sg.Input, sg.Multiline, sg.Combo, sg.Checkbox)):\n            # if element.Key in self.window.key_dict.keys():\n            logger.debug(\n                f\"Updating element {element.Key} to disabled: \"\n                f\"{disable}, visible: {visible}\"\n            )\n            if disable is not None:\n                element.update(disabled=disable)\n            if visible is not None:\n                element.update(visible=visible)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Form.purge_instance","title":"<code>purge_instance(frm)</code>  <code>classmethod</code>","text":"<p>Remove self from Form.instances.</p> <p>Parameters:</p> Name Type Description Default <code>frm</code> <code>Form</code> <p>the Form to purge</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>@classmethod\ndef purge_instance(cls, frm: Form) -&gt; None:\n\"\"\"Remove self from Form.instances.\n\n    Args:\n        frm: the `Form` to purge\n\n    Returns:\n        None\n    \"\"\"\n    cls.instances = [i for i in cls.instances if i != frm]\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Utility","title":"<code>Utility</code>","text":"<p>Utility functions are a collection of functions and classes that directly improve on aspects of the pysimplesql module.</p> <p>See the documentation for the following utility functions: process_events(), update_elements(), bind(), simple_transform(), KeyGen(),</p> <p>Note: This is a dummy class that exists purely to enhance documentation and has no use to the end user.</p>"},{"location":"#pysimplesql.pysimplesql.Popup","title":"<code>Popup(window=None)</code>","text":"<p>Popup helper class.</p> <p>Has popup functions for internal use. Stores last info popup as last_info</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, window: sg.Window = None) -&gt; None:\n\"\"\"Create a new Popup instance :returns: None.\"\"\"\n    self.window = window\n    self.popup_info = None\n    self.last_info_msg: str = \"\"\n    self.last_info_time = None\n    self.info_elements = []\n    self._timeout_id = None\n    self._window_kwargs = {\n        \"keep_on_top\": True,\n        \"element_justification\": \"center\",\n        \"enable_close_attempted_event\": True,\n        \"icon\": themepack.icon,\n        \"ttk_theme\": themepack.ttk_theme,\n        \"finalize\": True,\n    }\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Popup.ok","title":"<code>ok(title, msg)</code>","text":"<p>Internal use only.</p> <p>Creates sg.Window with LanguagePack OK button</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def ok(self, title, msg) -&gt; None:\n\"\"\"Internal use only.\n\n    Creates sg.Window with LanguagePack OK button\n    \"\"\"\n    msg_lines = msg.splitlines()\n    layout = [[sg.Text(line, font=\"bold\")] for line in msg_lines]\n    layout.append(\n        sg.Button(\n            button_text=lang.button_ok,\n            key=\"ok\",\n            use_ttk_buttons=themepack.use_ttk_buttons,\n            pad=themepack.popup_button_pad,\n        )\n    )\n    popup_win = sg.Window(title, layout=[layout], modal=True, **self._window_kwargs)\n\n    while True:\n        event, values = popup_win.read()\n        if event in [\"ok\", \"-WINDOW CLOSE ATTEMPTED-\"]:\n            break\n    popup_win.close()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Popup.yes_no","title":"<code>yes_no(title, msg)</code>","text":"<p>Internal use only.</p> <p>Creates sg.Window with LanguagePack Yes/No button</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def yes_no(self, title, msg):\n\"\"\"Internal use only.\n\n    Creates sg.Window with LanguagePack Yes/No button\n    \"\"\"\n    msg_lines = msg.splitlines()\n    layout = [[sg.Text(line, font=\"bold\")] for line in msg_lines]\n    layout.append(\n        sg.Button(\n            button_text=lang.button_yes,\n            key=\"yes\",\n            use_ttk_buttons=themepack.use_ttk_buttons,\n            pad=themepack.popup_button_pad,\n        )\n    )\n    layout.append(\n        sg.Button(\n            button_text=lang.button_no,\n            key=\"no\",\n            use_ttk_buttons=themepack.use_ttk_buttons,\n            pad=themepack.popup_button_pad,\n        )\n    )\n    popup_win = sg.Window(title, layout=[layout], modal=True, **self._window_kwargs)\n\n    while True:\n        event, values = popup_win.read()\n        if event in [\"no\", \"yes\", \"-WINDOW CLOSE ATTEMPTED-\"]:\n            result = event\n            break\n    popup_win.close()\n    return result\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Popup.info","title":"<code>info(msg, display_message=True, auto_close_seconds=None)</code>","text":"<p>Displays a popup message and saves the message to self.last_info, auto- closing after x seconds. The title of the popup window is defined in lang.info_popup_title.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to display.</p> required <code>display_message</code> <code>bool</code> <p>(optional) If True (default), displays the message in the popup window. If False, only saves msg to last_info_msg.</p> <code>True</code> <code>auto_close_seconds</code> <code>int</code> <p>(optional) The number of seconds before the popup window auto-closes. If not provided, it is obtained from themepack.popup_info_auto_close_seconds.</p> <code>None</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def info(\n    self, msg: str, display_message: bool = True, auto_close_seconds: int = None\n) -&gt; None:\n\"\"\"Displays a popup message and saves the message to self.last_info, auto-\n    closing after x seconds. The title of the popup window is defined in\n    lang.info_popup_title.\n\n    Args:\n        msg: The message to display.\n        display_message: (optional) If True (default), displays the message in the\n            popup window. If False, only saves `msg` to `self.last_info_msg`.\n        auto_close_seconds: (optional) The number of seconds before the popup window\n            auto-closes. If not provided, it is obtained from\n            themepack.popup_info_auto_close_seconds.\n    \"\"\"\n    title = lang.info_popup_title\n    if auto_close_seconds is None:\n        auto_close_seconds = themepack.popup_info_auto_close_seconds\n    self.last_info_msg = msg\n    self.update_info_element()\n    if display_message:\n        msg_lines = msg.splitlines()\n        layout = [[sg.Text(line, font=\"bold\")] for line in msg_lines]\n        if self.popup_info:\n            return\n        self.popup_info = sg.Window(\n            title=title,\n            layout=layout,\n            alpha_channel=themepack.popup_info_alpha_channel,\n            **self._window_kwargs,\n        )\n        self.popup_info.TKroot.after(\n            int(auto_close_seconds * 1000), self._auto_close\n        )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Popup.update_info_element","title":"<code>update_info_element(message=None, auto_erase_seconds=None, timeout=False, erase=False)</code>","text":"<p>Update any mapped info elements.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Text message to update info elements with</p> <code>None</code> <code>auto_erase_seconds</code> <code>int</code> <p>The number of seconds before automatically erasing the information element. If None, the default value from themepack will be used.</p> <code>None</code> <code>timeout</code> <code>bool</code> <p>A boolean flag indicating whether to erase the information element. If True, and the elapsed time since the information element was last updated exceeds the auto_erase_seconds, the element will be cleared.</p> <code>False</code> <code>erase</code> <code>bool</code> <p>Default False. Erase info elements</p> <code>False</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update_info_element(\n    self,\n    message: str = None,\n    auto_erase_seconds: int = None,\n    timeout: bool = False,\n    erase: bool = False,\n) -&gt; None:\n\"\"\"Update any mapped info elements.\n\n    Args:\n        message: Text message to update info elements with\n        auto_erase_seconds: The number of seconds before automatically erasing the\n            information element. If None, the default value from themepack will be\n            used.\n        timeout: A boolean flag indicating whether to erase the information element.\n            If True, and the elapsed time since the information element was last\n            updated exceeds the auto_erase_seconds, the element will be cleared.\n        erase: Default False. Erase info elements\n    \"\"\"\n    if auto_erase_seconds is None:\n        auto_erase_seconds = themepack.info_element_auto_erase_seconds\n\n    # set the text-string to update\n    message = message or self.last_info_msg\n    if erase:\n        message = \"\"\n        if self._timeout_id:\n            self.window.TKroot.after_cancel(self._timeout_id)\n\n    elif timeout and self.last_info_time:\n        elapsed_sec = time() - self.last_info_time\n        if elapsed_sec &gt;= auto_erase_seconds:\n            message = \"\"\n\n    # update elements\n    for element in self.info_elements:\n        element.update(message)\n\n    # record time of update, and tk.after\n    if not erase and self.window:\n        self.last_info_time = time()\n        if self._timeout_id:\n            self.window.TKroot.after_cancel(self._timeout_id)\n        self._timeout_id = self.window.TKroot.after(\n            int(auto_erase_seconds * 1000),\n            lambda: self.update_info_element(timeout=True),\n        )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ProgressBar","title":"<code>ProgressBar(title, max_value=100, hide_delay=100)</code>","text":"<p>The progress bar is updated by calling the update method to update the progress in incremental steps until the close method is called</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the window</p> required <code>max_value</code> <code>int</code> <p>Maximum value of the progress bar</p> <code>100</code> <code>hide_delay</code> <code>int</code> <p>Delay in milliseconds before displaying the Window</p> <code>100</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, title: str, max_value: int = 100, hide_delay: int = 100) -&gt; None:\n\"\"\"Creates a progress bar window with a message label and a progress bar.\n\n    The progress bar is updated by calling the `ProgressBar.update` method to update\n    the progress in incremental steps until the `ProgressBar.close` method is called\n\n    Args:\n        title: Title of the window\n        max_value: Maximum value of the progress bar\n        hide_delay: Delay in milliseconds before displaying the Window\n\n    Returns:\n        None\n    \"\"\"\n    self.win = None\n    self.title = title\n    self.layout = [\n        [sg.Text(\"\", key=\"message\", size=(50, 2))],\n        [\n            sg.ProgressBar(\n                max_value,\n                orientation=\"h\",\n                size=(30, 20),\n                key=\"bar\",\n                style=themepack.ttk_theme,\n            )\n        ],\n    ]\n\n    self.max = max\n    self.hide_delay = hide_delay\n    self.start_time = time() * 1000\n    self.update_queue = queue.Queue()  # Thread safe\n    self.animate_thread = None\n    self._stop_event = threading.Event()  # Added stop event\n    self.last_phrase_time = None\n    self.phrase_index = 0\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ProgressBar.update","title":"<code>update(message, current_count)</code>","text":"<p>Updates the progress bar with the current progress message and value.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to display</p> required <code>current_count</code> <code>int</code> <p>Current value of the progress bar</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update(self, message: str, current_count: int) -&gt; None:\n\"\"\"Updates the progress bar with the current progress message and value.\n\n    Args:\n        message: Message to display\n        current_count: Current value of the progress bar\n\n    Returns:\n        None\n    \"\"\"\n    if time() * 1000 - self.start_time &lt; self.hide_delay:\n        return\n\n    if self.win is None:\n        self._create_window()\n\n    self.win[\"message\"].update(message)\n    self.win[\"bar\"].update(current_count=current_count)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ProgressBar.close","title":"<code>close()</code>","text":"<p>Closes the progress bar window.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Closes the progress bar window.\n\n    Returns:\n        None\n    \"\"\"\n    if self.win is not None:\n        self.win.close()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ProgressAnimate","title":"<code>ProgressAnimate(title, config=None)</code>","text":"<p>The progress bar will animate indefinitely, until the process passed in to the run method finishes.</p> <p>The config for the animated progress bar contains oscillators for the bar divider and colors, a list of phrases to be displayed, and the number of seconds to elapse between phrases.  This is all specified in the config dict as follows: my_oscillators = {     # oscillators for the bar divider and colors     \"bar\": {\"value_start\": 0, \"value_range\": 100, \"period\": 3, \"offset\": 0},     \"red\": {\"value_start\": 0, \"value_range\": 255, \"period\": 2, \"offset\": 0},     \"green\": {\"value_start\": 0, \"value_range\": 255, \"period\": 3, \"offset\": 120},     \"blue\": {\"value_start\": 0, \"value_range\": 255, \"period\": 4, \"offset\": 240},</p> <pre><code># phrases to display and the number of seconds to elapse between phrases\n\"phrases\": [\n    \"Loading...\", \"Please be patient...\", \"This may take a while...\",\n    \"Almost done...\", \"Almost there...\", \"Just a little longer...\",\n    \"Please wait...\", \"Still working...\",\n],\n\"phrase_delay\": 2\n</code></pre> <p>} Defaults are used for any keys that are not specified in the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the window</p> required <code>config</code> <code>dict</code> <p>Dictionary of configuration options as listed above</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, title: str, config: dict = None) -&gt; None:\n\"\"\"Creates an animated progress bar with a message label.\n\n    The progress bar will animate indefinitely, until the process passed in to the\n    `ProgressAnimate.run` method finishes.\n\n    The config for the animated progress bar contains oscillators for the bar\n    divider and colors, a list of phrases to be displayed, and the number of seconds\n    to elapse between phrases.  This is all specified in the config dict\n    as follows:\n    my_oscillators = {\n        # oscillators for the bar divider and colors\n        \"bar\": {\"value_start\": 0, \"value_range\": 100, \"period\": 3, \"offset\": 0},\n        \"red\": {\"value_start\": 0, \"value_range\": 255, \"period\": 2, \"offset\": 0},\n        \"green\": {\"value_start\": 0, \"value_range\": 255, \"period\": 3, \"offset\": 120},\n        \"blue\": {\"value_start\": 0, \"value_range\": 255, \"period\": 4, \"offset\": 240},\n\n        # phrases to display and the number of seconds to elapse between phrases\n        \"phrases\": [\n            \"Loading...\", \"Please be patient...\", \"This may take a while...\",\n            \"Almost done...\", \"Almost there...\", \"Just a little longer...\",\n            \"Please wait...\", \"Still working...\",\n        ],\n        \"phrase_delay\": 2\n    }\n    Defaults are used for any keys that are not specified in the dictionary.\n\n    Args:\n        title: Title of the window\n        config: Dictionary of configuration options as listed above\n\n    Returns:\n        None\n    \"\"\"\n    default_config = {\n        # oscillators for the bar divider and colors\n        \"bar\": {\"value_start\": 0, \"value_range\": 100, \"period\": 3, \"offset\": 0},\n        \"red\": {\"value_start\": 0, \"value_range\": 255, \"period\": 2, \"offset\": 0},\n        \"green\": {\"value_start\": 0, \"value_range\": 255, \"period\": 3, \"offset\": 120},\n        \"blue\": {\"value_start\": 0, \"value_range\": 255, \"period\": 4, \"offset\": 240},\n        # phrases to display and the number of seconds to elapse between phrases\n        \"phrases\": lang.animate_phrases,\n        \"phrase_delay\": 5,\n    }\n    if config is None:\n        config = {}\n\n    if type(config) is not dict:\n        raise ValueError(\"config must be a dictionary\")\n\n    if set(config.keys()) - set(default_config.keys()):\n        raise NotImplementedError(\n            f\"config may only contain keys: {default_config.keys()}\"\n        )\n\n    for k in [\"bar\", \"red\", \"green\", \"blue\"]:\n        if k in config and not all(isinstance(v, (int, float)) for v in config[k]):\n            raise ValueError(f\"values for {k} component must all be numeric\")\n        required_keys = {\"value_start\", \"value_range\", \"period\", \"offset\"}\n        if k in config and not required_keys.issubset(set(config.keys())):\n            raise ValueError(f\"{k} must contain all of {required_keys}\")\n\n    if \"phrases\" in config:\n        if type(config[\"phrases\"]) is not list:\n            raise ValueError(\"phrases must be a list\")\n        if not all(isinstance(v, str) for v in config[\"phrases\"]):\n            raise ValueError(\"phrases must be a list of strings\")\n\n    if \"phrase_delay\" in config and not all(\n        isinstance(v, (int, float)) for v in config[\"phrase_delay\"]\n    ):\n        raise ValueError(\"phrase_delay must be numeric\")\n\n    self.config = {**default_config, **config}\n\n    self.title = title\n    self.win: sg.Window = None\n    self.layout = [\n        [sg.Text(\"\", key=\"message\", size=(50, 2))],\n        [\n            sg.ProgressBar(\n                100,\n                orientation=\"h\",\n                size=(30, 20),\n                key=\"bar\",\n                style=themepack.ttk_theme,\n            )\n        ],\n    ]\n    self.last_phrase_time = None\n    self.phrase_index = 0\n    self.completed = asyncio.Event()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ProgressAnimate.run","title":"<code>run(fn, *args, **kwargs)</code>","text":"<p>Runs the function in a separate co-routine, while animating the progress bar in another.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def run(self, fn: Callable, *args, **kwargs):\n\"\"\"Runs the function in a separate co-routine, while animating the progress bar\n    in another.\n    \"\"\"\n    if not callable(fn):\n        raise ValueError(\"fn must be a callable\")\n\n    return asyncio.run(self._dispatch(fn, *args, **kwargs))\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.KeyGen","title":"<code>KeyGen(separator='!')</code>","text":"<p>The keygen system provides a mechanism to generate unique keys for use as PySimpleGUI element keys.</p> <p>This is needed because many auto-generated items will have the same name.  If for example you had two save buttons on the screen at the same time, they must have unique names.  The keygen will append a separator and an incremental number to keys that would otherwise be duplicates. A global KeyGen instance is created automatically, see keygen for info.</p> <p>Parameters:</p> Name Type Description Default <code>separator</code> <code>str</code> <p>The default separator that goes between the key and the incremental number</p> <code>'!'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, separator: str = \"!\") -&gt; None:\n\"\"\"Create a new KeyGen instance.\n\n    Args:\n        separator: The default separator that goes between the key and the\n            incremental number\n\n    Returns:\n        None\n    \"\"\"\n    self._keygen = {}\n    self._separator = separator\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.KeyGen.get","title":"<code>get(key, separator=None)</code>","text":"<p>Get a generated key from the KeyGen.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key from which to generate the new key. If the key has not been used before, then it will be returned unmodified. For each successive call with the same key, it will be appended with the separator character and an incremental number. For example, if the key 'button' was passed to get() 3 times in a row, then the keys 'button', 'button:1', and 'button:2' would be returned respectively.</p> required <code>separator</code> <code>str</code> <p>(optional) override the default separator wth this separator</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get(self, key: str, separator: str = None) -&gt; str:\n\"\"\"Get a generated key from the `KeyGen`.\n\n    Args:\n        key: The key from which to generate the new key. If the key has not been\n            used before, then it will be returned unmodified. For each successive\n            call with the same key, it will be appended with the separator character\n            and an incremental number. For example, if the key 'button' was passed\n            to `KeyGen.get()` 3 times in a row, then the keys 'button', 'button:1',\n            and 'button:2' would be returned respectively.\n        separator: (optional) override the default separator wth this separator\n\n    Returns:\n        None\n    \"\"\"\n    if separator is None:\n        separator = self._separator\n\n    # Generate a unique key by attaching a sequential integer to the end\n    if key not in self._keygen:\n        self._keygen[key] = 0\n    return_key = key\n    if self._keygen[key] &gt; 0:\n        # only modify the key if it is a duplicate!\n        return_key += f\"{separator}{self._keygen[key]!s}\"\n    logger.debug(f\"Key generated: {return_key}\")\n    self._keygen[key] += 1\n    return return_key\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.KeyGen.reset_key","title":"<code>reset_key(key)</code>","text":"<p>Reset the generation sequence for the supplied key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The base key to reset te sequence for</p> required Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def reset_key(self, key: str) -&gt; None:\n\"\"\"Reset the generation sequence for the supplied key.\n\n    Args:\n        key: The base key to reset te sequence for\n    \"\"\"\n    with contextlib.suppress(KeyError):\n        del self._keygen[key]\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.KeyGen.reset","title":"<code>reset()</code>","text":"<p>Reset the entire KeyGen and remove all keys.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Reset the entire `KeyGen` and remove all keys.\n\n    Returns:\n        None\n    \"\"\"\n    self._keygen = {}\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.KeyGen.reset_from_form","title":"<code>reset_from_form(frm)</code>","text":"<p>Reset keys from the keygen that were from mapped PySimpleGUI elements of that Form.</p> <p>Parameters:</p> Name Type Description Default <code>frm</code> <code>Form</code> <p>The Form from which to get the list of mapped elements</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def reset_from_form(self, frm: Form) -&gt; None:\n\"\"\"Reset keys from the keygen that were from mapped PySimpleGUI elements of that\n    `Form`.\n\n    Args:\n        frm: The `Form` from which to get the list of mapped elements\n\n    Returns:\n        None\n    \"\"\"\n    # reset keys related to form\n    for mapped in frm.element_map:\n        self.reset_key(mapped.element.key)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.LazyTable","title":"<code>LazyTable(*args, lazy_loading=False, **kwargs)</code>","text":"<p>             Bases: <code>Table</code></p> <p>The LazyTable is a subclass of sg.Table for improved performance by loading rows lazily during scroll events. Updating a sg.Table is generally fast, but with large DataSets that contain thousands of rows, there may be some noticeable lag. LazyTable overcomes this by only inserting a slice of rows during an update().</p> <p>To use, simply replace <code>sg.Table</code> with LazyTable as the 'element' argument in a selector() function call in your layout.</p> <p>Expects values in the form of [TableRow(pk, values)], and only becomes active after a update(values=, selected_rows=[int]) call.</p> Note <p>LazyTable does not support the <code>sg.Table.row_colors</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p><code>sg.Table</code> specific args</p> <code>()</code> <code>lazy_loading</code> <code>bool</code> <p>True to enable lazy loading</p> <code>False</code> <code>**kwargs</code> <p>Additional <code>sg.Table</code> specific kwargs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, *args, lazy_loading: bool = False, **kwargs) -&gt; None:\n\"\"\"Initilize LazyTable.\n\n    Args:\n        *args: `sg.Table` specific args\n        lazy_loading: True to enable lazy loading\n        **kwargs: Additional `sg.Table` specific kwargs.\n\n\n    Returns:\n        None\n    \"\"\"\n    # remove LazyTable only\n    self.headings_justification = kwargs.pop(\"headings_justification\", None)\n    cols_justification = kwargs.pop(\"cols_justification\", None)\n    self.frame_pack_kwargs = kwargs.pop(\"frame_pack_kwargs\", None)\n\n    super().__init__(*args, **kwargs)\n\n    # set cols_justification after, since PySimpleGUI sets it in its init\n    self.cols_justification = cols_justification\n\n    self.data = []  # lazy slice of rows\n    self.lazy_loading: bool = True\n    self.lazy_insert_qty: int = 100\n\n    self._start_index = 0\n    self._end_index = 0\n    self._start_alt_color = False\n    self._end_alt_color = False\n    self._finalized = False\n    self._lock = threading.Lock()\n    self._bg = None\n    self._fg = None\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.LazyTable.insert_qty","title":"<code>insert_qty</code>  <code>property</code>","text":"<p>Number of rows to insert during an <code>update(values=)</code> and scroll events.</p>"},{"location":"#pysimplesql.pysimplesql.LazyTable.SelectedRows","title":"<code>SelectedRows</code>  <code>property</code>","text":"<p>Returns the selected row(s) in the LazyTable.</p> <p>Returns:</p> Type Description <ul> <li>If the LazyTable has data:</li> <li>Retrieves the index of the selected row by matching the primary key   (pk) value with the first selected item in the widget.</li> <li>Returns the corresponding row from the data list based on the index.</li> </ul> <ul> <li>If the LazyTable has no data:</li> <li>Returns None.</li> </ul> <p>:note:     This property assumes that the LazyTable is using a primary key (pk) value     to uniquely identify rows in the data list.</p>"},{"location":"#pysimplesql.pysimplesql.Convenience","title":"<code>Convenience</code>","text":"<p>Convenience functions are a collection of functions and classes that aide in building PySimpleGUI layouts that conform to pysimplesql standards so that your database application is up and running quickly, and with all the great automatic functionality pysimplesql has to offer. See the documentation for the following convenience functions: field(), selector(), actions(), TableBuilder.</p> <p>Note: This is a dummy class that exists purely to enhance documentation and has no use to the end user.</p>"},{"location":"#pysimplesql.pysimplesql.TableStyler","title":"<code>TableStyler</code>  <code>dataclass</code>","text":"<p>TODO.</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder","title":"<code>TableBuilder</code>  <code>dataclass</code>","text":"<p>             Bases: <code>list</code></p> <p>This is a convenience class used to build table headings for PySimpleGUI.</p> <p>In addition, TableBuilder objects can sort columns in ascending or descending order by clicking on the column in the heading in the PySimpleGUI Table element if the sort_enable parameter is set to True.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to display in the table.</p> required <code>sort_enable</code> <code>bool</code> <p>True to enable sorting by heading column.</p> <code>True</code> <code>allow_cell_edits</code> <code>bool</code> <p>Double-click to edit a cell value if True. Accepted edits update both <code>sg.Table</code> and associated field element. Note: primary key, generated, or readonly columns don't allow cell edits.</p> <code>False</code> <code>lazy_loading</code> <code>bool</code> <p>For larger DataSets (see LazyTable).</p> <code>False</code> <code>add_save_heading_button</code> <code>bool</code> <p>Adds a save button to the left-most heading column if True.</p> <code>False</code> <code>apply_search_filter</code> <code>bool</code> <p>Filter rows to only those columns in search_order that contain search_string.</p> <code>False</code> <code>style</code> <code>TableStyler</code> <p>see TableStyler.</p> <code>field(default_factory=TableStyler)</code> <p>Returns:</p> Type Description <p>None</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.num_rows","title":"<code>num_rows: int</code>  <code>instance-attribute</code>","text":"<p>Number of rows to display in the table.</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.sort_enable","title":"<code>sort_enable: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>True to enable sorting by heading column.</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.allow_cell_edits","title":"<code>allow_cell_edits: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Double-click to edit a cell value if True. Accepted edits update both <code>sg.Table</code> and associated field element. Note: primary key, generated, or readonly columns don't allow cell edits.</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.lazy_loading","title":"<code>lazy_loading: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>For larger DataSets (see LazyTable).</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.add_save_heading_button","title":"<code>add_save_heading_button: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Adds a save button to the left-most heading column if True.</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.apply_search_filter","title":"<code>apply_search_filter: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Filter rows to only those columns in search_order that contain search_string.</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.heading_names","title":"<code>heading_names: List[str]</code>  <code>property</code>","text":"<p>Return a list of heading_names for use with the headings parameter of PySimpleGUI.Table.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>a list of heading names</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.columns","title":"<code>columns</code>  <code>property</code>","text":"<p>Return a list of column names.</p> <p>Returns:</p> Type Description <p>a list of column names</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.col_justify_map","title":"<code>col_justify_map: List[str]</code>  <code>property</code>","text":"<p>Convenience method for creating PySimpleGUI tables.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>a list column justifications for use with PySimpleGUI Table</p> <code>List[str]</code> <p>cols_justification parameter</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.heading_justify_map","title":"<code>heading_justify_map: List[str]</code>  <code>property</code>","text":"<p>Convenience method for creating PySimpleGUI tables.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>a list heading justifications for use with LazyTable headings_justification</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.heading_anchor_map","title":"<code>heading_anchor_map: List[str]</code>  <code>property</code>","text":"<p>Internal method for passing directly to treeview heading() function.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>a list heading anchors for use with treeview heading() function.</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.visible_map","title":"<code>visible_map: List[Union[bool, int]]</code>  <code>property</code>","text":"<p>Convenience method for creating PySimpleGUI tables.</p> <p>Returns:</p> Type Description <code>List[Union[bool, int]]</code> <p>a list of visible columns for use with th PySimpleGUI Table</p> <code>List[Union[bool, int]]</code> <p>visible_column_map parameter</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.width_map","title":"<code>width_map: List[int]</code>  <code>property</code>","text":"<p>Convenience method for creating PySimpleGUI tables.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>a list column widths for use with th PySimpleGUI Table col_widths parameter</p>"},{"location":"#pysimplesql.pysimplesql.TableBuilder.add_column","title":"<code>add_column(column, heading, width, col_justify='default', heading_justify='column', readonly=False, visible=True)</code>","text":"<p>Add a new heading column to this TableBuilder object.  Columns are added in the order that this method is called. Note that the primary key column does not need to be included, as primary keys are stored internally in the TableRow class.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The name of the column in the database</p> required <code>heading</code> <code>str</code> <p>The name of this columns heading (title)</p> required <code>width</code> <code>int</code> <p>The width for this column to display within the Table element</p> required <code>col_justify</code> <code>ColumnJustify</code> <p>Default 'left'. Available options: 'left', 'right', 'center', 'default'.</p> <code>'default'</code> <code>heading_justify</code> <code>HeadingJustify</code> <p>Defaults to 'column' inherity col_justify. Available options: 'left', 'right', 'center', 'column', 'default'.</p> <code>'column'</code> <code>readonly</code> <code>bool</code> <p>Indicates if the column is read-only when allow_cell_edits is True.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>True if the column is visible.  Typically, the only hidden column would be the primary key column if any. This is also useful if the rows DataFrame has information that you don't want to display.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def add_column(\n    self,\n    column: str,\n    heading: str,\n    width: int,\n    col_justify: ColumnJustify = \"default\",\n    heading_justify: HeadingJustify = \"column\",\n    readonly: bool = False,\n    visible: bool = True,\n) -&gt; None:\n\"\"\"Add a new heading column to this TableBuilder object.  Columns are added in\n    the order that this method is called. Note that the primary key column does not\n    need to be included, as primary keys are stored internally in the `TableRow`\n    class.\n\n    Args:\n        column: The name of the column in the database\n        heading: The name of this columns heading (title)\n        width: The width for this column to display within the Table element\n        col_justify: Default 'left'. Available options: 'left', 'right', 'center',\n            'default'.\n        heading_justify: Defaults to 'column' inherity `col_justify`. Available\n            options: 'left', 'right', 'center', 'column', 'default'.\n        readonly: Indicates if the column is read-only when\n            `TableBuilder.allow_cell_edits` is True.\n        visible: True if the column is visible.  Typically, the only hidden column\n            would be the primary key column if any. This is also useful if the\n            `DataSet.rows` DataFrame has information that you don't want to display.\n\n    Returns:\n        None\n    \"\"\"\n    self.append({\"heading\": heading, \"column\": column})\n    self._width_map.append(width)\n\n    # column justify\n    if col_justify == \"default\":\n        col_justify = self.style.justification\n    self._col_justify_map.append(col_justify)\n\n    # heading justify\n    if heading_justify == \"column\":\n        heading_justify = col_justify\n    if heading_justify == \"default\":\n        heading_justify = self.style.justification\n    self._heading_justify_map.append(heading_justify)\n\n    self._visible_map.append(visible)\n    if readonly:\n        self.readonly_columns.append(column)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ThemePack","title":"<code>ThemePack(tp_dict=None)</code>","text":"<p>ThemePacks are user-definable objects that allow for the look and feel of database applications built with PySimpleGUI + pysimplesql.  This includes everything from icons, the ttk themes, to sounds. Pysimplesql comes with 3 pre-made ThemePacks: default (aka ss_small), ss_large and ss_text. Creating your own is easy as well! In fact, a ThemePack can be as simple as one line if you just want to change one aspect of the default ThemePack. Example: my_tp = {'search': 'Click here to search'} # I want a different search button.</p> <p>Once a ThemePack is created, it's very easy to use.  Here is a very simple example of using a ThemePack:     ss.themepack(my_tp_dict_variable)     # make a search button, using the 'search' key from the ThemePack     sg.Button(ss.themepack.search, key='search_button')</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, tp_dict: Dict[str, str] = None) -&gt; None:\n\"\"\"Initialize the `ThemePack` class.\"\"\"\n    self.tp_dict = tp_dict or ThemePack.default\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ThemePack.default","title":"<code>default: Dict[Any] = {'ttk_theme': 'default', 'use_ttk_buttons': True, 'default_element_pad': (5, 0), 'action_button_pad': (3, 0), 'popup_button_pad': (5, 5), 'edit_protect': b'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', 'quick_edit': b'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', 'save': b'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', 'first': b'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', 'previous': b'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', 'next': b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAGz3pUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarVdZssQmDPznFDkCEovgOCCgKjfI8dMY2fPW5L1UxmWzGAuhbi3j5l9/LvcHfhwyu5ik5Jqzxy/WWLmhU/z51etJPl5PG/i7827ePS8YUwFtOENptr5hPr0+uPeg/n7eFXvDxQTdkk1g2DszOuOtkpjnM0/RBNV5OrkWeatq59OqLbxUsTvIJfoRssfu7UQUWGkkrArMM1Dw17McDcK5G+6CJ+axzoeKfgjs0HC4jwSDvDveY0D/1kDvjHz33EfrP70Pxudm8+GDLbPZCJ0vX1D62viXid9sHB6N+P0LvCmfjmP3WqOsNc/pWsywaDZGeXdbZ3+DhR0mD9dnGZfgTujLdVVcxTevAGd49R2XUiUGKstRpEGNFs2rVVKoGHmyoGVWDtdcCcKVFShRiPuixQLEBhDkoDwdoIuBH13o2rde+ykV7DwIS5kgjPDJt5f7p5e/udxauk1Evjy2gl68mQs1NnL7iVUAhJbhli4D35fB79/wZ1M1Ytk2c8EBm+9HRE/04la4cA5Yl9AeryAnwwTARNg7QRkKQMBnCokyeWEWItixAKAGzTlE7kCAUuIBJTmGHY+E4TLYG98IXWs5ceY9jdgEIFLIQYANfApgxZjAH4kFHGoppJhSyklScammlkOOOeWcJe8g1yRIlCRZRIpUaSWUWFLJRUoptbTKNSAGppqr1FJrbY1dw0YNshrWN8x07qHHnnru0kuvvSnoo1GTZhUtWrUNHmEgTIw8ZJRRR5vkJiLFjDPNPGWWWWdb4NoKK6608pJVVl3tQc1Q/XT9AjUy1PhCaq+TBzXMOpFbBO1wkjZmQIwjAXHZCIDQvDHzhWLkjdzGzFeEsZAYSqaNjRu0EQOEcRKnRQ92L+R+hJtL5Ue48b8h5zZ0/wdyDtB9xu0L1MbOc3ohdrxw29QHeB/WNC4Ot/d4/KbFvvnq9jn8qiHMXp1NsK6mvxX4tn2nUdA6d6etHBdruWabluFnbFd/jqCT26CYCODlPNPVLeRG5NP3qdYRd1/aFF2Quc6wRoQIJOIzCnUgS15iMxNbJ7iR81EilLnYjg7+pW/tI2rm6H7p8uOsdF07bBWnyZsdfNFylrYI8SuGM8LCsZiuQQXRz/ly3EEsJkepUS3reo1Ulcc5qE6JpPUMxpSqYOb5dMa6Ik677KweoWwLimlXEeldm81ucKoiSDPXBxGBZ3I9g95EB1zpGoHJ4iA9nK9WALNbjmfUqpc6TIdKM9VmX+2axSQgaY4G8mOZwzrMSs3n+9kq7LKD9AFMsduQe4R+LtdCBI/3LaqRelTPcGcVM0q7jHIrhBAfZk6mKo0soPR5RYStJzzTPScGGbvxqGQZyNS3VM7+2CxqpQNu53iOEGkKKYzjLrkIDQv+bITS1b93Mz6SwFBY4PACBNXhgjZjZNRFqvZSqM5pCJW2ue6N5w0glBtexKwzS45mqVNsUa7qYaCLUx7nPEI51PI4G8rETWDjKGyn/tLVNX86b1qtZ1nkOL15cdxevIK3wxAOE8xeo6gucWSySxgpVBvtrbQewWh02nkDurcpuSzxM5lnVYeK4Oi52eSTnbhuP0jNuCV15U/sf7wgXkxw4AVj4U1hSKCZXyaLt7cM+I30m7apYqlaMAKvyLujNUo0ixtUDlb4h5PNvhl8e2ldy+PWRcF0gxZ/IZAE/Ne0B+vPWVOF1rb/7ATXnWJWSFAso/y8CNkxeKmdERvpjoeJtFk8jDdM+GfzBOGCDHT1HfKBsAWKjIozWfxTxFT9Md3bFfy358DljSIlaMJnZp+yK72z58AZAtLgeUGhq9qmGdnOfdQ2jl0EnL7OCqlGSdKVys3ZFfvjZ3NvO9xPVf+kOfbgR/NRHHRvt+YpjG5MZUDeqgXSHM3eUPt2moISRc0Bl9fl5HGxdecZbDazzvDQqPzA6u573ftOYXDv24OLpXS4XMWufAbwPtRQFthQ6VWLnaUOltLNY0A8/RijCf5jrydCsDf/Ql7TLIH+xUNFX066jsSS88mRUaP0XfpdqQilJf6ipSd7IuMeS++69HQjbeeQJ6z3V5xsciXInYR24ppKj//gn8MySQB5GpY+7Fpo3dYB9o+53VMbvFgTjbwoEkvJxk1UVJFfwX7xXWWEevXcBoHCriT3GrhXQglhMRBfj2H1hE5UtIcCI+rtHa3EXC2w7cL5rhZgtkyoCcd3UeVQFOUjODgsqsGgiyxBMmWpB3OgIRQ+gJbKzSAOCJWH2mD5uJ2yk/uYQkp+iD7MCjxuDfs3cfvbsuY/tD8TJKizKyD+G3PleeQObj5bAAABhGlDQ1BJQ0MgcHJvZmlsZQAAeJx9kT1Iw0AcxV9TpUVaBO0gopChOlkQFXHUKhShQqgVWnUwufQLmjQkLS6OgmvBwY/FqoOLs64OroIg+AHi5Oik6CIl/i8ptIjx4Lgf7+497t4BQqPMNKtrHND0qplKxMVMdlUMvCKIPoQxDFFmljEnSUl4jq97+Ph6F+NZ3uf+HGE1ZzHAJxLPMsOsEm8QT29WDc77xBFWlFXic+Ixky5I/Mh1xeU3zgWHBZ4ZMdOpeeIIsVjoYKWDWdHUiKeIo6qmU76QcVnlvMVZK9dY6578haGcvrLMdZpDSGARS5AgQkENJZRRRYxWnRQLKdqPe/gHHb9ELoVcJTByLKACDbLjB/+D391a+ckJNykUB7pfbPtjBAjsAs26bX8f23bzBPA/A1d6219pADOfpNfbWvQI6N0GLq7bmrIHXO4AA0+GbMqO5Kcp5PPA+xl9UxbovwV61tzeWvs4fQDS1FXyBjg4BEYLlL3u8e5gZ2//nmn19wNkDXKhWfC+CAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+QIEg0gGAVRCEYAAAJuSURBVDjLnZNLSJRRFMd/95vvMc5YOr6mEYXUoIdp9LBcFFQQVItqEUEPWkRRUC0iCCOElkKhZPs2RS6K2hRpmg+CHlNK6RAKUQRGjxltmmZ05ptv5rQoH1G66A9ncTmc3z3/e89BRJgr2Heb+fIighIRAJrujiCTUTrejvEtmaLGn48rk+QR5VyoKyf6IQSaQRY4s3c9OYaglELjty7HHD4nbOKpNIMJZ3cgL0fycnMPbrei9PQPEfoGjq5z/30Cr1WFUgpgBtC7s5z66lL6YzaM/AjUrQiwOOC78WQ02hqLJwiHetmwqoKJYhOO7pgqmwEUipBIZzEADGQiLZx9PMqZ7StOL1poHiqp3si1zmG8BmDxNwAFk3aWAhdgKZIObCnz0fb6K0srA9dDX35cHf8eIxONMFva7EMyA24FuISUgNttku+1aHsX5/CmqlOFXnP/Mj1vPoBgKgGXYGc1PG4T07RY6fPwLCyU+fNulvg8fwD0GQeCLRo6AmRxlAvLstAVKKVRqGxevXzT1DUchrJ/AADsDGgigODgwmtaKAULtDSDvX0NXS0nrgBw8uS/LTjKhYaAZMhqOm6PxYIcg4Gnzy91tpxoBpJbW+7M/QaOcv3qIJMFw8BSMPDwXkNP04GLQBrA6yv6G6CUon5dLa27KjA0KPNoqUQ8afd3d13uaT7WDEzU7jtHQ/cYpGyIjs/8vsivmTb8S5Qk47J8xxEMQy8aGP5YyYvgGxiK51asIaeglPBYjECBh08D7UztkA4QjoxTHFgtjeeP09H+gGAwGAEiePxs27yH+rU10wW2bdPYd4upi6e38X/1E3nDHDifVZPbAAAAAElFTkSuQmCC', 'last': b'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', 'insert': b'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', 'delete': b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAHUHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarVhbkiQpDvznFHsEQDzEcUCA2d5gjr8OCLKqumd2xmwyOjMIgofkLlyqNuOP/07zH3x8sMGEmDmVlCw+oYTiKxpsz6fsX2fD/tUHexvf+s174dFFuNN5zFXHV/THz4S7h2vf+w3rG8+6kHsL7w+tnVe7fzUS/f70u6ALlXEaqXD+amrThUQHblP0G55Z57aezbeODJR6xEbk/SBHdv/ysYDOt+LL+EU/xlkqaBM5g5un6xIA+ebeA9B+BegbyLdlfqL/Wj/A91X76QeWSTFC47cvXPzRT28b/3Vjehb57y/8eAz/AvKcneccx7saEhBNGlEbbHeXwcAGyGlPS7gyvhHtvK+Ci221Asq7FdtwiSvOg5VpXHDdVTfd2HdxAhODHz7j7r142n1M2RcvYMlRWJebPoOxDgY9iR8G1AXyzxa39y17P3GMnbvDUO+wmMOUP73MX738J5eZUxZEzvLDCnb5FdcwYzG3fjEKhLipvMUN8L2UfvslflaoBgxbMDMcrLadJVp0n9iizTNhXMT9HCFnctcFABH2jjDGERiwyVF0ydnsfXYOODIIqrDcU/ANDLgYfYeRPhAlb7LHkcHemJPdHuujT351Q5tARKREGdzgTIGsECLiJwdGDNVIMcQYU8yRTSyxJkohxZRSTkvkaqYccswp58y55MrEgSMnzsxcuBZfCBoYSyq5cCmlVm8qNqpYq2J8RU/zjVposaWWG7fSqiB8JEiUJFlYitTuO3XIRE89d+6l1+HMgFKMMOJIIw8eZdSJWJs0w4wzzTx5llkfa8rqL9c/YM0pa34ztcblxxp6Tc53CbfkJC7OwJgPDoznxQAC2i/OLLsQ/GJucWYLZIyih5FxcWO6W4yBwjCcj9M97j7M/S3eTOS/xZv/f8yZRd2/wZwBdb/y9hvW+spzshk7p3BhagmnD5Aw4ogxzU4gJa2ujho6nHIB/xiBvboYa4ictyxSTl8BdnzmtF7JTKSQ/QQp/XGnRmecRBiIRHeeArAZclZbmQiQomVw/qhJ2GNK8alua2KC/JW47IrBAaW8m0ivfZ7lEsmg7s56kHLjBYicd0VmkmHTfteo2KFeSJhBJlX1I9Ok9syGQK+GAURhdsuDzqTRaSQAPXRxnimMUe/GFCaV8wprEPmhgBnAp74TrXDZ2CJ+aPsCIovPNfbtbysjFqHjPJcBm49dUHQzT7dF2hd/xofkU+tvtIvj0eTVbKGRl7/PBCwU6At6Ms+kkamzH3u1IBJGPs4FBCQd4HGEKg6jWi4mFwxKZ//uEf/Z6TvUWimpUz6Hjxv1rAQv137KrMFkV/aDtTHfSGG+AIsM0KyBOZgkraLmshxF+olUE/oNVRtSP4Ah4YZMN4oQ6eROuzQHPXyB1so1TRIWumCzqO3aQLrth+kqI5K9kCffLykBMCmhxo2Mf8dr7DwGANEZyO8nngFLO3s7Wbht+1zKrl2jUR73105qXE9ZZhms5ISMCaTrQInKnZBOtAQr65Cb1eIe9WyPdIO/5RUOHL/iyr9G7oPVOOFrrIWP7QV0yuFAjHpmDETrmTFamcB78BmZi4WIcSajg4MbBHfKx5162rRK1oMzaBc1JUQI9gV/WQgZOQPy8RfJn1VRbDqBHWuRFK/OrNLtszWAOmMEkd1CLnLNdtBVq47eu+t68DBx1oAM/dwPOSlZ0GzUaR/i6Ewppa9ss+PdaxBAqS9LV9ygtaznhVbpx/z6EXXpaRmkR1WpJ2jZ+HNJli3+0GRoXkjkVb7sIGr8RqW3TZjenwfmWbNGONQBEBvF4Zrt2nEaOc5CHVWpA9KVin2RPjTdrCM8D4szmjB/Y6vq8JNhVaNvOi4Q5a7HaUBqkWo4PRFGqmnvwfugK2ujsCOlEtJ5JWPsLrPCJFx9Wk7QGdEBtQwdLjzW03UDXiCH6Y4bYES2Jo+DcHi+2ZewiIdTJu2MPFTB8RDkpjt8TL4GjBcwL8nAENFO74q/Adr0QAr4kJM8ghiAppK1SGCq/BsdhV5TOmYlHI16T0nB7pp7zM44q0w5ZwYEyY1pnKp+90ZGc3rcCr800D4SbAp9DrxualdOPCxx/0Q9j/CMgq2nYGnX0rUQwkGdq/iDCX/zfkoB+7DFkUFJ+rOUwPpwJmyFRPeIV1uipibcSy8qzj6JZrck8eX3ZsuxBX9dxHPWQLdGaEfNgaJ0XB3VNF9cry+nrmpA8QIJQuUYZ3Z5NMqn3JArjbA0fbK+Gp2Cva9RUj61S9nc0Kmkm3Sp7kv+mJ8zLKy5EdnclVeEnd0M5NfVeYFRVZSg9RGOWVVd4GsfYs32pJkTAX7qJZR+HRUiqtPPyR968nm2cSFA+Lg+tEjFMSgvCUjXQxuA6ac3PK3q/Va5q7o9cYe/EQ5U1VsNxvWfTumUx5if/Av/m72RWEYWHWx/3l/Oh5EzjxSjuRV1rS8N2Rc1KX9Kj/6yykT5Xsz/AFfFmNHyuZtSAAABhGlDQ1BJQ0MgcHJvZmlsZQAAeJx9kT1Iw0AcxV9TpUVaBO0gopChOlkQFXHUKhShQqgVWnUwufQLmjQkLS6OgmvBwY/FqoOLs64OroIg+AHi5Oik6CIl/i8ptIjx4Lgf7+497t4BQqPMNKtrHND0qplKxMVMdlUMvCKIPoQxDFFmljEnSUl4jq97+Ph6F+NZ3uf+HGE1ZzHAJxLPMsOsEm8QT29WDc77xBFWlFXic+Ixky5I/Mh1xeU3zgWHBZ4ZMdOpeeIIsVjoYKWDWdHUiKeIo6qmU76QcVnlvMVZK9dY6578haGcvrLMdZpDSGARS5AgQkENJZRRRYxWnRQLKdqPe/gHHb9ELoVcJTByLKACDbLjB/+D391a+ckJNykUB7pfbPtjBAjsAs26bX8f23bzBPA/A1d6219pADOfpNfbWvQI6N0GLq7bmrIHXO4AA0+GbMqO5Kcp5PPA+xl9UxbovwV61tzeWvs4fQDS1FXyBjg4BEYLlL3u8e5gZ2//nmn19wNkDXKhWfC+CAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+QIEg0fGF2PInoAAAN+SURBVDjLVZPvTxN3AMafu++3d+0VmgrSnxa1lGtjDdEdSqJg3cY0zhVjpIklITF74b+x1/4Bezm3ZBkJ4BSiQxZ4IZRkQyzJkBpqZvlRSO9oWopcud61pXuxSOLz/vO8eD55mEmnE6qigAK83W7vypVKqWbg8B4+zygABRDCkhQuJJMrNUA3u91gVUWBw+eD4+bNmfCjR6/bL1+emgPohMt1DD91u/EjQKVodKrzwYPXJ65fn7GLIvRcDiwBeHru3Hw4Hu/bnZ+HPRSKRHt6Rv6WZfrEasUYgIlcjv7Q3z/SfuNGRHn2DK0nT/bBbJ4nAE89vb1dHYODfdnpaei5HMCyaOnoiH1VrTqSy8v92wCGL1yYFQcGIvKLF9CLRbAfP8IZCvWx9XoXXVtYSNXr9Tmb3x8BgIauQ/vwAa2BQOQLk+lxj82Gzmg0Io+OonpwAEIIOLcb+1tbc5upVIr5HcAUQIeuXBmxnzoVO8xkwDIMGJYF7/XC0dsLZWoKejYLptGAxe9HoVAY/3lpaWigqanGAMCEy4U/ZJnGr16dtTmdkcrGBo4qFdSLRTCyjLrJBGqxwCKK2Ne0uZ9Sqf6Y11u7t7MD5tPS4xyHN4ZBv7548TFfLg/rGxsglIIQApZhIIRC2NO0Xyffvv2+t62tdj+fBwCwx644Dk0AwPPw3r0LxjD+L6AUnNkMwvMwDAMnADQIOcbYT57/UVUqeb2znbduDecTCVBBAAFAGAaEZcFms+hobx/uEcXZhCzTMZ8PAMA8sVqRLpdp96VLI+Lt2zHl5UuoS0vgbDYIwSBMhKCRzcJECCil4IJBpDc3x39ZXR2Kulw18l21KgQ8nj/FePzbnelplBcXQQiBNRxGQVWTZcPItfl8HnZ/H7zFAq5SgScQCDuOjiK5zc0x2tLWFhYfPozknj+HmkzC1NQEIRhESdPeb71796UGgJekN2eDQZEqCnhCYJJlSJIUqVWrYdbI51fWX71KVDUNDABLIICiqqbXV1clu8t14HC5DhaTSenf3d00d+YMOEJgFUWkM5mEnMmsUEMQdGN7+5rOMPM2Seo70LT3u+l0d4vXWx7c2QEAjPl85YXl5W4zzydDfr/419pagq3VrhUBME/dbuh7ezA1N1tMFsudw1JphgpCISbLn935N6cTRUVp7Tx//pv8+vrkdrmsnT19Gv8BFBBmvuY6IW0AAAAASUVORK5CYII=', 'duplicate': b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU9TRZGKQztIcchQnSyIFnHUKhShQqgVWnUweekfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfE1cVJ0UVKvC8ptIjxwuN9nHfP4b37AKFZZZrVMwFoum1mUkkxl18V+14hIIAwokjIzDLmJCkN3/q6p16quzjP8u/7swbVgsWAgEg8ywzTJt4gnt60Dc77xBFWllXic+Jxky5I/Mh1xeM3ziWXBZ4ZMbOZeeIIsVjqYqWLWdnUiBPEMVXTKV/Ieaxy3uKsVeusfU/+wlBBX1nmOq0RpLCIJUgQoaCOCqqwEaddJ8VChs6TPv6o65fIpZCrAkaOBdSgQXb94H/we7ZWcWrSSwolgd4Xx/kYBfp2gVbDcb6PHad1AgSfgSu94681gZlP0hsdLXYEDG0DF9cdTdkDLneA4SdDNmVXCtISikXg/Yy+KQ+Eb4GBNW9u7XOcPgBZmlX6Bjg4BMZKlL3u8+7+7rn929Oe3w9rHnKk7x4JKQAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+cCARMnD1HzB0IAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABJUlEQVQ4y6WTT2qDQBTGvxnLwFTETZfZZCu9hPdwJei2B3GThZcovUJAkx6hdXqBisxOycI/YF43VWxiTEo+eAy8gW9+35sZMMYeAWxM0zwAoEvFOSfbtvcA1piIAdhEUfTieR4451iSUgqu634BcMamaZqHoihoqqZpLtYv0WpqTFprIiLK85x836elKJP6GOKMBr7vU5ZldIuSJCEhxHY0GPBuldaaDMOg5akBqOsaYRjO7vV9j6sEZVnO9rXWBIAelk7uug5VVQHAuEopIYTA2S2cEgRBMDv9OI7/EIBzflcEblnWu1IK92gNQA2Ip2rbdsSeI5garf77DqSUx+ktfAP4TNP02XGcq9i73Q51Xb+dxRFCbA3DWPwHUsojgFfG2NMPCKbWh17KiKEAAAAASUVORK5CYII=', 'icon': b'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', 'search': 'Search', 'unsaved_column_header': '\ud83d\udcbe', 'unsaved_column_width': 3, 'marker_unsaved': '\u2731', 'marker_required': '\u2731', 'marker_required_color': 'red2', 'placeholder_color': 'grey', 'marker_sort_asc': '\u25bc', 'marker_sort_desc': '\u25b2', 'popup_info_auto_close_seconds': 1.5, 'popup_info_alpha_channel': 0.85, 'info_element_auto_erase_seconds': 5, 'live_update_typing_delay_seconds': 0.3, 'default_label_size': (15, 1), 'default_element_size': (30, 1), 'default_mline_size': (30, 7), 'use_cell_buttons': True, 'text_min_width': 80, 'combobox_min_width': 80, 'checkbox_min_width': 75, 'datepicker_min_width': 80, 'display_bool_as_checkbox': True, 'checkbox_true': '\u2611', 'checkbox_false': '\u2610', 'validate_exception_animation': lambda : shake_widget(widget)}</code>  <code>class-attribute</code>","text":"<p>Default Themepack.</p>"},{"location":"#pysimplesql.pysimplesql.ThemePack.__call__","title":"<code>__call__(tp_dict=None)</code>","text":"<p>Update the ThemePack object from tp_dict.</p> NOTE: You can add additional keys if desired <p>tp_example = {     'ttk_theme : the name of a ttk theme     'edit_protect' : either base64 image (eg b''), or string eg '', f''     'quick_edit' : either base64 image (eg b''), or string eg '', f''     'save' : either base64 image (eg b''), or string eg '', f''     'first' : either base64 image (eg b''), or string eg '', f''     'previous' : either base64 image (eg b''), or string eg '', f''     'next' : either base64 image (eg b''), or string eg '', f''     'last' : either base64 image (eg b'') or a string eg '', f''     'insert' : either base64 image (eg b''), or string eg '', f''     'delete' : either base64 image (eg b''), or string eg '', f''     'duplicate' : either base64 image (eg b''), or string eg '', f''     'search' : either base64 image (eg b''), or string eg '', f''     'marker_unsaved' : string eg '', f'',  unicode     'marker_required' : string eg '', f'',  unicode     'marker_required_color': string eg 'red', Tuple eg (255,0,0)     'marker_sort_asc': string eg '', f'',  unicode     'marker_sort_desc': string eg '', f'',  unicode }</p> <p>For Base64, you can convert a whole folder using https://github.com/PySimpleGUI/PySimpleGUI-Base64-Encoder # fmt: skip Remember to us b'' around the string.</p> <p>Parameters:</p> Name Type Description Default <code>tp_dict</code> <code>Dict[str, str]</code> <p>(optional) A dict formatted as above to create the ThemePack from. If one is not supplied, a default ThemePack will be generated.  Any keys not present in the supplied tp_dict will be generated from the default values.  Additionally, tp_dict may contain additional keys not specified in the minimal default ThemePack.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __call__(self, tp_dict: Dict[str, str] = None) -&gt; None:\n\"\"\"Update the ThemePack object from tp_dict.\n\n    Example minimal ThemePack: NOTE: You can add additional keys if desired\n        tp_example = {\n            'ttk_theme : the name of a ttk theme\n            'edit_protect' : either base64 image (eg b''), or string eg '', f''\n            'quick_edit' : either base64 image (eg b''), or string eg '', f''\n            'save' : either base64 image (eg b''), or string eg '', f''\n            'first' : either base64 image (eg b''), or string eg '', f''\n            'previous' : either base64 image (eg b''), or string eg '', f''\n            'next' : either base64 image (eg b''), or string eg '', f''\n            'last' : either base64 image (eg b'') or a string eg '', f''\n            'insert' : either base64 image (eg b''), or string eg '', f''\n            'delete' : either base64 image (eg b''), or string eg '', f''\n            'duplicate' : either base64 image (eg b''), or string eg '', f''\n            'search' : either base64 image (eg b''), or string eg '', f''\n            'marker_unsaved' : string eg '', f'',  unicode\n            'marker_required' : string eg '', f'',  unicode\n            'marker_required_color': string eg 'red', Tuple eg (255,0,0)\n            'marker_sort_asc': string eg '', f'',  unicode\n            'marker_sort_desc': string eg '', f'',  unicode\n        }\n    For Base64, you can convert a whole folder using https://github.com/PySimpleGUI/PySimpleGUI-Base64-Encoder # fmt: skip\n    Remember to us b'' around the string.\n\n    Args:\n        tp_dict: (optional) A dict formatted as above to create the ThemePack from.\n            If one is not supplied, a default ThemePack will be generated.  Any keys\n            not present in the supplied tp_dict will be generated from the default\n            values.  Additionally, tp_dict may contain additional keys not specified\n            in the minimal default ThemePack.\n\n    Returns:\n        None\n    \"\"\"  # noqa: E501\n    # For default use cases, load the default directly to avoid the overhead\n    # of __getattr__() going through 2 key reads\n    self.tp_dict = tp_dict or ThemePack.default\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.LanguagePack","title":"<code>LanguagePack(lp_dict=None)</code>","text":"<p>LanguagePacks are user-definable collections of strings that allow for localization of strings and messages presented to the end user.</p> <p>Creating your own is easy as well! In fact, a LanguagePack can be as simple as one line if you just want to change one aspect of the default LanguagePack. Example: # I want the save popup to display this text in English in all caps     lp_en = {'save_success': 'SAVED!'}</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, lp_dict=None) -&gt; None:\n\"\"\"Initialize the `LanguagePack` class.\"\"\"\n    self.lp_dict = lp_dict or type(self).default\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.LanguagePack.default","title":"<code>default: Dict[Any] = {'button_cancel': ' Cancel ', 'button_ok': '  OK  ', 'button_yes': ' Yes ', 'button_no': '  No  ', 'description_column_str_null_default': 'New Record', 'notnull_placeholder': '*Required', 'search_placeholder': '\ud83d\udd0d Search...', 'combo_placeholder': 'Please select one:', 'duplicate_prepend': 'Copy of ', 'startup_form': 'Creating Form', 'startup_init': 'Initializing', 'startup_datasets': 'Adding datasets', 'startup_relationships': 'Adding relationships', 'startup_binding': 'Binding window to Form', 'SQLDriver_init': '{name} connection', 'SQLDriver_connecting': 'Connecting to database', 'SQLDriver_execute': 'Executing SQL commands', 'SQLDriver_file_not_found_title': 'Trouble finding db file', 'SQLDriver_file_not_found': 'Could not find file\\n{file}', 'animate_phrases': ['Please wait...', 'Still working...'], 'info_popup_title': 'Info', 'form_save_success': 'Updates saved successfully.', 'form_save_none': 'There were no updates to save.', 'dataset_save_empty': 'There were no updates to save.', 'dataset_save_none': 'There were no changes to save!', 'dataset_save_success': 'Updates saved successfully.', 'form_prompt_save_title': 'Unsaved Changes', 'form_prompt_save': 'You have unsaved changes!\\nWould you like to save them first?', 'dataset_prompt_save_title': 'Unsaved Changes', 'dataset_prompt_save': 'You have unsaved changes!\\nWould you like to save them first?', 'form_save_problem_title': 'Problem Saving', 'form_save_partial': 'Some updates were saved successfully;', 'form_save_problem': 'There was a problem saving updates to the following tables:\\n{tables}.', 'dataset_save_callback_false_title': 'Callback Prevented Save', 'dataset_save_callback_false': 'Updates not saved.', 'dataset_save_keyed_fail_title': 'Problem Saving', 'dataset_save_keyed_fail': 'Query failed: {exception}.', 'dataset_save_fail_title': 'Problem Saving', 'dataset_save_fail': 'Query failed: {exception}.', 'dataset_search_failed_title': 'Search Failed', 'dataset_search_failed': 'Failed to find:\\n{search_string}', 'delete_title': 'Confirm Deletion', 'delete_cascade': 'Are you sure you want to delete this record?\\nKeep in mind that child records:\\n({children})\\nwill also be deleted!', 'delete_single': 'Are you sure you want to delete this record?', 'delete_failed_title': 'Problem Deleting', 'delete_failed': 'Query failed: {exception}.', 'delete_recursion_limit_error': 'Delete Cascade reached max recursion limit.\\nDELETE_CASCADE_RECURSION_LIMIT', 'duplicate_child_title': 'Confirm Duplication', 'duplicate_child': 'This record has child records:\\n(in {children})\\nWhich records would you like to duplicate?', 'duplicate_child_button_dupparent': 'Only duplicate this record.', 'duplicate_child_button_dupboth': '++ Duplicate this record and its children.', 'duplicate_single_title': 'Confirm Duplication', 'duplicate_single': 'Are you sure you want to duplicate this record?', 'duplicate_failed_title': 'Problem Duplicating', 'duplicate_failed': 'Query failed: {exception}.', 'error_title': 'Error', 'quick_edit_title': 'Quick Edit - {data_key}', 'import_module_failed_title': 'Problem importing module', 'import_module_failed': 'Unable to import module neccessary for {name}\\nException: {exception}\\n\\nTry `pip install {requires}`', 'overwrite_title': 'Overwrite file?', 'overwrite': 'File exists, type YES to overwrite', 'overwrite_prompt': 'YES', 'dataset_save_validate_error_title': 'Error: Invalid Input(s)', 'dataset_save_validate_error_header': 'The following fields(s) have issues:\\n', 'dataset_save_validate_error_field': '{field}: ', ValidateRule.REQUIRED: 'Field is required', ValidateRule.PYTHON_TYPE: '{value} could not be cast to correct type, {rule}', ValidateRule.PRECISION: '{value} exceeds max precision length, {rule}', ValidateRule.MIN_VALUE: '{value} less than minimum value, {rule}', ValidateRule.MAX_VALUE: '{value} more than max value, {rule}', ValidateRule.MIN_LENGTH: '{value} less than minimum length, {rule}', ValidateRule.MAX_LENGTH: '{value} more than max length, {rule}', ValidateRule.CUSTOM: '{value}{rule}'}</code>  <code>class-attribute</code>","text":"<p>Default LanguagePack.</p>"},{"location":"#pysimplesql.pysimplesql.LanguagePack.__call__","title":"<code>__call__(lp_dict=None)</code>","text":"<p>Update the LanguagePack instance.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __call__(self, lp_dict=None) -&gt; None:\n\"\"\"Update the LanguagePack instance.\"\"\"\n    # For default use cases, load the default directly to avoid the overhead\n    # of __getattr__() going through 2 key reads\n    self.lp_dict = lp_dict or type(self).default\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.LangFormat","title":"<code>LangFormat</code>","text":"<p>             Bases: <code>dict</code></p> <p>This is a convenience class used by LanguagePack format_map calls, allowing users to not include expected variables.</p> <p>Note: This is typically not used by the end user.</p>"},{"location":"#pysimplesql.pysimplesql.Abstractions","title":"<code>Abstractions</code>","text":"<p>Supporting multiple databases in your application can quickly become very complicated and unmanageable. pysimplesql abstracts all of this complexity and presents a unified API via abstracting the main concepts of database programming. See the following documentation for a better understanding of how this is accomplished. Column, ColumnInfo, SQLDriver, Sqlite, Mysql, Postgres.</p> <p>Note: This is a dummy class that exists purely to enhance documentation and has no use to the end user.</p>"},{"location":"#pysimplesql.pysimplesql.Column","title":"<code>Column</code>  <code>dataclass</code>","text":"<p>Base ColumnClass represents a SQL column and helps casting/validating values.</p> <p>The Column class is a generic column class. It holds a dict containing the column name, type  whether the column is notnull, whether the column is a primary key and the default value, if any. Columns are typically stored in a ColumnInfo collection. There are multiple ways to get information from a Column, including subscript notation, and via properties. The available column info via these methods are name, domain, notnull, default and pk See example:</p> <p>.. literalinclude:: ../doc_examples/Column.1.py     :language: python     :caption: Example code</p>"},{"location":"#pysimplesql.pysimplesql.Column.cast","title":"<code>cast(value)</code>","text":"<p>Cast a value to the appropriate data type as defined by the column info for the column. This can be useful for comparing values between the database and the GUI.</p> <p>:param value: The value you would like to cast :returns: The value, cast to a type as defined by the domain</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def cast(self, value: Any) -&gt; Any:\n\"\"\"Cast a value to the appropriate data type as defined by the column info for\n    the column. This can be useful for comparing values between the database and the\n    GUI.\n\n    :param value: The value you would like to cast\n    :returns: The value, cast to a type as defined by the domain\n    \"\"\"\n    if self.custom_cast_fn:\n        try:\n            return self.custom_cast_fn(value)\n        except Exception as e:  # noqa: BLE001\n            logger.debug(f\"Error running custom_cast_fn, {e}\")\n    return str(value)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Column.validate","title":"<code>validate(value)</code>","text":"<p>TODO.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def validate(self, value: Any) -&gt; bool:\n\"\"\"TODO.\"\"\"\n    value = self.cast(value)\n\n    if self.notnull and value in EMPTY:\n        return ValidateResponse(ValidateRule.REQUIRED, value, self.notnull)\n\n    if value in EMPTY:\n        return ValidateResponse()\n\n    if self.custom_validate_fn:\n        try:\n            response = self.custom_validate_fn(value)\n            if response.exception:\n                return response\n        except Exception as e:  # noqa: BLE001\n            logger.debug(f\"Error running custom_validate_fn, {e}\")\n\n    if not isinstance(value, self.python_type):\n        return ValidateResponse(\n            ValidateRule.PYTHON_TYPE, value, self.python_type.__name__\n        )\n\n    return ValidateResponse()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.MinMaxCol","title":"<code>MinMaxCol</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Column</code></p> <p>Base ColumnClass for columns with minimum and maximum constraints.</p> <p>This class extends the functionality of the base Column class to include optional validation based on minimum and maximum values.</p> <p>Parameters:</p> Name Type Description Default <code>min_value</code> <code>Any valid value type compatible with the column's data type.</code> <p>The minimum allowed value for the column (inclusive). Defaults to None, indicating no minimum constraint.</p> <code>None</code> <code>max_value</code> <code>Any valid value type compatible with the column's data type.</code> <p>The maximum allowed value for the column (inclusive). Defaults to None, indicating no maximum constraint.</p> <code>None</code>"},{"location":"#pysimplesql.pysimplesql.LengthCol","title":"<code>LengthCol</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Column</code></p> <p>Base ColumnClass for length-constrained columns.</p> <p>This class represents a column with length constraints. It inherits from the base Column class and adds attributes to store the maximum and minimum length values. The validate method is overridden to include length validations.</p> <p>Parameters:</p> Name Type Description Default <code>max_length</code> <code>int</code> <p>Maximum length allowed for the column value.</p> <code>None</code> <code>min_length</code> <code>int</code> <p>Minimum length allowed for the column value.</p> <code>None</code>"},{"location":"#pysimplesql.pysimplesql.LocaleCol","title":"<code>LocaleCol</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Column</code></p> <p>Base ColumnClass that provides Locale functions.</p> <p>Parameters:</p> Name Type Description Default <code>negative_symbol</code> <code>str</code> <p>The symbol representing negative values in the locale.</p> <code>localeconv()['negative_sign']</code> <code>currency_symbol</code> <code>str</code> <p>The symbol representing the currency in the locale.</p> <code>localeconv()['currency_symbol']</code> Example <p>col = LocaleCol() normalized_value = col.strip_locale(\"$1,000.50\")</p>"},{"location":"#pysimplesql.pysimplesql.ColumnInfo","title":"<code>ColumnInfo(driver, table)</code>","text":"<p>             Bases: <code>List</code></p> <p>Custom container that behaves like a List containing a collection of Columns.</p> <p>This class is responsible for maintaining information about all the columns (Column) in a table. While the individual Column elements of this collection contain information such as default values, primary key status, SQL data type, column name, and the notnull status - this class ties them all together into a collection and adds functionality to set default values for null columns and retrieve a dict representing a table row with all defaults already assigned. See example below: .. literalinclude:: ../doc_examples/ColumnInfo.1.py     :language: python     :caption: Example code</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(self, driver: SQLDriver, table: str) -&gt; None:\n\"\"\"Initilize a ColumnInfo instance.\"\"\"\n    self.driver = driver\n    self.table = table\n\n    # Defaults to use for Null values returned from the database. These can be\n    # overwritten by the user and support function calls as well by using\n    # ColumnInfo.set_null_default() and ColumnInfo.set_null_defaults()\n    self.null_defaults = {\n        \"str\": lang.description_column_str_null_default,\n        \"int\": 0,\n        \"float\": 0.0,\n        \"Decimal\": Decimal(0),\n        \"bool\": 0,\n        \"time\": lambda: dt.datetime.now().strftime(TIME_FORMAT),\n        \"date\": lambda: dt.date.today().strftime(DATE_FORMAT),\n        \"datetime\": lambda: dt.datetime.now().strftime(DATETIME_FORMAT),\n    }\n    super().__init__()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ColumnInfo.pk_column","title":"<code>pk_column: Union[str, None]</code>  <code>property</code>","text":"<p>Get the pk_column for this colection of column_info.</p> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>A string containing the column name of the PK column, or None if one was not</p> <code>Union[str, None]</code> <p>found</p>"},{"location":"#pysimplesql.pysimplesql.ColumnInfo.names","title":"<code>names: List[str]</code>  <code>property</code>","text":"<p>Return a List of column names from the Columns in this collection.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of column names</p>"},{"location":"#pysimplesql.pysimplesql.ColumnInfo.col_name","title":"<code>col_name(idx)</code>","text":"<p>Get the column name located at the specified index in this collection of Columns.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the column to get the name from</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the column at the specified index</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def col_name(self, idx: int) -&gt; str:\n\"\"\"Get the column name located at the specified index in this collection of\n    `Column`s.\n\n    Args:\n        idx: The index of the column to get the name from\n\n    Returns:\n        The name of the column at the specified index\n    \"\"\"\n    return self[idx].name\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ColumnInfo.default_row_dict","title":"<code>default_row_dict(dataset)</code>","text":"<p>Return a dictionary of a table row with all defaults assigned.</p> <p>This is useful for inserting new records to prefill the GUI elements.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>DataSet</code> <p>a pysimplesql DataSet object</p> required <p>Returns:</p> Type Description <code>dict</code> <p>dict</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def default_row_dict(self, dataset: DataSet) -&gt; dict:\n\"\"\"Return a dictionary of a table row with all defaults assigned.\n\n    This is useful for inserting new records to prefill the GUI elements.\n\n    Args:\n        dataset: a pysimplesql DataSet object\n\n    Returns:\n        dict\n    \"\"\"\n    d = {}\n    for c in self:\n        default = c.default\n        python_type = c.python_type.__name__\n\n        # First, check to see if the default might be a database function\n        if self._looks_like_function(default):\n            table = self.driver.quote_table(self.table)\n\n            q = f\"SELECT {default} AS val FROM {table};\"\n\n            rows = self.driver.execute(q)\n            if rows.attrs[\"exception\"] is None:\n                try:\n                    default = rows.iloc[0][\"val\"]\n                except IndexError:\n                    try:\n                        default = rows.iloc[0][\"VAL\"]\n                    except IndexError:\n                        default = None\n                if default is not None:\n                    d[c.name] = default\n                    continue\n            logger.warning(\n                \"There was an exception getting the default: \"\n                f\"{rows.attrs['exception']}\"\n            )\n\n        # The stored default is a literal value, lets try to use it:\n        if default in [None, \"None\"]:\n            try:\n                null_default = self.null_defaults[python_type]\n            except KeyError:\n                # Perhaps our default dict does not yet support this datatype\n                null_default = None\n\n            # return PK_PLACEHOLDER if this is a fk_relationships.\n            # trick used in Combo for the pk to display placeholder\n            rels = self.driver.relationships.get_rels_for(dataset.table)\n            rel = next((r for r in rels if r.fk_column == c.name), None)\n            if rel:\n                null_default = PK_PLACEHOLDER\n\n            # skip primary keys\n            if not c.pk:\n                # put default in description_column\n                if c.name == dataset.description_column:\n                    default = null_default\n\n                # put defaults in other fields\n\n                #  don't put txt in other txt fields\n                elif c.python_type != str:\n                    # If our default is callable, call it.\n                    if callable(null_default):\n                        default = null_default()\n                    # Otherwise, assign it\n                    else:\n                        default = null_default\n                # string-like, not description_column\n                else:\n                    default = \"\"\n        else:\n            # Load the default that was fetched from the database\n            # during ColumnInfo creation\n            if c.python_type == str:\n                # strip quotes from default strings as they seem to get passed with\n                # some database-stored defaults\n                # strip leading and trailing quotes\n                default = c.default.strip(\"\\\"'\")\n\n        d[c.name] = default\n        logger.debug(\n            f\"Default fetched from database function. Default value is: {default}\"\n        )\n    if dataset.transform is not None:\n        dataset.transform(dataset, d, TFORM_DECODE)\n    return d\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ColumnInfo.set_null_default","title":"<code>set_null_default(python_type, value)</code>","text":"<p>Set a Null default for a single python type.</p> <p>Parameters:</p> Name Type Description Default <code>python_type</code> <code>str</code> <p>This should be equal to what calling <code>.__name__</code> on the Column python_type would equal: 'str', 'int', 'float', 'Decimal', 'bool', 'time', 'date', or 'datetime'.</p> required <code>value</code> <code>object</code> <p>The new value to set the SQL type to. This can be a literal or even a callable</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_null_default(self, python_type: str, value: object) -&gt; None:\n\"\"\"Set a Null default for a single python type.\n\n    Args:\n        python_type: This should be equal to what calling `.__name__` on the Column\n            `python_type` would equal: 'str', 'int', 'float', 'Decimal', 'bool',\n            'time', 'date', or 'datetime'.\n        value: The new value to set the SQL type to. This can be a literal or even a\n            callable\n\n    Returns:\n        None\n    \"\"\"\n    if python_type not in self._python_types:\n        RuntimeError(\n            f\"Unsupported SQL Type: {python_type}. Supported types are: \"\n            f\"{self._python_types}\"\n        )\n\n    self.null_defaults[python_type] = value\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ColumnInfo.set_null_defaults","title":"<code>set_null_defaults(null_defaults)</code>","text":"<p>Set Null defaults for all python types.</p> 'str', 'int', 'float', 'Decimal', 'bool', <p>'time', 'date', or 'datetime'.</p> <p>Parameters:</p> Name Type Description Default <code>null_defaults</code> <code>dict</code> <p>A dict of python types and default values. This can be a literal or even a callable</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def set_null_defaults(self, null_defaults: dict) -&gt; None:\n\"\"\"Set Null defaults for all python types.\n\n    Supported types: 'str', 'int', 'float', 'Decimal', 'bool',\n        'time', 'date', or 'datetime'.\n\n    Args:\n        null_defaults: A dict of python types and default values. This can be a\n            literal or even a callable\n\n    Returns:\n        None\n    \"\"\"\n    # Check if the null_defaults dict has all the required keys:\n    if not all(key in null_defaults for key in self._python_types):\n        RuntimeError(\n            f\"The supplied null_defaults dictionary does not havle all required SQL\"\n            f\" types. Required: {self._python_types}\"\n        )\n\n    self.null_defaults = null_defaults\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.ColumnInfo.get_virtual_names","title":"<code>get_virtual_names()</code>","text":"<p>Get a list of virtual column names.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A List of column names that are virtual, or [] if none are present in this</p> <code>List[str]</code> <p>collections</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def get_virtual_names(self) -&gt; List[str]:\n\"\"\"Get a list of virtual column names.\n\n    Returns:\n        A List of column names that are virtual, or [] if none are present in this\n        collections\n    \"\"\"\n    return [c.name for c in self if c.virtual]\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Result","title":"<code>Result</code>","text":"<p>This is a \"dummy\" Result object that is a convenience for constructing a DataFrame that has the expected attrs set.</p>"},{"location":"#pysimplesql.pysimplesql.Result.set","title":"<code>set(row_data=None, lastrowid=None, exception=None, column_info=None)</code>  <code>classmethod</code>","text":"<p>Create a pandas DataFrame with the row data and expected attrs set.</p> <p>Parameters:</p> Name Type Description Default <code>row_data</code> <code>dict</code> <p>A list of dicts of row data</p> <code>None</code> <code>lastrowid</code> <code>int</code> <p>The inserted row ID from the last INSERT statement</p> <code>None</code> <code>exception</code> <code>Exception</code> <p>Exceptions passed back from the SQLDriver</p> <code>None</code> <code>column_info</code> <code>ColumnInfo</code> <p>(optional) ColumnInfo object</p> <code>None</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>@classmethod\ndef set(\n    cls,\n    row_data: dict = None,\n    lastrowid: int = None,\n    exception: Exception = None,\n    column_info: ColumnInfo = None,\n):\n\"\"\"Create a pandas DataFrame with the row data and expected attrs set.\n\n    Args:\n        row_data: A list of dicts of row data\n        lastrowid: The inserted row ID from the last INSERT statement\n        exception: Exceptions passed back from the SQLDriver\n        column_info: (optional) ColumnInfo object\n    \"\"\"\n    rows = pd.DataFrame(row_data)\n    rows.attrs[\"lastrowid\"] = lastrowid\n    rows.attrs[\"exception\"] = exception\n    rows.attrs[\"column_info\"] = column_info\n    rows.attrs[\"row_backup\"] = None\n    rows.attrs[\"virtual\"] = []\n    rows.attrs[\"sort_column\"] = None\n    rows.attrs[\"sort_reverse\"] = None\n    return rows\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SqlChar","title":"<code>SqlChar</code>  <code>dataclass</code>","text":"<p>Container for passing database-specific characters.</p> <p>Each database type expects their SQL prepared in a certain way. Defaults in this dataclass are set for how various elements in the SQL string should be quoted and represented as placeholders. Override these in the derived class as needed to satisfy SQL requirements</p>"},{"location":"#pysimplesql.pysimplesql.SqlChar.placeholder","title":"<code>placeholder: str = '%s'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The placeholder for values in the query string. This is typically '?' or'%s'</p>"},{"location":"#pysimplesql.pysimplesql.SqlChar.table_quote","title":"<code>table_quote: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Character to quote table. (defaults to no quotes)</p>"},{"location":"#pysimplesql.pysimplesql.SqlChar.column_quote","title":"<code>column_quote: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chacter to quote column. (defaults to no quotes)</p>"},{"location":"#pysimplesql.pysimplesql.SqlChar.value_quote","title":"<code>value_quote: str = \"'\"</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Character to quote value. (defaults to single quotes)</p>"},{"location":"#pysimplesql.pysimplesql.SQLDriver","title":"<code>SQLDriver</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract SQLDriver class.  Derive from this class to create drivers that conform to PySimpleSQL.  This ensures that the same code will work the same way regardless of which database is used.  There are a few important things to note: The commented code below is broken into methods that MUST be implemented in the derived class, methods that.</p> <p>SHOULD be implemented in the derived class, and methods that MAY need to be implemented in the derived class for it to work as expected. Most derived drivers will at least partially work by implementing the MUST have methods.</p> <p>See the source code for Sqlite, Mysql and Postgres for examples of how to construct your own driver.</p> <p>NOTE: SQLDriver.execute() should return a pandas DataFrame.  Additionally, by pysimplesql convention, the attrs[\"lastrowid\"] should always be None unless and INSERT query is executed with SQLDriver.execute() or a record is inserted with SQLDriver.insert_record()</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host.</p> <code>None</code> <code>user</code> <code>str</code> <p>User.</p> <code>None</code> <code>password</code> <code>str</code> <p>Password.</p> <code>None</code> <code>database</code> <code>str</code> <p>Name of database.</p> <code>None</code> <code>sql_script</code> <code>str</code> <p>(optional) SQL script file to execute after opening the database.</p> <code>None</code> <code>sql_script_encoding</code> <code>str</code> <p>The encoding of the SQL script file. Defaults to 'utf-8'.</p> <code>'utf-8'</code> <code>sql_commands</code> <code>str</code> <p>(optional) SQL commands to execute after opening the database. Note: sql_commands are executed after sql_script.</p> <code>None</code> <code>update_cascade</code> <code>bool</code> <p>(optional) Default:True. Requery and filter child table on selected parent primary key. (ON UPDATE CASCADE in SQL)</p> <code>True</code> <code>delete_cascade</code> <code>bool</code> <p>(optional) Default:True. Delete the dependent child records if the parent table record is deleted. (ON UPDATE DELETE in SQL)</p> <code>True</code> <code>sql_char</code> <code>InitVar[SqlChar]</code> <p>(optional) SqlChar object, if non-default chars desired.</p> <code>SqlChar()</code>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.connect","title":"<code>connect(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Connect to a database.</p> <p>Connect to a database in the connect() method, assigning the connection to self.con.</p> <p>Implementation varies by database, you may need only one parameter, or several depending on how a connection is established with the target database.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>@abstractmethod\ndef connect(self, *args, **kwargs):\n\"\"\"Connect to a database.\n\n    Connect to a database in the connect() method, assigning the connection to\n    self.con.\n\n    Implementation varies by database, you may need only one parameter, or several\n    depending on how a connection is established with the target database.\n    \"\"\"\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.execute","title":"<code>execute(query, values=None, column_info=None, auto_commit_rollback=False)</code>  <code>abstractmethod</code>","text":"<p>Execute a query.</p> <p>Implements the native SQL implementation's execute() command.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <p>The query string to execute</p> required <code>values</code> <p>Values to pass into the query to replace the placeholders</p> <code>None</code> <code>column_info</code> <code>ColumnInfo</code> <p>An optional ColumnInfo object</p> <code>None</code> <code>auto_commit_rollback</code> <code>bool</code> <p>Automatically commit or rollback depending on whether an exception was handled. Set to False by default. Set to True to have exceptions and commit/rollbacks happen automatically</p> <code>False</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>@abstractmethod\ndef execute(\n    self,\n    query,\n    values=None,\n    column_info: ColumnInfo = None,\n    auto_commit_rollback: bool = False,\n):\n\"\"\"Execute a query.\n\n    Implements the native SQL implementation's execute() command.\n\n    Args:\n        query: The query string to execute\n        values: Values to pass into the query to replace the placeholders\n        column_info: An optional ColumnInfo object\n        auto_commit_rollback: Automatically commit or rollback depending on whether\n            an exception was handled. Set to False by default. Set to True to have\n            exceptions and commit/rollbacks happen automatically\n    \"\"\"\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.check_keyword","title":"<code>check_keyword(keyword, key=None)</code>","text":"<p>Check keyword to see if it is a reserved word.  If it is raise a ReservedKeywordError. Checks to see if the database name is in keys and uses the database name for the key if it exists, otherwise defaults to 'common' in the RESERVED set. Override this with the specific key for the database if needed for best results.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>the value to check against reserved words</p> required <code>key</code> <code>str</code> <p>The key in the RESERVED set to check in</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def check_keyword(self, keyword: str, key: str = None) -&gt; None:\n\"\"\"Check keyword to see if it is a reserved word.  If it is raise a\n    ReservedKeywordError. Checks to see if the database name is in keys and uses the\n    database name for the key if it exists, otherwise defaults to 'common' in the\n    RESERVED set. Override this with the specific key for the database if needed for\n    best results.\n\n    Args:\n        keyword: the value to check against reserved words\n        key: The key in the RESERVED set to check in\n\n    Returns:\n        None\n    \"\"\"\n    if not self.check_reserved_keywords:\n        return\n\n    if key is None:\n        # First try using the name of the driver\n        key = self.NAME.lower() if self.NAME.lower() in RESERVED else \"common\"\n\n    if keyword.upper() in RESERVED[key] or keyword.upper in RESERVED[\"common\"]:\n        raise ReservedKeywordError(\n            f\"`{keyword}` is a reserved keyword and cannot be used for table or \"\n            f\"column names.\"\n        )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.commit","title":"<code>commit()</code>","text":"<p>Commit a transaction.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def commit(self) -&gt; None:\n\"\"\"Commit a transaction.\"\"\"\n    self.con.commit()\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.generate_join_clause","title":"<code>generate_join_clause(dataset)</code>","text":"<p>Automatically generates a join clause from the Relationships that have been set.</p> <p>This typically isn't used by end users.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A join string to be used in a sqlite3 query</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def generate_join_clause(self, dataset: DataSet) -&gt; str:\n\"\"\"Automatically generates a join clause from the Relationships that have been\n    set.\n\n    This typically isn't used by end users.\n\n    Returns:\n        str: A join string to be used in a sqlite3 query\n    \"\"\"\n    join = \"\"\n    for r in self.relationships:\n        if dataset.table == r.child_table:\n            join += f\" {self.relationship_to_join_clause(r)}\"\n    return join if not dataset.join_clause else dataset.join_clause\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.generate_where_clause","title":"<code>generate_where_clause(dataset)</code>","text":"<p>Generates a where clause from the Relationships that have been set, as well as the DataSet's where clause.</p> <p>This is not typically used by end users.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A where clause string to be used in a sqlite3 query</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def generate_where_clause(self, dataset: DataSet) -&gt; str:\n\"\"\"Generates a where clause from the Relationships that have been set, as well\n    as the DataSet's where clause.\n\n    This is not typically used by end users.\n\n    Returns:\n        str: A where clause string to be used in a sqlite3 query\n    \"\"\"\n    where = \"\"\n    for r in self.relationships:\n        if dataset.table == r.child_table and r.on_update_cascade:\n            table = dataset.table\n            parent_pk = dataset.frm[r.parent_table].current.pk\n\n            # Children without cascade-filtering parent aren't displayed\n            if not parent_pk:\n                parent_pk = PK_PLACEHOLDER\n\n            clause = f\" WHERE {table}.{r.fk_column}={parent_pk!s}\"\n            if where:\n                clause = clause.replace(\"WHERE\", \"AND\")\n            where += clause\n\n    if not where:\n        # There was no where clause from Relationships..\n        where = dataset.where_clause\n    else:\n        # There was an auto-generated portion of the where clause.\n        # We will add the table's where clause to it\n        where = where + \" \" + dataset.where_clause.replace(\"WHERE\", \"AND\")\n\n    return where\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.generate_query","title":"<code>generate_query(dataset, join_clause=True, where_clause=True, order_clause=True)</code>  <code>staticmethod</code>","text":"<p>Generate a query string using the relationships that have been set.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>DataSet</code> <p>A DataSet object</p> required <code>join_clause</code> <code>bool</code> <p>True to auto-generate 'join' clause, False to not</p> <code>True</code> <code>where_clause</code> <code>bool</code> <p>True to auto-generate 'where' clause, False to not</p> <code>True</code> <code>order_clause</code> <code>bool</code> <p>True to auto-generate 'order by' clause, False to not</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>a query string for use with sqlite3</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>@staticmethod\ndef generate_query(\n    dataset: DataSet,\n    join_clause: bool = True,\n    where_clause: bool = True,\n    order_clause: bool = True,\n) -&gt; str:\n\"\"\"Generate a query string using the relationships that have been set.\n\n    Args:\n        dataset: A `DataSet` object\n        join_clause: True to auto-generate 'join' clause, False to not\n        where_clause: True to auto-generate 'where' clause, False to not\n        order_clause: True to auto-generate 'order by' clause, False to not\n\n    Returns:\n        a query string for use with sqlite3\n    \"\"\"\n    return (\n        f\"{dataset.query}\"\n        f' {dataset.join_clause if join_clause else \"\"}'\n        f' {dataset.where_clause if where_clause else \"\"}'\n        f' {dataset.order_clause if order_clause else \"\"}'\n    )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.duplicate_record","title":"<code>duplicate_record(dataset, children)</code>","text":"<p>Duplicates a record in a database table and optionally duplicates its dependent records.</p> <p>The function uses all columns found in column_info and select all except the primary key column, inserting a duplicate record with the same column values.</p> <p>If the 'children' parameter is set to 'True', the function duplicates the dependent records by setting the foreign key column of the child records to the primary key value of the newly duplicated record before inserting them.</p> <p>Note that this function assumes the primary key column is auto-incrementing and that no columns are set to unique.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>DataSet</code> <p>The DataSet of the the record to be duplicated.</p> required <code>children</code> <code>bool</code> <p>(optional) Whether to duplicate dependent records. Defaults to False.</p> required Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def duplicate_record(self, dataset: DataSet, children: bool) -&gt; pd.DataFrame:\n\"\"\"Duplicates a record in a database table and optionally duplicates its\n    dependent records.\n\n    The function uses all columns found in `DataSet.column_info` and\n    select all except the primary key column, inserting a duplicate record with the\n    same column values.\n\n    If the 'children' parameter is set to 'True', the function duplicates the\n    dependent records by setting the foreign key column of the child records to the\n    primary key value of the newly duplicated record before inserting them.\n\n    Note that this function assumes the primary key column is auto-incrementing and\n    that no columns are set to unique.\n\n    Args:\n        dataset: The `DataSet` of the the record to be duplicated.\n        children: (optional) Whether to duplicate dependent records. Defaults to\n            False.\n    \"\"\"\n    # Get variables\n    table = self.quote_table(dataset.table)\n    columns = [\n        self.quote_column(column.name)\n        for column in dataset.column_info\n        if column.name != dataset.pk_column and not column.generated\n    ]\n    columns = \", \".join(columns)\n    pk_column = dataset.pk_column\n    pk = dataset.current.pk\n\n    # Insert new record\n    res = self._insert_duplicate_record(table, columns, pk_column, pk)\n\n    if res.attrs[\"exception\"]:\n        return res\n\n    # Get pk of new record\n    new_pk = res.attrs[\"lastrowid\"]\n    # now wrap pk_column\n    pk_column = self.quote_column(dataset.pk_column)\n\n    # Set description if TEXT\n    if dataset.column_info[dataset.description_column].python_type == str:\n        description_column = self.quote_column(dataset.description_column)\n        description = (\n            f\"{lang.duplicate_prepend}{dataset.get_description_for_pk(pk)}\"\n        )\n        query = (\n            f\"UPDATE {table} \"\n            f\"SET {description_column} = {self.placeholder} \"\n            f\"WHERE {pk_column} = {new_pk};\"\n        )\n        res = self.execute(query, [description])\n        if res.attrs[\"exception\"]:\n            return res\n\n    # create list of which children we have duplicated\n    child_duplicated = []\n    # Next, duplicate the child records!\n    if children:\n        for _ in dataset.frm.datasets:\n            for r in self.relationships:\n                if (\n                    r.parent_table == dataset.table\n                    and r.on_update_cascade\n                    and (r.child_table not in child_duplicated)\n                ):\n                    child = self.quote_table(r.child_table)\n                    fk_column = self.quote_column(r.fk_column)\n\n                    # all columns except pk_column\n                    columns = [\n                        self.quote_column(column.name)\n                        for column in dataset.frm[r.child_table].column_info\n                        if column.name != dataset.frm[r.child_table].pk_column\n                        and not column.generated\n                    ]\n\n                    # replace fk_column value with pk of new parent\n                    select_columns = [\n                        str(new_pk)\n                        if column == self.quote_column(r.fk_column)\n                        else column\n                        for column in columns\n                    ]\n\n                    # prepare query &amp; execute\n                    columns = \", \".join(columns)\n                    select_columns = \", \".join(select_columns)\n                    query = (\n                        f\"INSERT INTO {child} ({columns}) \"\n                        f\"SELECT {select_columns} FROM {child} \"\n                        f\"WHERE {fk_column} = {pk};\"\n                    )\n                    res = self.execute(query)\n                    if res.attrs[\"exception\"]:\n                        return res\n\n                    child_duplicated.append(r.child_table)\n    # If we made it here, we can return the pk.\n    # Since the pk was stored earlier, we will just send an empty dataframe.\n    return Result.set(lastrowid=new_pk)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.add_relationship","title":"<code>add_relationship(join, child_table, fk_column, parent_table, pk_column, update_cascade, delete_cascade)</code>","text":"<p>Add a foreign key relationship between two dataset of the database.</p> <p>When you attach a database, PySimpleSQL isn't aware of the relationships contained until datasets are added via add_dataset, and the relationship of various tables is set with this function. Note that auto_add_relationships() will do this automatically from the schema of the database, which also happens automatically when a SQLDriver is created.</p> <p>Parameters:</p> Name Type Description Default <code>join</code> <code>str</code> <p>The join type of the relationship ('LEFT JOIN', 'INNER JOIN', 'RIGHT JOIN')</p> required <code>child_table</code> <code>str</code> <p>The child table containing the foreign key</p> required <code>fk_column</code> <code>str</code> <p>The foreign key column of the child table</p> required <code>parent_table</code> <code>str</code> <p>The parent table containing the primary key</p> required <code>pk_column</code> <code>str</code> <p>The primary key column of the parent table</p> required <code>update_cascade</code> <code>bool</code> <p>Requery and filter child table results on selected parent primary key (ON UPDATE CASCADE in SQL)</p> required <code>delete_cascade</code> <code>bool</code> <p>Delete the dependent child records if the parent table record is deleted (ON UPDATE DELETE in SQL)</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def add_relationship(\n    self,\n    join: str,\n    child_table: str,\n    fk_column: str,\n    parent_table: str,\n    pk_column: str,\n    update_cascade: bool,\n    delete_cascade: bool,\n) -&gt; None:\n\"\"\"Add a foreign key relationship between two dataset of the database.\n\n    When you attach a database, PySimpleSQL isn't aware of the relationships\n    contained until datasets are added via `Form.add_dataset`, and the relationship\n    of various tables is set with this function. Note that\n    `SQLDriver.auto_add_relationships()` will do this automatically from the schema\n    of the database, which also happens automatically when a `SQLDriver` is created.\n\n    Args:\n        join: The join type of the relationship ('LEFT JOIN', 'INNER JOIN', 'RIGHT\n            JOIN')\n        child_table: The child table containing the foreign key\n        fk_column: The foreign key column of the child table\n        parent_table: The parent table containing the primary key\n        pk_column: The primary key column of the parent table\n        update_cascade: Requery and filter child table results on selected parent\n            primary key (ON UPDATE CASCADE in SQL)\n        delete_cascade: Delete the dependent child records if the parent table\n            record is deleted (ON UPDATE DELETE in SQL)\n\n    Returns:\n        None\n    \"\"\"\n    self.relationships.append(\n        Relationship(\n            join,\n            child_table,\n            fk_column,\n            parent_table,\n            pk_column,\n            update_cascade,\n            delete_cascade,\n            self,\n        )\n    )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.auto_add_relationships","title":"<code>auto_add_relationships()</code>","text":"<p>Automatically add a foreign key relationship between tables of the database. This is done by foreign key constraints within the database.  Automatically requery the child table if the parent table changes (ON UPDATE CASCADE in sql is set) When you attach a database, PySimpleSQL isn't aware of the relationships contained until tables are added and the relationship of various tables is set. This happens automatically during SQLDriver creation. Note that add_relationship() can do this manually.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def auto_add_relationships(self) -&gt; None:\n\"\"\"Automatically add a foreign key relationship between tables of the database.\n    This is done by foreign key constraints within the database.  Automatically\n    requery the child table if the parent table changes (ON UPDATE CASCADE in sql is\n    set) When you attach a database, PySimpleSQL isn't aware of the relationships\n    contained until tables are added and the relationship of various tables is set.\n    This happens automatically during `SQLDriver` creation. Note that\n    `SQLDriver.add_relationship()` can do this manually.\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(\"Automatically adding foreign key relationships\")\n    # Clear any current rels so that successive calls will not double the entries\n    self.relationships = RelationshipStore(\n        self\n    )  # clear any relationships already stored\n    relationships = self.get_relationships()\n    for r in relationships:\n        logger.debug(\n            f'Adding relationship {r[\"from_table\"]}.{r[\"from_column\"]} = '\n            f'{r[\"to_table\"]}.{r[\"to_column\"]}'\n        )\n        self.add_relationship(\n            \"LEFT JOIN\",\n            r[\"from_table\"],\n            r[\"from_column\"],\n            r[\"to_table\"],\n            r[\"to_column\"],\n            r[\"update_cascade\"],\n            r[\"delete_cascade\"],\n        )\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.SQLDriver.check_reserved_keywords","title":"<code>check_reserved_keywords(value)</code>","text":"<p>SQLDrivers can check to make sure that field names respect their own reserved keywords.  By default, all SQLDrivers will check for their respective keywords. You can choose to disable this feature with this method.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True to check for reserved keywords in field names, false to skip this check</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def check_reserved_keywords(self, value: bool) -&gt; None:\n\"\"\"SQLDrivers can check to make sure that field names respect their own reserved\n    keywords.  By default, all SQLDrivers will check for their respective keywords.\n    You can choose to disable this feature with this method.\n\n    Args:\n        value: True to check for reserved keywords in field names, false to skip\n            this check\n\n    Returns:\n        None\n    \"\"\"\n    self._CHECK_RESERVED_KEYWORDS = value\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Sqlite","title":"<code>Sqlite(database=None, *, sql_script=None, sql_script_encoding='utf-8', sql_commands=None, update_cascade=True, delete_cascade=True, sql_char=sql_char, create_file=True, skip_sql_if_db_exists=True)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>SQLDriver</code></p> <p>The SQLite driver supports SQLite3 databases.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>Union[str, Path, Literal[':memory:'], Connection]</code> <p>Path to database file, ':memory:' in-memory database, or existing Sqlite3.Connection</p> <code>None</code> <code>sql_script</code> <p>(optional) SQL script file to execute after opening the db.</p> <code>None</code> <code>sql_script_encoding</code> <code>str</code> <p>(optional) The encoding of the SQL script file. Defaults to 'utf-8'.</p> <code>'utf-8'</code> <code>sql_commands</code> <p>(optional) SQL commands to execute after opening the database. Note: sql_commands are executed after sql_script.</p> <code>None</code> <code>update_cascade</code> <code>bool</code> <p>(optional) Default:True. Requery and filter child table on selected parent primary key. (ON UPDATE CASCADE in SQL)</p> <code>True</code> <code>delete_cascade</code> <code>bool</code> <p>(optional) Default:True. Delete the dependent child records if the parent table record is deleted. (ON UPDATE DELETE in SQL)</p> <code>True</code> <code>sql_char</code> <code>SqlChar</code> <p>(optional) SqlChar object, if non-default chars desired.</p> <code>sql_char</code> <code>create_file</code> <code>bool</code> <p>(optional) default True. Create file if it doesn't exist.</p> <code>True</code> <code>skip_sql_if_db_exists</code> <code>bool</code> <p>(optional) Skip both 'sql_file' and 'sql_commands' if database already exists.</p> <code>True</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(\n    self,\n    database: Union[\n        str,\n        Path,\n        Literal[\":memory:\"],\n        sqlite3.Connection,\n    ] = None,\n    *,\n    sql_script=None,\n    sql_script_encoding: str = \"utf-8\",\n    sql_commands=None,\n    update_cascade: bool = True,\n    delete_cascade: bool = True,\n    sql_char: SqlChar = sql_char,\n    create_file: bool = True,\n    skip_sql_if_db_exists: bool = True,\n) -&gt; None:\n\"\"\"Initilize a Sqlite instance.\n\n    Args:\n        database: Path to database file, ':memory:' in-memory database, or existing\n            Sqlite3.Connection\n        sql_script: (optional) SQL script file to execute after opening the db.\n        sql_script_encoding: (optional) The encoding of the SQL script file.\n            Defaults to 'utf-8'.\n        sql_commands: (optional) SQL commands to execute after opening the database.\n            Note: sql_commands are executed after sql_script.\n        update_cascade: (optional) Default:True. Requery and filter child table on\n            selected parent primary key. (ON UPDATE CASCADE in SQL)\n        delete_cascade: (optional) Default:True. Delete the dependent child records\n            if the parent table record is deleted. (ON UPDATE DELETE in SQL)\n        sql_char: (optional) `SqlChar` object, if non-default chars desired.\n        create_file: (optional) default True. Create file if it doesn't exist.\n        skip_sql_if_db_exists: (optional) Skip both 'sql_file' and 'sql_commands' if\n            database already exists.\n    \"\"\"\n    self._database = str(database)\n    self.sql_script = sql_script\n    self.sql_script_encoding = sql_script_encoding\n    self.sql_commands = sql_commands\n    self.update_cascade = update_cascade\n    self.delete_cascade = delete_cascade\n    self.create_file = create_file\n    self.skip_sql_if_db_exists = skip_sql_if_db_exists\n\n    super().__post_init__(sql_char)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Flatfile","title":"<code>Flatfile(file_path, delimiter=',', quotechar='\"', header_row_num=0, table=None, pk_col=None)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Sqlite</code></p> <p>The Flatfile driver adds support for flatfile databases such as CSV files to pysimplesql.</p> <p>The flatfile data is loaded into an internal SQlite database, where it can be used and manipulated like any other database file.  Each timem records are saved, the contents of the internal SQlite database are written back out to the file. This makes working with flatfile data as easy and consistent as any other database.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the flatfile</p> required <code>delimiter</code> <code>str</code> <p>The delimiter for the flatfile. Defaults to ','.  Tabs ('\\t') are another popular option</p> <code>','</code> <code>quotechar</code> <code>str</code> <p>The quoting character specified by the flatfile. Defaults to '\"'</p> <code>'\"'</code> <code>header_row_num</code> <code>int</code> <p>The row containing the header column names. Defaults to 0</p> <code>0</code> <code>table</code> <code>str</code> <p>The name to give this table in pysimplesql. Default is 'Flatfile'</p> <code>None</code> <code>pk_col</code> <code>str</code> <p>The column name that acts as a primary key for the dataset. See  below how to use this parameter: - If no pk_col parameter is supplied, then a generic primary key column   named 'pk' will be generated with AUTO INCREMENT and PRIMARY KEY set.   This is a virtual column and will not be written back out to the   flatfile. - If the pk_col parameter is supplied, and it exists in the header row,   then it will be used as the primary key for the dataset. If this   column does not exist in the header row, then a virtual primary key   column with this name will be created with AUTO INCREMENT and PRIMARY   KEY set. As above, the virtual primary key column that was created   will not be written to the flatfile.</p> <code>None</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(\n    self,\n    file_path: str,\n    delimiter: str = \",\",\n    quotechar: str = '\"',\n    header_row_num: int = 0,\n    table: str = None,\n    pk_col: str = None,\n) -&gt; None:\nr\"\"\"Create a new Flatfile driver instance.\n\n    Args:\n        file_path: The path to the flatfile\n        delimiter: The delimiter for the flatfile. Defaults to ','.  Tabs ('\\t') are\n            another popular option\n        quotechar: The quoting character specified by the flatfile. Defaults to '\"'\n        header_row_num: The row containing the header column names. Defaults to 0\n        table: The name to give this table in pysimplesql. Default is 'Flatfile'\n        pk_col: The column name that acts as a primary key for the dataset. See\n             below how to use this parameter:\n            - If no pk_col parameter is supplied, then a generic primary key column\n              named 'pk' will be generated with AUTO INCREMENT and PRIMARY KEY set.\n              This is a virtual column and will not be written back out to the\n              flatfile.\n            - If the pk_col parameter is supplied, and it exists in the header row,\n              then it will be used as the primary key for the dataset. If this\n              column does not exist in the header row, then a virtual primary key\n              column with this name will be created with AUTO INCREMENT and PRIMARY\n              KEY set. As above, the virtual primary key column that was created\n              will not be written to the flatfile.\n    \"\"\"\n    self.file_path = file_path\n    self.delimiter = delimiter\n    self.quotechar = quotechar\n    self.header_row_num = header_row_num\n    self.pk_col = pk_col if pk_col is not None else \"pk\"\n    self.pk_col_is_virtual = False\n    self.table = table if table is not None else \"Flatfile\"\n\n    # First up the SQLite driver that we derived from\n    super().__init__(\":memory:\")  # use an in-memory database\n\n    # Change Sqlite SQLDriver init set values to Flatfile-specific\n    self.NAME = \"Flatfile\"\n    self.REQUIRES = [\"csv,sqlite3\"]\n    self.placeholder = \"?\"  # update\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Mysql","title":"<code>Mysql</code>  <code>dataclass</code>","text":"<p>             Bases: <code>SQLDriver</code></p> <p>The Mysql driver supports MySQL databases.</p>"},{"location":"#pysimplesql.pysimplesql.Mysql.tinyint1_is_boolean","title":"<code>tinyint1_is_boolean: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Treat SQL column-type 'tinyint(1)' as Boolean</p> <p>MySQL does not have a true 'Boolean' column. Instead, a column is declared as 'Boolean' will be stored as 'tinyint(1)'. Setting this arg as 'True' will map the ColumnClass as a BoolCol.</p>"},{"location":"#pysimplesql.pysimplesql.Mariadb","title":"<code>Mariadb</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Mysql</code></p> <p>The Mariadb driver supports MariaDB databases.</p>"},{"location":"#pysimplesql.pysimplesql.Postgres","title":"<code>Postgres</code>  <code>dataclass</code>","text":"<p>             Bases: <code>SQLDriver</code></p> <p>The Postgres driver supports PostgreSQL databases.</p>"},{"location":"#pysimplesql.pysimplesql.Postgres.sync_sequences","title":"<code>sync_sequences: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Synchronize the sequences with the max pk for each table on database connection.</p> <p>This is useful if manual records were inserted without calling nextval() to update the sequencer.</p>"},{"location":"#pysimplesql.pysimplesql.Sqlserver","title":"<code>Sqlserver</code>  <code>dataclass</code>","text":"<p>             Bases: <code>SQLDriver</code></p> <p>The Sqlserver driver supports Microsoft SQL Server databases.</p>"},{"location":"#pysimplesql.pysimplesql.MSAccess","title":"<code>MSAccess(database_file, *, overwrite_file=False, sql_script=None, sql_script_encoding='utf-8', sql_commands=None, update_cascade=True, delete_cascade=True, sql_char=sql_char, infer_datetype_from_default_function=True, use_newer_jackcess=False)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>SQLDriver</code></p> <p>The MSAccess driver supports Microsoft Access databases. Note that only database interactions are supported, including stored Queries, but not operations dealing with Forms, Reports, etc.</p> <p>Note: Jackcess and UCanAccess libraries may not accurately report decimal places for \"Number\" or \"Currency\" columns. Manual configuration of decimal places may be required by replacing the placeholders as follows: frm[DATASET KEY].column_info[COLUMN NAME].scale = 2</p> <p>Parameters:</p> Name Type Description Default <code>database_file</code> <code>Union[str, Path]</code> <p>The path to the MS Access database file.</p> required <code>overwrite_file</code> <code>bool</code> <p>If True, prompts the user if the file already exists. If the user declines to overwrite the file, the provided SQL commands or script will not be executed.</p> <code>False</code> <code>sql_script</code> <code>str</code> <p>(optional) SQL script file to execute after opening the db.</p> <code>None</code> <code>sql_script_encoding</code> <code>str</code> <p>The encoding of the SQL script file. Defaults to 'utf-8'.</p> <code>'utf-8'</code> <code>sql_commands</code> <code>str</code> <p>(optional) SQL commands to execute after opening the database. Note: sql_commands are executed after sql_script.</p> <code>None</code> <code>update_cascade</code> <code>bool</code> <p>(optional) Default:True. Requery and filter child table on selected parent primary key. (ON UPDATE CASCADE in SQL)</p> <code>True</code> <code>delete_cascade</code> <code>bool</code> <p>(optional) Default:True. Delete the dependent child records if the parent table record is deleted. (ON UPDATE DELETE in SQL)</p> <code>True</code> <code>sql_char</code> <code>SqlChar</code> <p>(optional) SqlChar object, if non-default chars desired.</p> <code>sql_char</code> <code>infer_datetype_from_default_function</code> <code>bool</code> <p>If True, specializes a DateTime column by examining the column's default function. A DateTime column with '=Date()' will be treated as a 'DateCol', and '=Time()' will be treated as a 'TimeCol'. Defaults to True.</p> <code>True</code> <code>use_newer_jackcess</code> <code>bool</code> <p>If True, uses a newer version of the Jackcess library for improved compatibility, specifically allowing handling of 'attachment' columns. Defaults to False.</p> <code>False</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def __init__(\n    self,\n    database_file: Union[str, Path],\n    *,\n    overwrite_file: bool = False,\n    sql_script: str = None,\n    sql_script_encoding: str = \"utf-8\",\n    sql_commands: str = None,\n    update_cascade: bool = True,\n    delete_cascade: bool = True,\n    sql_char: SqlChar = sql_char,\n    infer_datetype_from_default_function: bool = True,\n    use_newer_jackcess: bool = False,\n) -&gt; None:\n\"\"\"Initialize the MSAccess class.\n\n    Args:\n        database_file: The path to the MS Access database file.\n        overwrite_file: If True, prompts the user if the file already exists. If the\n            user declines to overwrite the file, the provided SQL commands or script\n            will not be executed.\n        sql_script: (optional) SQL script file to execute after opening the db.\n        sql_script_encoding: The encoding of the SQL script file. Defaults to\n            'utf-8'.\n        sql_commands: (optional) SQL commands to execute after opening the database.\n            Note: sql_commands are executed after sql_script.\n        update_cascade: (optional) Default:True. Requery and filter child table on\n            selected parent primary key. (ON UPDATE CASCADE in SQL)\n        delete_cascade: (optional) Default:True. Delete the dependent child records\n            if the parent table record is deleted. (ON UPDATE DELETE in SQL)\n        sql_char: (optional) `SqlChar` object, if non-default chars desired.\n        infer_datetype_from_default_function: If True, specializes a DateTime column\n            by examining the column's default function. A DateTime column with\n            '=Date()' will be treated as a 'DateCol', and '=Time()' will be treated\n            as a 'TimeCol'. Defaults to True.\n        use_newer_jackcess: If True, uses a newer version of the Jackcess library\n            for improved compatibility, specifically allowing handling of\n            'attachment' columns. Defaults to False.\n    \"\"\"\n    self.database_file = str(database_file)\n    self.overwrite_file = overwrite_file\n    self.sql_script = sql_script\n    self.sql_script_encoding = sql_script_encoding\n    self.sql_commands = sql_commands\n    self.update_cascade = update_cascade\n    self.delete_cascade = delete_cascade\n    self.infer_datetype_from_default_function = infer_datetype_from_default_function\n    self.use_newer_jackcess = use_newer_jackcess\n\n    super().__post_init__(sql_char)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.Driver","title":"<code>Driver</code>","text":"<p>The Driver class allows for easy driver creation.</p> <p>It is a simple wrapper around the various SQLDriver classes.</p>"},{"location":"#pysimplesql.pysimplesql.process_events","title":"<code>process_events(event, values)</code>","text":"<p>Process mapped events for ALL Form instances.</p> <p>Not to be confused with process_events(), which processes events for individual Form instances. This should be called once per iteration in your event loop. Note: Events handled are responsible for requerying and updating elements as needed.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event returned by PySimpleGUI.read()</p> required <code>values</code> <code>list</code> <p>the values returned by PySimpleGUI.read()</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if an event was handled, False otherwise</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def process_events(event: str, values: list) -&gt; bool:\n\"\"\"Process mapped events for ALL Form instances.\n\n    Not to be confused with `Form.process_events()`, which processes events for\n    individual `Form` instances. This should be called once per iteration in your event\n    loop. Note: Events handled are responsible for requerying and updating elements as\n    needed.\n\n    Args:\n        event: The event returned by PySimpleGUI.read()\n        values: the values returned by PySimpleGUI.read()\n\n    Returns:\n        True if an event was handled, False otherwise\n    \"\"\"\n    handled = False\n    for i in Form.instances:\n        if i.process_events(event, values):\n            handled = True\n    return handled\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.update_elements","title":"<code>update_elements(data_key=None, edit_protect_only=False)</code>","text":"<p>Updated the GUI elements to reflect values from the database for ALL Form instances. Not to be confused with update_elements(), which updates GUI elements for individual Form instances.</p> <p>Parameters:</p> Name Type Description Default <code>data_key</code> <code>str</code> <p>(optional) key of DataSet to update elements for, otherwise updates elements for all datasets.</p> <code>None</code> <code>edit_protect_only</code> <code>bool</code> <p>(optional) If true, only update items affected by edit_protect.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update_elements(data_key: str = None, edit_protect_only: bool = False) -&gt; None:\n\"\"\"Updated the GUI elements to reflect values from the database for ALL Form\n    instances. Not to be confused with `Form.update_elements()`, which updates GUI\n    elements for individual `Form` instances.\n\n    Args:\n        data_key: (optional) key of `DataSet` to update elements for, otherwise updates\n            elements for all datasets.\n        edit_protect_only: (optional) If true, only update items affected by\n            edit_protect.\n\n    Returns:\n        None\n    \"\"\"\n    for i in Form.instances:\n        i.update_elements(data_key, edit_protect_only)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.bind","title":"<code>bind(win)</code>","text":"<p>Bind all Form instances to specific window.</p> <p>Not to be confused with bind(), which binds specific form to the window.</p> <p>Parameters:</p> Name Type Description Default <code>win</code> <code>Window</code> <p>The PySimpleGUI window to bind all forms to</p> required Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def bind(win: sg.Window) -&gt; None:\n\"\"\"Bind all `Form` instances to specific window.\n\n    Not to be confused with `Form.bind()`, which binds specific form to the window.\n\n    Args:\n        win: The PySimpleGUI window to bind all forms to\n    \"\"\"\n    for i in Form.instances:\n        i.bind(win)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.simple_transform","title":"<code>simple_transform(dataset, row, encode)</code>","text":"<p>Convenience transform function that makes it easier to add transforms to your records.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def simple_transform(dataset: DataSet, row, encode) -&gt; None:\n\"\"\"Convenience transform function that makes it easier to add transforms to your\n    records.\n    \"\"\"\n    for col, function in dataset._simple_transform.items():\n        if col in row:\n            msg = f\"Transforming {col} from {row[col]}\"\n            if encode == TFORM_DECODE:\n                row[col] = function[\"decode\"](row, col)\n            else:\n                row[col] = function[\"encode\"](row, col)\n            logger.debug(f\"{msg} to {row[col]}\")\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.update_table_element","title":"<code>update_table_element(window, element, values, select_rows)</code>","text":"<p>Updates a PySimpleGUI sg.Table with new data and suppresses extra events emitted.</p> <p>Call this function instead of simply calling update() on a sg.Table element. Without unbinding the virtual \"&lt;&gt;\" event, updating the selection or values will in turn fire more changed events, creating an endless loop of events. <p>Parameters:</p> Name Type Description Default <code>window</code> <code>Window</code> <p>A PySimpleGUI Window containing the sg.Table element to be updated.</p> required <code>element</code> <code>Type[Table]</code> <p>The sg.Table element to be updated.</p> required <code>values</code> <code>List[TableRow]</code> <p>A list of table rows to update the sg.Table with.</p> required <code>select_rows</code> <code>List[int]</code> <p>List of rows to select as if user did.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def update_table_element(\n    window: sg.Window,\n    element: Type[sg.Table],\n    values: List[TableRow],\n    select_rows: List[int],\n) -&gt; None:\n\"\"\"Updates a PySimpleGUI sg.Table with new data and suppresses extra events emitted.\n\n    Call this function instead of simply calling update() on a sg.Table element.\n    Without unbinding the virtual \"&lt;&lt;TreeviewSelect&gt;&gt;\" event, updating the selection or\n    values will in turn fire more changed events, creating an endless loop of events.\n\n    Args:\n        window: A PySimpleGUI Window containing the sg.Table element to be updated.\n        element: The sg.Table element to be updated.\n        values: A list of table rows to update the sg.Table with.\n        select_rows: List of rows to select as if user did.\n\n    Returns:\n        None\n    \"\"\"\n    # Disable handling for \"&lt;&lt;TreeviewSelect&gt;&gt;\" event\n    element.widget.unbind(\"&lt;&lt;TreeviewSelect&gt;&gt;\")\n    # update element\n    element.update(values=values, select_rows=select_rows)\n\n    # make sure row_iid is visible\n    if not isinstance(element, LazyTable) and len(values) and select_rows:\n        row_iid = element.tree_ids[select_rows[0]]\n        element.widget.see(row_iid)\n\n    window.refresh()  # Event handled and bypassed\n    # Enable handling for \"&lt;&lt;TreeviewSelect&gt;&gt;\" event\n    element.widget.bind(\"&lt;&lt;TreeviewSelect&gt;&gt;\", element._treeview_selected)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.checkbox_to_bool","title":"<code>checkbox_to_bool(value)</code>","text":"<p>Allows a variety of checkbox values to still return True or False.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, int, bool]</code> <p>Value to convert into True or False</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def checkbox_to_bool(value: Union[str, int, bool]) -&gt; bool:\n\"\"\"Allows a variety of checkbox values to still return True or False.\n\n    Args:\n        value: Value to convert into True or False\n\n    Returns:\n        bool\n    \"\"\"\n    return str(value).lower() in [\n        \"y\",\n        \"yes\",\n        \"t\",\n        \"true\",\n        \"1\",\n        \"on\",\n        \"enabled\",\n        themepack.checkbox_true,\n    ]\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.shake_widget","title":"<code>shake_widget(widget, pixels=4, delay_ms=50, repeat=2)</code>","text":"<p>Shakes the given widget by modifying its padx attribute.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>Union[Element, Widget]</code> <p>The widget to shake. Must be an instance of sg.Element or tk.Widget.</p> required <code>pixels</code> <code>int</code> <p>The number of pixels by which to shake the widget horizontally.</p> <code>4</code> <code>delay_ms</code> <code>int</code> <p>The delay in milliseconds between each shake movement.</p> <code>50</code> <code>repeat</code> <code>int</code> <p>The number of times to repeat the shaking movement.</p> <code>2</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def shake_widget(\n    widget: Union[sg.Element, tk.Widget],\n    pixels: int = 4,\n    delay_ms: int = 50,\n    repeat: int = 2,\n) -&gt; None:\n\"\"\"Shakes the given widget by modifying its padx attribute.\n\n    Args:\n        widget: The widget to shake. Must be an instance of sg.Element or tk.Widget.\n        pixels: The number of pixels by which to shake the widget horizontally.\n        delay_ms: The delay in milliseconds between each shake movement.\n        repeat: The number of times to repeat the shaking movement.\n    \"\"\"\n    if isinstance(widget, sg.Element):\n        widget = widget.Widget\n    elif not isinstance(widget, tk.Widget):\n        logger.debug(f\"{widget} not a valid sg.Element or tk.Widget\")\n        return\n    padx = widget.pack_info().get(\"padx\", 0)\n\n    # Adjust padx based on its current value\n    if isinstance(padx, tuple):\n        padx_left = padx[0] + pixels\n        padx_right = padx[1] - pixels\n        new_padx = (padx_left, padx_right)\n    else:\n        padx_left = padx + pixels\n        padx_right = max(padx - pixels, 0)\n        new_padx = (padx_left, padx_right)\n\n    widget.update()\n\n    # Perform the shaking movement\n    for _ in range(repeat):\n        widget.pack_configure(padx=new_padx)\n        widget.update()\n        widget.after(delay_ms)\n        widget.pack_configure(padx=padx)\n        widget.update()\n        widget.after(delay_ms)\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.field","title":"<code>field(field, element=_EnhancedInput, size=None, label='', no_label=False, label_above=False, quick_editor=True, quick_editor_kwargs=None, filter=None, key=None, use_ttk_buttons=None, pad=None, **kwargs)</code>","text":"<p>Convenience function for adding PySimpleGUI elements to the Window, so they are properly configured for pysimplesql. The automatic functionality of pysimplesql relies on accompanying metadata so that the auto_map_elements() can pick them up. This convenience function will create a text label, along with an element with the above metadata already set up for you. Note: The element key will default to the field name if none is supplied.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The database record in the form of table.column I.e. 'Journal.entry'</p> required <code>element</code> <code>Union[Type[Checkbox], Type[Combo], Type[Input], Type[Multiline]]</code> <p>(optional) The element type desired (defaults to PySimpleGUI.Input)</p> <code>_EnhancedInput</code> <code>size</code> <code>Tuple[int, int]</code> <p>Overrides the default element size for this element only.</p> <code>None</code> <code>label</code> <code>str</code> <p>The text/label will automatically be generated from the column name. If a different text/label is desired, it can be specified here.</p> <code>''</code> <code>no_label</code> <code>bool</code> <p>Do not automatically generate a label for this element</p> <code>False</code> <code>label_above</code> <code>bool</code> <p>Place the label above the element instead of to the left.</p> <code>False</code> <code>quick_editor</code> <code>bool</code> <p>For records that reference another table, place a quick edit button next to the element</p> <code>True</code> <code>quick_editor_kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to quick editor.</p> <code>None</code> <code>filter</code> <p>Can be used to reference different Forms in the same layout. Use a matching filter when creating the Form with the filter parameter.</p> <code>None</code> <code>key</code> <p>(optional) The key to give this element. See note above about the default auto generated key.</p> <code>None</code> <code>use_ttk_buttons</code> <p>Use ttk buttons for all action buttons. If None, defaults to setting use_ttk_buttons.</p> <code>None</code> <code>pad</code> <p>The padding to use for the generated elements. If None, defaults to setting default_element_pad.</p> <code>None</code> <code>**kwargs</code> <p>Any additional arguments will be passed to the PySimpleGUI element.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Column</code> <p>Element(s) to be used in the creation of PySimpleGUI layouts.  Note that this</p> <code>Column</code> <p>function actually creates multiple Elements wrapped in a PySimpleGUI Column, but</p> <code>Column</code> <p>can be treated as a single Element.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def field(\n    field: str,\n    element: Union[\n        Type[sg.Checkbox],\n        Type[sg.Combo],\n        Type[sg.Input],\n        Type[sg.Multiline],\n    ] = _EnhancedInput,\n    size: Tuple[int, int] = None,\n    label: str = \"\",\n    no_label: bool = False,\n    label_above: bool = False,\n    quick_editor: bool = True,\n    quick_editor_kwargs: dict = None,\n    filter=None,\n    key=None,\n    use_ttk_buttons=None,\n    pad=None,\n    **kwargs,\n) -&gt; sg.Column:\n\"\"\"Convenience function for adding PySimpleGUI elements to the Window, so they are\n    properly configured for pysimplesql. The automatic functionality of pysimplesql\n    relies on accompanying metadata so that the `Form.auto_map_elements()` can pick them\n    up. This convenience function will create a text label, along with an element with\n    the above metadata already set up for you. Note: The element key will default to the\n    field name if none is supplied.\n\n    Args:\n        field: The database record in the form of table.column I.e. 'Journal.entry'\n        element: (optional) The element type desired (defaults to PySimpleGUI.Input)\n        size: Overrides the default element size for this element only.\n        label: The text/label will automatically be generated from the column name. If a\n            different text/label is desired, it can be specified here.\n        no_label: Do not automatically generate a label for this element\n        label_above: Place the label above the element instead of to the left.\n        quick_editor: For records that reference another table, place a quick edit\n            button next to the element\n        quick_editor_kwargs: Additional keyword arguments to pass to quick editor.\n        filter: Can be used to reference different `Form`s in the same layout. Use a\n            matching filter when creating the `Form` with the filter parameter.\n        key: (optional) The key to give this element. See note above about the default\n            auto generated key.\n        use_ttk_buttons: Use ttk buttons for all action buttons. If None, defaults to\n            setting `ThemePack.use_ttk_buttons`.\n        pad: The padding to use for the generated elements. If None, defaults to setting\n            `ThemePack.default_element_pad`.\n        **kwargs: Any additional arguments will be passed to the PySimpleGUI element.\n\n    Returns:\n        Element(s) to be used in the creation of PySimpleGUI layouts.  Note that this\n        function actually creates multiple Elements wrapped in a PySimpleGUI Column, but\n        can be treated as a single Element.\n    \"\"\"\n    # TODO: See what the metadata does after initial setup is complete - needed anymore?\n    element = _EnhancedInput if element == sg.Input else element\n    element = _EnhancedMultiline if element == sg.Multiline else element\n    element = _AutocompleteCombo if element == sg.Combo else element\n\n    if use_ttk_buttons is None:\n        use_ttk_buttons = themepack.use_ttk_buttons\n    if pad is None:\n        pad = themepack.default_element_pad\n\n    # if Record imply a where clause (indicated by ?) If so, strip out the info we need\n    if \"?\" in field:\n        table_info, where_info = field.split(\"?\")\n        label_text = (\n            where_info.split(\"=\")[1].replace(\"fk\", \"\").replace(\"_\", \" \").capitalize()\n            + \":\"\n        )\n    else:\n        table_info = field\n        label_text = (\n            table_info.split(\".\")[1].replace(\"fk\", \"\").replace(\"_\", \" \").capitalize()\n            + \":\"\n        )\n    table, column = table_info.split(\".\")\n\n    key = field if key is None else key\n    key = keygen.get(key)\n\n    if \"values\" in kwargs:\n        first_param = kwargs[\"values\"]\n        del kwargs[\"values\"]  # make sure we don't put it in twice\n    else:\n        first_param = \"\"\n\n    if element == _EnhancedMultiline:\n        layout_element = element(\n            first_param,\n            key=key,\n            size=size or themepack.default_mline_size,\n            metadata={\n                \"type\": ElementType.FIELD,\n                \"Form\": None,\n                \"filter\": filter,\n                \"field\": field,\n                \"data_key\": key,\n            },\n            pad=pad,\n            **kwargs,\n        )\n    else:\n        layout_element = element(\n            first_param,\n            key=key,\n            size=size or themepack.default_element_size,\n            metadata={\n                \"type\": ElementType.FIELD,\n                \"Form\": None,\n                \"filter\": filter,\n                \"field\": field,\n                \"data_key\": key,\n            },\n            pad=pad,\n            **kwargs,\n        )\n    layout_label = sg.Text(\n        label if label else label_text,\n        size=themepack.default_label_size,\n        key=f\"{key}:label\",\n    )\n    # Marker for required (notnull) records\n    layout_marker = sg.Column(\n        [\n            [\n                sg.T(\n                    themepack.marker_required,\n                    key=f\"{key}:marker\",\n                    text_color=sg.theme_background_color(),\n                    visible=True,\n                )\n            ]\n        ],\n        pad=(0, 0),\n    )\n    if no_label:\n        layout = [[layout_marker, layout_element]]\n    elif label_above:\n        layout = [[layout_label], [layout_marker, layout_element]]\n    else:\n        layout = [[layout_label, layout_marker, layout_element]]\n    # Add the quick editor button where appropriate\n    if element == _AutocompleteCombo and quick_editor:\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.QUICK_EDIT,\n            \"table\": table,\n            \"column\": column,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n            \"quick_editor_kwargs\": quick_editor_kwargs,\n        }\n        if type(themepack.quick_edit) is bytes:\n            layout[-1].append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}.quick_edit\"),\n                    size=(1, 1),\n                    image_data=themepack.quick_edit,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                )\n            )\n        else:\n            layout[-1].append(\n                sg.B(\n                    themepack.quick_edit,\n                    key=keygen.get(f\"{key}.quick_edit\"),\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                )\n            )\n    # return layout\n    return sg.Col(layout=layout, pad=(0, 0))\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.actions","title":"<code>actions(table, key=None, default=True, edit_protect=None, navigation=None, insert=None, delete=None, duplicate=None, save=None, search=None, search_size=(30, 1), bind_return_key=True, filter=None, use_ttk_buttons=None, pad=None, **kwargs)</code>","text":"<p>Allows for easily adding record navigation and record action elements to the PySimpleGUI window The navigation elements are generated automatically (first, previous, next, last and search).  The action elements can be customized by selecting which ones you want generated from the parameters available.  This allows full control over what is available to the user of your database application. Check out ThemePack to give any of these autogenerated controls a custom look!.</p> <p>Note: By default, the base element keys generated for PySimpleGUI will be <code>table:action</code> using the name of the table passed in the table parameter plus the action strings below separated by a colon: (I.e. Journal:table_insert) edit_protect, db_save, table_first, table_previous, table_next, table_last, table_duplicate, table_insert, table_delete, search_input, search_button. If you supply a key with the key parameter, then these additional strings will be appended to that key. Also note that these autogenerated keys also pass through the KeyGen, so it's possible that these keys could be table_last:action!1, table_last:action!2, etc.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table name that this \"element\" will provide actions for</p> required <code>key</code> <p>(optional) The base key to give the generated elements</p> <code>None</code> <code>default</code> <code>bool</code> <p>Default edit_protect, navigation, insert, delete, save and search to either true or false (defaults to True) The individual keyword arguments will trump the default parameter.  This allows for starting with all actions defaulting to False, then individual ones can be enabled with True - or the opposite by defaulting them all to True, and disabling the ones not needed with False.</p> <code>True</code> <code>edit_protect</code> <code>bool</code> <p>An edit protection mode to prevent accidental changes in the database. It is a button that toggles the ability on and off to prevent accidental changes in the database by enabling/disabling the insert, edit, duplicate, delete and save buttons.</p> <code>None</code> <code>navigation</code> <code>bool</code> <p>The standard &lt;&lt; &lt; &gt; &gt;&gt; (First, previous, next, last) buttons for navigation</p> <code>None</code> <code>insert</code> <code>bool</code> <p>Button to insert new records</p> <code>None</code> <code>delete</code> <code>bool</code> <p>Button to delete current record</p> <code>None</code> <code>duplicate</code> <code>bool</code> <p>Button to duplicate current record</p> <code>None</code> <code>save</code> <code>bool</code> <p>Button to save record.  Note that the save button feature saves changes made to any table, therefore only one save button is needed per window.</p> <code>None</code> <code>search</code> <code>bool</code> <p>A search Input element. Size can be specified with the 'search_size' parameter</p> <code>None</code> <code>search_size</code> <code>Tuple[int, int]</code> <p>The size of the search input element</p> <code>(30, 1)</code> <code>bind_return_key</code> <code>bool</code> <p>Bind the return key to the search button. Defaults to true.</p> <code>True</code> <code>filter</code> <code>str</code> <p>Can be used to reference different Forms in the same layout.  Use a matching filter when creating the Form with the filter parameter.</p> <code>None</code> <code>use_ttk_buttons</code> <code>bool</code> <p>Use ttk buttons for all action buttons. If None, defaults to setting use_ttk_buttons.</p> <code>None</code> <code>pad</code> <p>The padding to use for the generated elements. If None, defaults to setting action_button_pad.</p> <code>None</code> <code>**kwargs</code> <p>Any additional arguments will be passed to the PySimpleGUI element.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Column</code> <p>An element to be used in the creation of PySimpleGUI layouts.  Note that this is</p> <code>Column</code> <p>technically multiple elements wrapped in a PySimpleGUI.Column, but acts as one</p> <code>Column</code> <p>element for the purpose of layout building.</p> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def actions(\n    table: str,\n    key=None,\n    default: bool = True,\n    edit_protect: bool = None,\n    navigation: bool = None,\n    insert: bool = None,\n    delete: bool = None,\n    duplicate: bool = None,\n    save: bool = None,\n    search: bool = None,\n    search_size: Tuple[int, int] = (30, 1),\n    bind_return_key: bool = True,\n    filter: str = None,\n    use_ttk_buttons: bool = None,\n    pad=None,\n    **kwargs,\n) -&gt; sg.Column:\n\"\"\"Allows for easily adding record navigation and record action elements to the\n    PySimpleGUI window The navigation elements are generated automatically (first,\n    previous, next, last and search).  The action elements can be customized by\n    selecting which ones you want generated from the parameters available.  This allows\n    full control over what is available to the user of your database application. Check\n    out `ThemePack` to give any of these autogenerated controls a custom look!.\n\n    Note: By default, the base element keys generated for PySimpleGUI will be\n    `table:action` using the name of the table passed in the table parameter plus the\n    action strings below separated by a colon: (I.e. Journal:table_insert) edit_protect,\n    db_save, table_first, table_previous, table_next, table_last, table_duplicate,\n    table_insert, table_delete, search_input, search_button. If you supply a key with\n    the key parameter, then these additional strings will be appended to that key. Also\n    note that these autogenerated keys also pass through the `KeyGen`, so it's possible\n    that these keys could be table_last:action!1, table_last:action!2, etc.\n\n    Args:\n        table: The table name that this \"element\" will provide actions for\n        key: (optional) The base key to give the generated elements\n        default: Default edit_protect, navigation, insert, delete, save and search to\n            either true or false (defaults to True) The individual keyword arguments\n            will trump the default parameter.  This allows for starting with all actions\n            defaulting to False, then individual ones can be enabled with True - or the\n            opposite by defaulting them all to True, and disabling the ones not needed\n            with False.\n        edit_protect: An edit protection mode to prevent accidental changes in the\n            database. It is a button that toggles the ability on and off to prevent\n            accidental changes in the database by enabling/disabling the insert, edit,\n            duplicate, delete and save buttons.\n        navigation: The standard &lt;&lt; &lt; &gt; &gt;&gt; (First, previous, next, last) buttons for\n            navigation\n        insert: Button to insert new records\n        delete: Button to delete current record\n        duplicate: Button to duplicate current record\n        save: Button to save record.  Note that the save button feature saves changes\n            made to any table, therefore only one save button is needed per window.\n        search: A search Input element. Size can be specified with the 'search_size'\n            parameter\n        search_size: The size of the search input element\n        bind_return_key: Bind the return key to the search button. Defaults to true.\n        filter: Can be used to reference different `Form`s in the same layout.  Use a\n            matching filter when creating the `Form` with the filter parameter.\n        use_ttk_buttons: Use ttk buttons for all action buttons. If None, defaults to\n            setting `ThemePack.use_ttk_buttons`.\n        pad: The padding to use for the generated elements. If None, defaults to setting\n            `ThemePack.action_button_pad`.\n        **kwargs: Any additional arguments will be passed to the PySimpleGUI element.\n\n    Returns:\n        An element to be used in the creation of PySimpleGUI layouts.  Note that this is\n        technically multiple elements wrapped in a PySimpleGUI.Column, but acts as one\n        element for the purpose of layout building.\n    \"\"\"\n    if use_ttk_buttons is None:\n        use_ttk_buttons = themepack.use_ttk_buttons\n    if pad is None:\n        pad = themepack.action_button_pad\n\n    edit_protect = default if edit_protect is None else edit_protect\n    navigation = default if navigation is None else navigation\n    insert = default if insert is None else insert\n    delete = default if delete is None else delete\n    duplicate = default if duplicate is None else duplicate\n    save = default if save is None else save\n    search = default if search is None else search\n    key = f\"{table}:\" if key is None else f\"{key}:\"\n\n    layout = []\n\n    # Form-level events\n    if edit_protect:\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.EDIT_PROTECT_DB,\n            \"table\": None,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.edit_protect) is bytes:\n            layout.append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}edit_protect\"),\n                    size=(1, 1),\n                    image_data=themepack.edit_protect,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        else:\n            layout.append(\n                sg.B(\n                    themepack.edit_protect,\n                    key=keygen.get(f\"{key}edit_protect\"),\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n    if save:\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.SAVE_DB,\n            \"table\": None,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.save) is bytes:\n            layout.append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}db_save\"),\n                    image_data=themepack.save,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        else:\n            layout.append(\n                sg.B(themepack.save, key=keygen.get(f\"{key}db_save\"), metadata=meta)\n            )\n\n    # DataSet-level events\n    if navigation:\n        # first\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.FIRST,\n            \"table\": table,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.first) is bytes:\n            layout.append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}table_first\"),\n                    size=(1, 1),\n                    image_data=themepack.first,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        else:\n            layout.append(\n                sg.B(\n                    themepack.first,\n                    key=keygen.get(f\"{key}table_first\"),\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        # previous\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.PREVIOUS,\n            \"table\": table,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.previous) is bytes:\n            layout.append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}table_previous\"),\n                    size=(1, 1),\n                    image_data=themepack.previous,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        else:\n            layout.append(\n                sg.B(\n                    themepack.previous,\n                    key=keygen.get(f\"{key}table_previous\"),\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        # next\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.NEXT,\n            \"table\": table,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.next) is bytes:\n            layout.append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}table_next\"),\n                    size=(1, 1),\n                    image_data=themepack.next,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        else:\n            layout.append(\n                sg.B(\n                    themepack.next,\n                    key=keygen.get(f\"{key}table_next\"),\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        # last\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.LAST,\n            \"table\": table,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.last) is bytes:\n            layout.append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}table_last\"),\n                    size=(1, 1),\n                    image_data=themepack.last,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        else:\n            layout.append(\n                sg.B(\n                    themepack.last,\n                    key=keygen.get(f\"{key}table_last\"),\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n    if duplicate:\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.DUPLICATE,\n            \"table\": table,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.duplicate) is bytes:\n            layout.append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}table_duplicate\"),\n                    size=(1, 1),\n                    image_data=themepack.duplicate,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        else:\n            layout.append(\n                sg.B(\n                    themepack.duplicate,\n                    key=keygen.get(f\"{key}table_duplicate\"),\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n    if insert:\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.INSERT,\n            \"table\": table,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.insert) is bytes:\n            layout.append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}table_insert\"),\n                    size=(1, 1),\n                    image_data=themepack.insert,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        else:\n            layout.append(\n                sg.B(\n                    themepack.insert,\n                    key=keygen.get(f\"{key}table_insert\"),\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n    if delete:\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.DELETE,\n            \"table\": table,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.delete) is bytes:\n            layout.append(\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}table_delete\"),\n                    size=(1, 1),\n                    image_data=themepack.delete,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n        else:\n            layout.append(\n                sg.B(\n                    themepack.delete,\n                    key=keygen.get(f\"{key}table_delete\"),\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                )\n            )\n    if search:\n        meta = {\n            \"type\": ElementType.EVENT,\n            \"event_type\": EventType.SEARCH,\n            \"table\": table,\n            \"column\": None,\n            \"function\": None,\n            \"Form\": None,\n            \"filter\": filter,\n        }\n        if type(themepack.search) is bytes:\n            layout += [\n                _SearchInput(\n                    \"\", key=keygen.get(f\"{key}search_input\"), size=search_size\n                ),\n                sg.B(\n                    \"\",\n                    key=keygen.get(f\"{key}search_button\"),\n                    bind_return_key=bind_return_key,\n                    size=(1, 1),\n                    image_data=themepack.search,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                ),\n            ]\n        else:\n            layout += [\n                _SearchInput(\n                    \"\", key=keygen.get(f\"{key}search_input\"), size=search_size\n                ),\n                sg.B(\n                    themepack.search,\n                    key=keygen.get(f\"{key}search_button\"),\n                    bind_return_key=bind_return_key,\n                    metadata=meta,\n                    use_ttk_buttons=use_ttk_buttons,\n                    pad=pad,\n                    **kwargs,\n                ),\n            ]\n    return sg.Col(layout=[layout], pad=(0, 0))\n</code></pre>"},{"location":"#pysimplesql.pysimplesql.selector","title":"<code>selector(table, element=sg.Listbox, size=None, filter=None, key=None, **kwargs)</code>","text":"<p>Selectors in pysimplesql are special elements that allow the user to change records in the database application. For example, Listboxes, Comboboxes and Tables all provide a convenient way to users to choose which record they want to select. This convenience function makes creating selectors very quick and as easy as using a normal PySimpleGUI element.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table name that this selector will act on.</p> required <code>element</code> <code>Union[Type[Combo], Type[LazyTable], Type[Listbox], Type[Slider], Type[Table], TableBuilder]</code> <p>The type of element you would like to use as a selector (defaults to a Listbox)</p> <code>Listbox</code> <code>size</code> <code>Tuple[int, int]</code> <p>The desired size of this selector element</p> <code>None</code> <code>filter</code> <code>str</code> <p>Can be used to reference different Forms in the same layout. Use a matching filter when creating the Form with the filter parameter.</p> <code>None</code> <code>key</code> <code>str</code> <p>(optional) The key to give to this selector. If no key is provided, it will default to table:selector using the name specified in the table parameter. This is also passed through the keygen, so if selectors all use the default name, they will be made unique. ie: Journal:selector!1, Journal:selector!2, etc.</p> <code>None</code> <code>**kwargs</code> <p>Any additional arguments supplied will be passed on to the PySimpleGUI element. Note: TableBuilder objects bring their own kwargs.</p> <code>{}</code> Source code in <code>pysimplesql\\pysimplesql.py</code> <pre><code>def selector(\n    table: str,\n    element: Union[\n        Type[sg.Combo],\n        Type[LazyTable],\n        Type[sg.Listbox],\n        Type[sg.Slider],\n        Type[sg.Table],\n        TableBuilder,\n    ] = sg.Listbox,\n    size: Tuple[int, int] = None,\n    filter: str = None,\n    key: str = None,\n    **kwargs,\n) -&gt; sg.Element:\n\"\"\"Selectors in pysimplesql are special elements that allow the user to change\n    records in the database application. For example, Listboxes, Comboboxes and Tables\n    all provide a convenient way to users to choose which record they want to select.\n    This convenience function makes creating selectors very quick and as easy as using a\n    normal PySimpleGUI element.\n\n    Args:\n        table: The table name that this selector will act on.\n        element: The type of element you would like to use as a selector (defaults to a\n            Listbox)\n        size: The desired size of this selector element\n        filter: Can be used to reference different `Form`s in the same layout. Use a\n            matching filter when creating the `Form` with the filter parameter.\n        key: (optional) The key to give to this selector. If no key is provided, it will\n            default to table:selector using the name specified in the table parameter.\n            This is also passed through the keygen, so if selectors all use the default\n            name, they will be made unique. ie: Journal:selector!1, Journal:selector!2,\n            etc.\n        **kwargs: Any additional arguments supplied will be passed on to the PySimpleGUI\n            element. Note: TableBuilder objects bring their own kwargs.\n    \"\"\"\n    element = _AutocompleteCombo if element == sg.Combo else element\n\n    key = f\"{table}:selector\" if key is None else key\n    key = keygen.get(key)\n\n    meta = {\n        \"type\": ElementType.SELECTOR,\n        \"table\": table,\n        \"Form\": None,\n        \"filter\": filter,\n    }\n    if element == sg.Listbox:\n        layout = element(\n            values=(),\n            size=size or themepack.default_element_size,\n            key=key,\n            select_mode=sg.LISTBOX_SELECT_MODE_SINGLE,\n            enable_events=True,\n            metadata=meta,\n        )\n    elif element == sg.Slider:\n        layout = element(\n            enable_events=True,\n            size=size or themepack.default_element_size,\n            orientation=\"h\",\n            disable_number_display=True,\n            key=key,\n            metadata=meta,\n        )\n    elif element == _AutocompleteCombo:\n        w = themepack.default_element_size[0]\n        layout = element(\n            values=(),\n            size=size or (w, 10),\n            enable_events=True,\n            key=key,\n            auto_size_text=False,\n            metadata=meta,\n        )\n    elif element in [sg.Table, LazyTable]:\n        required_kwargs = [\"headings\", \"visible_column_map\", \"num_rows\"]\n        for kwarg in required_kwargs:\n            if kwarg not in kwargs:\n                raise RuntimeError(\n                    f\"DataSet selectors must use the {kwarg} keyword argument.\"\n                )\n        # Create a narrow column for displaying a * character for virtual rows.\n        # This will be the 1st column\n        kwargs[\"headings\"].insert(0, \"\")\n        kwargs[\"visible_column_map\"].insert(0, 1)\n        if \"col_widths\" in kwargs:\n            kwargs[\"col_widths\"].insert(0, themepack.unsaved_column_width)\n\n        # Create other kwargs that are required\n        kwargs[\"enable_events\"] = True\n        kwargs[\"select_mode\"] = sg.TABLE_SELECT_MODE_BROWSE\n        kwargs[\"justification\"] = \"left\"\n\n        # Make an empty list of values\n        vals = [[\"\"] * len(kwargs[\"headings\"])]\n        layout = element(values=vals, key=key, metadata=meta, **kwargs)\n    elif isinstance(element, TableBuilder):\n        table_builder = element\n        element = table_builder.element\n        lazy = table_builder.lazy_loading\n        kwargs = table_builder.get_table_kwargs()\n\n        meta[\"TableBuilder\"] = table_builder\n        # Make an empty list of values\n        vals = [[\"\"] * len(kwargs[\"headings\"])]\n        layout = element(\n            vals,\n            lazy_loading=lazy,\n            key=key,\n            metadata=meta,\n            **kwargs,\n        )\n    else:\n        raise RuntimeError(f'Element type \"{element}\" not supported as a selector.')\n\n    return layout\n</code></pre>"}]}